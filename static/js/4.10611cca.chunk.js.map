{"version":3,"sources":["../node_modules/rollup/dist/es/shared/watch.js","../node_modules/os-browserify/browser.js"],"names":["utils","createCommonjsModule","module","exports","isInteger","num","Number","trim","find","node","type","nodes","exceedsLimit","min","max","step","limit","escapeNode","block","n","escaped","value","encloseBrace","commas","ranges","invalid","isInvalidBrace","dollar","open","close","isOpenOrClose","reduce","acc","push","flatten","result","flat","arr","i","length","ele","Array","isArray","args","stringify","ast","options","parent","invalidBlock","escapeInvalid","invalidNode","output","child","isNumber","isFinite","toRegexRange","TypeError","String","opts","relaxZeros","strictZeros","cacheKey","shorthand","capture","wrap","cache","hasOwnProperty","a","Math","b","abs","isPadded","hasPadding","state","positives","negatives","maxLen","splitToPatterns","neg","pos","onlyNegative","filterPatterns","onlyPositive","intersected","concat","join","collatePatterns","rangeToPattern","start","stop","pattern","count","digits","zipped","zip","startDigit","stopDigit","toCharacterClass","tok","prev","nines","zeros","countNines","stops","Set","add","countZeros","sort","compare","splitToRanges","tokens","obj","padZeros","string","toQuantifier","pop","comparison","prefix","intersection","contains","key","val","some","len","slice","repeat","integer","pow","str","test","diff","relax","clearCache","toRegexRange_1","isObject","transform","toNumber","isValidValue","isNumber$1","input","index","stringify$1","end","pad","maxLength","dash","padStart","toMaxLen","negative","toSequence","parts","toRange","isNumbers","fromCharCode","toRegex","rangeError","RangeError","util","inspect","invalidRange","strictRanges","invalidStep","fillNumbers","descending","startString","endString","stepString","padded","format","range","fillLetters","charCodeAt","fillRange","fill","compile_1","walk","isOpen","isClose","append","queue","stash","enclose","map","item","expand_1","rangeLimit","p","q","MAX_LENGTH","CHAR_BACKSLASH","CHAR_BACKTICK","CHAR_COMMA","CHAR_DOT","CHAR_LEFT_PARENTHESES","CHAR_RIGHT_PARENTHESES","CHAR_LEFT_CURLY_BRACE","CHAR_RIGHT_CURLY_BRACE","CHAR_LEFT_SQUARE_BRACKET","CHAR_RIGHT_SQUARE_BRACKET","CHAR_DOUBLE_QUOTE","CHAR_SINGLE_QUOTE","CHAR_NO_BREAK_SPACE","CHAR_ZERO_WIDTH_NOBREAK_SPACE","parse_1","SyntaxError","stack","brackets","depth","advance","shift","siblings","before","brace","next","keepQuotes","keepEscaping","forEach","indexOf","splice","braces","create","expand","nodupes","parse","compile","noempty","filter","Boolean","braces_1","WIN_NO_SLASH","END_ANCHOR","START_ANCHOR","DOTS_SLASH","POSIX_CHARS","DOT_LITERAL","PLUS_LITERAL","QMARK_LITERAL","SLASH_LITERAL","ONE_CHAR","QMARK","NO_DOT","NO_DOTS","NO_DOT_SLASH","NO_DOTS_SLASH","QMARK_NO_DOT","STAR","WINDOWS_CHARS","constants$1","POSIX_REGEX_SOURCE","alnum","alpha","ascii","blank","cntrl","digit","graph","lower","print","punct","space","upper","word","xdigit","REGEX_BACKSLASH","REGEX_NON_SPECIAL_CHARS","REGEX_SPECIAL_CHARS","REGEX_SPECIAL_CHARS_BACKREF","REGEX_SPECIAL_CHARS_GLOBAL","REGEX_REMOVE_BACKSLASH","REPLACEMENTS","CHAR_0","CHAR_9","CHAR_UPPERCASE_A","CHAR_LOWERCASE_A","CHAR_UPPERCASE_Z","CHAR_LOWERCASE_Z","CHAR_ASTERISK","CHAR_AMPERSAND","CHAR_AT","CHAR_BACKWARD_SLASH","CHAR_CARRIAGE_RETURN","CHAR_CIRCUMFLEX_ACCENT","CHAR_COLON","CHAR_EQUAL","CHAR_EXCLAMATION_MARK","CHAR_FORM_FEED","CHAR_FORWARD_SLASH","CHAR_GRAVE_ACCENT","CHAR_HASH","CHAR_HYPHEN_MINUS","CHAR_LEFT_ANGLE_BRACKET","CHAR_LINE_FEED","CHAR_PERCENT","CHAR_PLUS","CHAR_QUESTION_MARK","CHAR_RIGHT_ANGLE_BRACKET","CHAR_SEMICOLON","CHAR_SPACE","CHAR_TAB","CHAR_UNDERSCORE","CHAR_VERTICAL_LINE","SEP","path","sep","extglobChars","chars","globChars","win32","utils$1","process","platform","hasRegexChars","isRegexChar","escapeRegex","replace","toPosixSlashes","removeBackslashes","match","supportsLookbehinds","segs","version","split","isWindows","windows","escapeLast","char","lastIdx","idx","lastIndexOf","removePrefix","startsWith","wrapOutput","prepend","negated","CHAR_COMMA$1","CHAR_DOT$1","CHAR_LEFT_CURLY_BRACE$1","CHAR_LEFT_PARENTHESES$1","CHAR_LEFT_SQUARE_BRACKET$1","CHAR_RIGHT_CURLY_BRACE$1","CHAR_RIGHT_PARENTHESES$1","CHAR_RIGHT_SQUARE_BRACKET$1","isPathSeparator","code","token","isPrefix","isGlobstar","Infinity","scan_1","scanToEnd","slashes","lastIndex","isBrace","isBracket","isGlob","isExtglob","braceEscaped","backslashes","finished","eos","noext","nonegate","noparen","base","glob","unescape","maxDepth","prevIndex","MAX_LENGTH$1","POSIX_REGEX_SOURCE$1","expandRange","syntaxError","parse$1","bos","PLATFORM_CHARS","EXTGLOB_CHARS","globstar","dot","nodot","qmarkNoDot","star","bash","noextglob","consumed","backtrack","parens","quotes","extglobs","peek","remaining","consume","negate","increment","decrement","extglob","inner","extglobOpen","conditions","extglobClose","extglobStar","includes","negatedExtglob","fastpaths","m","esc","first","rest","exec","posix","pre","nobrace","regex","noglobstar","prior","isStart","afterStar","after","strictSlashes","Error","dots","comma","unshift","out","outputIndex","toks","tokensIndex","t","nobracket","strictBrackets","prevValue","literalBrackets","suffix","slashDot","source","parse_1$1","isObject$1","picomatch","returnState","fns","arrayMatcher","isMatch","isState","compileRe","makeRe","isIgnored","ignore","ignoreOpts","onMatch","onResult","matcher","returnObject","onIgnore","matchBase","basename","RegExp","patterns","scan","parsed","returnOutput","undefined","flags","nocase","err","debug","constants","picomatch$1","isEmptyString","micromatch","list","omit","keep","items","matched","delete","matches","has","failglob","nonull","nullglob","any","not","matchKeys","keys","Object","res","every","all","v","braceExpand","micromatch_1","ensureArray","thing","getMatcherString","id","resolutionBase","resolve","commandAliases","c","d","e","f","g","h","o","w","getCommandOptions","rawCommandOptions","external","globals","globalDefinition","variableName","mergeInputOptions","config","overrides","defaultOnWarnHandler","getOption","name","_a","inputOptions","acorn","acornInjectPlugins","context","experimentalCacheExpiry","getExternal","inlineDynamicImports","manualChunks","moduleContext","onwarn","getOnWarn","perf","plugins","ensureArray$1","preserveEntrySignatures","preserveModules","preserveSymlinks","shimMissingExports","strictDeprecations","treeshake","getObjectOption","watch","getWatch","warnUnknownOptions","configExternal","importer","isResolved","warning","commandOption","normalizeObjectOptionValue","configOption","optionValue","mergeOutputOptions","warn","outputOptions","amd","assetFileNames","banner","chunkFileNames","compact","dir","dynamicImportFunction","entryFileNames","esModule","extend","externalLiveBindings","file","footer","freeze","hoistTransitiveImports","indent","interop","intro","minifyInternalExports","namespaceToStringTag","noConflict","outro","paths","preferConst","sourcemap","sourcemapExcludeSources","sourcemapFile","sourcemapPathTransform","strict","systemNullSetters","Readable","stream","promisify","readdir","fs","stat","lstat","realpath","NORMAL_FLOW_ERRORS","FILE_TYPE","DIR_TYPE","FILE_DIR_TYPE","EVERYTHING_TYPE","ALL_TYPES","normalizeFilter","entry","positive","trimmed","charAt","ReaddirpStream","objectMode","autoDestroy","highWaterMark","defaultOptions","root","_fileFilter","fileFilter","_directoryFilter","directoryFilter","statMethod","_stat","bigint","_maxDepth","_wantsDir","_wantsFile","_wantsEverything","_root","_isDirent","alwaysStat","_statsProp","_rdOptions","encoding","withFileTypes","parents","_exploreDir","reading","batch","this","files","dirent","_formatEntry","Promise","destroyed","_getEntryType","entryType","fullPath","_includeAsFile","destroy","_onError","path$1","relative","error","emit","stats","isFile","isDirectory","isSymbolicLink","entryRealPath","entryRealPathStats","readdirp","promise","reject","on","default","readdirp_1","normalizePath","stripTrailing","ch","anymatch_1","defineProperty","DEFAULT_OPTIONS","returnIndex","arrify","createPattern","matchPatterns","negPatterns","isList","_path","prototype","toString","call","nglob","applied","anymatch","matchers","testString","mtchers","negatedGlobs","ri","strictRegex","relaxedRegex","pathPosixDirname","dirname","isWin32","os","backslash","enclosure","globby","binaryExtensions$1","__proto__","require$$0","getCjsExportFromNamespace","extensions","constants$2","EV_ALL","EV_READY","EV_ADD","EV_CHANGE","EV_ADD_DIR","EV_UNLINK","EV_UNLINK_DIR","EV_RAW","EV_ERROR","STR_DATA","STR_END","STR_CLOSE","FSEVENT_CREATED","FSEVENT_MODIFIED","FSEVENT_DELETED","FSEVENT_MOVED","FSEVENT_CLONED","FSEVENT_UNKNOWN","FSEVENT_TYPE_FILE","FSEVENT_TYPE_DIRECTORY","FSEVENT_TYPE_SYMLINK","KEY_LISTENERS","KEY_ERR","KEY_RAW","HANDLER_KEYS","DOT_SLASH","BACK_SLASH_RE","DOUBLE_SLASH_RE","SLASH_OR_BACK_SLASH_RE","DOT_RE","REPLACER_RE","SLASH","BRACE_START","BANG","ONE_DOT","TWO_DOTS","GLOBSTAR","ROOT_GLOBSTAR","SLASH_GLOBSTAR","DIR_SUFFIX","ANYMATCH_OPTS","STRING_TYPE","FUNCTION_TYPE","EMPTY_STR","EMPTY_FN","IDENTITY_FN","isMacos","promisify$1","STAR$1","stat$1","lstat$1","fsrealpath","statMethods","foreach","fn","addAndConvert","main","prop","container","delFromSet","isEmptySet","size","FsWatchInstances","Map","createFsWatchInstance","listener","errHandler","emitRaw","rawEvent","evPath","watchedPath","fsWatchBroadcast","fsevents","val1","val2","val3","cont","get","setFsWatchListener","handlers","watcher","rawEmitter","persistent","bind","broadcastErr","watcherUnusable","fd","listeners","errHandlers","rawEmitters","set","clear","clearItem","FsWatchFileInstances","nodefsHandler","fsW","fsw","_boundHandleError","_handleError","directory","_getWatchedDir","closer","filePath","absolutePath","usePolling","interval","enableBinaryInterval","extname","toLowerCase","binaryInterval","copts","unwatchFile","watchFile","curr","currmtime","mtimeMs","setFsWatchFileListener","_emitRaw","initialAdd","closed","prevStats","_watchWithNodeFs","newStats","_throttle","at","atimeMs","mt","_emit","_remove","ignoreInitial","_isntIgnored","full","followSymlinks","_incrReadyCount","linkPath","_symlinkPaths","_emitReady","wh","target","throttler","hasGlob","previous","current","_readdirp","filterPath","filterDir","_handleSymlink","_addToNodeFs","once","wasThrottled","getChildren","_handleRead","parentDir","tracked","globFilter","oDepth","dirPath","priorWh","ready","_isIgnored","_getWatchHelpers","watchPath","follow","targetPath","_handleDir","_handleFile","_addPathCloser","require$$1","fseventsImporter","promisify$2","getFsEvents","CHOKIDAR_PRINT_FSEVENTS_REQUIRE_ERROR","console","mtch","maj","parseInt","EV_ADD$1","EV_CHANGE$1","EV_ADD_DIR$1","EV_ERROR$1","STR_DATA$1","STR_END$1","EMPTY_FN$1","stat$2","lstat$2","realpath$1","statMethods$1","FSEventsWatchers","wrongEventFlags","couldConsolidate","calcDepth","sameTypes","info","fseventsHandler","ipaths","_ignoredPaths","realPath","watchedDir","event","handleEvent","addOrChange","checkIgnored","curDepth","_addToFsEvents","eventName","parentPath","callback","resolvedPath","hasSymlink","filteredListener","watchedParent","getInfo","lst","then","setFSEventsListener","ignored","checkExists","linkTarget","aliasedPath","newPath","processPath","forceAdd","pp","isDir","dirObj","_watchWithFsEvents","priorDepth","emitAdd","isNaN","joinedPath","_handleFsEventsSymlink","initWatch","canUse_1","canUse","EventEmitter","events","promisify$3","EV_ADD$2","EV_CHANGE$2","EV_UNLINK$1","EV_ADD_DIR$2","EV_ERROR$2","STR_END$2","BRACE_START$1","BANG$1","FUNCTION_TYPE$1","EMPTY_STR$1","EMPTY_FN$2","isWindows$1","stat$3","readdir$1","unifyPaths","paths_","normalizePathToUnix","toUnix","normalize","normalizeIgnored","cwd","isAbsolute","undef","DirEntry","removeWatcher","_removeWatcher","values","WatchHelper","fullWatchPath","globSymlink","dirParts","getDirParts","fullParentDir","checkGlobSymlink","entryPath","_hasReadPermissions","entryParts","unmatchedGlob","part","FSWatcher","_opts","assign","_watched","_closers","_throttled","_streams","ignorePermissionErrors","disableGlobbing","useFsEvents","envPoll","CHOKIDAR_USEPOLLING","envLower","envInterval","CHOKIDAR_INTERVAL","atomic","_pendingUnlinks","awaitWriteFinish","awf","stabilityThreshold","pollInterval","_pendingWrites","readyCalls","_readyCount","_readyEmitted","nextTick","_fsEventsHandler","_nodeFsHandler","_origAdd","_internal","absPath","getAbsolutePath","_userIgnored","results","_closePath","_closePromise","removeAllListeners","closers","closerList","dispose","watchList","pw","lastChange","Date","setTimeout","awfEmit","emitWithAll","_awaitWriteFinish","actionType","timeout","timeoutObject","action","actionPath","clearTimeout","thr","threshold","timeoutHandler","now","cancelWait","prevStat","curStat","ign","_getGlobIgnored","flipBackslashes","globParent","_boundRemove","st","mode","it","nested","wasTracked","remove","relPath","chokidar","FileWatcher","task","chokidarOptions","transformWatchers","createWatcher","unwatch","transformWatcher","isTransformDependency","transformWatcherId","isLinux","handleChange","changedId","invalidate","Watcher","configs","emitter","buildDelay","buildTimeout","invalidatedIds","rerun","tasks","Task","running","run","modules","watchFiles","invalidated","watched","skipWrite","defaultOnWarn","command","outputOptionsArray","singleOutputOptions","option","mergeOptions","outputs","outputFiles","watchOptions","include","exclude","getMatcher","includeMatchers","excludeMatchers","createFilter","fileWatcher","transformDependencies","originalCode","rollupInternal","updateWatchedFiles","write","duration","previouslyWatched","depId","endianness","hostname","location","loadavg","uptime","freemem","MAX_VALUE","totalmem","cpus","release","navigator","appVersion","networkInterfaces","getNetworkInterfaces","arch","tmpdir","tmpDir","EOL","homedir"],"mappings":"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ACA,MACA,MACA,OACA,MACA,MACA,MACA,MACA,OACA,OACA,MACA,OACA,MACA,WACA,MACA,MACA,QACA,MACA,MACA,MACA,YACA,YACA,YACA,MACA,MACA,MACA,OACA,MACA,MACA,MACA,KACA,MACA,OACA,MACA,MACA,MACA,MACA,MACA,KACA,KACA,MACA,UACA,KACA,OACA,OACA,OACA,OACA,OACA,MACA,MACA,MACA,MACA,MACA,MACA,OACA,MACA,OACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,KACA,MACA,OACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,OACA,MACA,MACA,MACA,MACA,MACA,OACA,MACA,QACA,MACA,MACA,OACA,OACA,MACA,OACA,MACA,MACA,MACA,UACA,QACA,IACA,MACA,MACA,MACA,MACA,QACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,OACA,OACA,MACA,OACA,MACA,MACA,OACA,OACA,MACA,OACA,OACA,MACA,MACA,MACA,MACA,MACA,KACA,MACA,MACA,MACA,YACA,MACA,MACA,MACA,MACA,OACA,MACA,KACA,MACA,MACA,OACA,MACA,OACA,MACA,SACA,MACA,MACA,MACA,KACA,MACA,MACA,MACA,MACA,MACA,MACA,OACA,MACA,MACA,OACA,MACA,OACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,OACA,MACA,OACA,OACA,OACA,MACA,MACA,KACA,MACA,MACA,MACA,OACA,QACA,MACA,MACA,MACA,MACA,MACA,OACA,MACA,OACA,OACA,OACA,MACA,OACA,OACA,KACA,QACA,MACA,MACA,MACA,KACA,IACA,MACA,SAQGC,GAAaC,YAA0BH,IAIrCI,GAAa,IAAI/kB,IAFE6kB,IAMrBG,GAAcvrB,aAAqB,SAAUC,EAAQC,GAAS,IAE3D4S,EAAOD,IAAPC,IACAO,EAAYD,EAAZC,SAEPnT,EAAQsrB,OAAS,MACjBtrB,EAAQurB,SAAW,QACnBvrB,EAAQwrB,OAAS,MACjBxrB,EAAQyrB,UAAY,SACpBzrB,EAAQ0rB,WAAa,SACrB1rB,EAAQ2rB,UAAY,SACpB3rB,EAAQ4rB,cAAgB,YACxB5rB,EAAQ6rB,OAAS,MACjB7rB,EAAQ8rB,SAAW,QAEnB9rB,EAAQ+rB,SAAW,OACnB/rB,EAAQgsB,QAAU,MAClBhsB,EAAQisB,UAAY,QAEpBjsB,EAAQksB,gBAAkB,UAC1BlsB,EAAQmsB,iBAAmB,WAC3BnsB,EAAQosB,gBAAkB,UAC1BpsB,EAAQqsB,cAAgB,QACxBrsB,EAAQssB,eAAiB,SACzBtsB,EAAQusB,gBAAkB,UAC1BvsB,EAAQwsB,kBAAoB,OAC5BxsB,EAAQysB,uBAAyB,YACjCzsB,EAAQ0sB,qBAAuB,UAE/B1sB,EAAQ2sB,cAAgB,YACxB3sB,EAAQ4sB,QAAU,cAClB5sB,EAAQ6sB,QAAU,cAClB7sB,EAAQ8sB,aAAe,CAAC9sB,EAAQ2sB,cAAe3sB,EAAQ4sB,QAAS5sB,EAAQ6sB,SAExE7sB,EAAQ+sB,UAAR,WAAwBna,GAExB5S,EAAQgtB,cAAgB,MACxBhtB,EAAQitB,gBAAkB,OAC1BjtB,EAAQktB,uBAAyB,QACjCltB,EAAQmtB,OAAS,mCACjBntB,EAAQotB,YAAc,WAEtBptB,EAAQqtB,MAAQ,IAChBrtB,EAAQstB,YAAc,IACtBttB,EAAQutB,KAAO,IACfvtB,EAAQwtB,QAAU,IAClBxtB,EAAQytB,SAAW,KACnBztB,EAAQkP,KAAO,IACflP,EAAQ0tB,SAAW,KACnB1tB,EAAQ2tB,cAAgB,QACxB3tB,EAAQ4tB,eAAiB,MACzB5tB,EAAQ6tB,WAAa,MACrB7tB,EAAQ8tB,cAAgB,CAACxW,KAAK,GAC9BtX,EAAQ+tB,YAAc,SACtB/tB,EAAQguB,cAAgB,WACxBhuB,EAAQiuB,UAAY,GACpBjuB,EAAQkuB,SAAW,aACnBluB,EAAQmuB,YAAc,SAAA7mB,GAAG,OAAIA,GAE7BtH,EAAQ+T,UAAyB,UAAbZ,EACpBnT,EAAQouB,QAAuB,WAAbjb,KAGCkb,GAAgB3kB,IAA3B4a,UAGNvQ,GAeEsX,GAfFtX,UACAma,GAcE7C,GAdF6C,SACAD,GAaE5C,GAbF4C,UACAtB,GAYEtB,GAZFsB,cACAC,GAWEvB,GAXFuB,QACAC,GAUExB,GAVFwB,QACAC,GASEzB,GATFyB,aACArB,GAQEJ,GARFI,UACAD,GAOEH,GAPFG,OACAE,GAMEL,GANFK,WACAI,GAKET,GALFS,SACAC,GAIEV,GAJFU,SACAC,GAGEX,GAHFW,QACAsB,GAEEjC,GAFFiC,YACMgB,GACJjD,GADFnc,KAKIzN,GAAO4sB,GAAY7J,IAAG/iB,MACtB8sB,GAASF,GAAY7J,IAAGC,MACxB+J,GAAUH,GAAY7J,IAAGE,OACzBhjB,GAAQ2sB,GAAY7J,IAAG9iB,OACvB+sB,GAAaJ,GAAY7J,IAAGG,UAE5B+J,GAAc,CAAEhK,MAAO8J,GAAS/J,KAAM8J,IAGtCI,GAAU,SAACrnB,EAAKsnB,GAChBtnB,aAAejB,IACjBiB,EAAI+F,QAAQuhB,GAEZA,EAAGtnB,IAIDunB,GAAgB,SAACC,EAAMC,EAAM3jB,GACjC,IAAI4jB,EAAYF,EAAKC,GACfC,aAAqB3oB,MACzByoB,EAAKC,GAAQC,EAAY,IAAI3oB,IAAI,CAAC2oB,KAEpCA,EAAU1oB,IAAI8E,IAYV6jB,GAAa,SAACH,EAAMC,EAAM3jB,GAC9B,IAAM4jB,EAAYF,EAAKC,GACnBC,aAAqB3oB,IACvB2oB,EAAU1R,OAAOlS,GACR4jB,IAAc5jB,UAChB0jB,EAAKC,IAIVG,GAAa,SAAC5nB,GAAD,OAASA,aAAejB,IAAmB,IAAbiB,EAAI6nB,MAAc7nB,GAuB7D8nB,GAAmB,IAAIC,IAW7B,SAASC,GAAsBvH,EAAQplB,EAAS4sB,EAAUC,EAAYC,GAapE,IACE,OAAOjL,IAAGhD,MAAMuG,EAAQplB,GAbN,SAAC+sB,EAAUC,GAC7BJ,EAASxH,GACT0H,EAAQC,EAAUC,EAAQ,CAACC,YAAa7H,IAIpC4H,GAAU5H,IAAW4H,GACvBE,GACEld,IAAKiM,QAAQmJ,EAAQ4H,GAAShD,GAAeha,IAAKzN,KAAK6iB,EAAQ4H,OAMnE,MAAO1H,GACPuH,EAAWvH,IAYf,IAqfI6H,GArfED,GAAmB,SAAClI,EAAUpnB,EAAMwvB,EAAMC,EAAMC,GACpD,IAAMC,EAAOd,GAAiBe,IAAIxI,GAC7BuI,GACLvB,GAAQuB,EAAK3vB,IAAO,SAACgvB,GACnBA,EAASQ,EAAMC,EAAMC,OAYnBG,GAAqB,SAACzd,EAAMgV,EAAUhlB,EAAS0tB,GAAa,IAK5DC,EAJGf,EAAoCc,EAApCd,SAAUC,EAA0Ba,EAA1Bb,WAAYe,EAAcF,EAAdE,WACzBL,EAAOd,GAAiBe,IAAIxI,GAIhC,IAAKhlB,EAAQ6tB,WAIX,OAHAF,EAAUhB,GACR3c,EAAMhQ,EAAS4sB,EAAUC,EAAYe,IAExB7uB,MAAM+uB,KAAKH,GAE5B,GAAIJ,EACFrB,GAAcqB,EAAMvD,GAAe4C,GACnCV,GAAcqB,EAAMtD,GAAS4C,GAC7BX,GAAcqB,EAAMrD,GAAS0D,OACxB,CAQL,KAPAD,EAAUhB,GACR3c,EACAhQ,EACAktB,GAAiBY,KAAK,KAAM9I,EAAUgF,IACtC6C,EACAK,GAAiBY,KAAK,KAAM9I,EAAUkF,MAE1B,OACdyD,EAAQ1H,GAAGkD,GAAX,uCAAqB,WAAO7D,GAAP,iBAAAjkB,EAAA,yDACb0sB,EAAeb,GAAiBY,KAAK,KAAM9I,EAAUiF,IAC3DsD,EAAKS,iBAAkB,GAEnB5c,IAA4B,UAAfkU,EAAM7S,KAJJ,0CAME3T,GAAKkR,EAAM,KANb,cAMTie,EANS,gBAOTlvB,GAAMkvB,GAPG,OAQfF,EAAazI,GARE,kFAWjByI,EAAazI,GAXI,0DAArB,uDAcAiI,EAAO,CACLW,UAAWtB,EACXuB,YAAatB,EACbuB,YAAaR,EACbD,WAEFlB,GAAiB4B,IAAIrJ,EAAUuI,GAMjC,OAAO,WACLjB,GAAWiB,EAAMvD,GAAe4C,GAChCN,GAAWiB,EAAMtD,GAAS4C,GAC1BP,GAAWiB,EAAMrD,GAAS0D,GACtBrB,GAAWgB,EAAKW,aAGlBX,EAAKI,QAAQ5uB,QAEb0tB,GAAiB9R,OAAOqK,GACxBmF,GAAazf,QA7JD,SAAA6iB,GAAI,OAAI,SAAA7oB,GACxB,IAAM2pB,EAAMd,EAAK7oB,GACb2pB,aAAe3qB,IACjB2qB,EAAIC,eAEGf,EAAK7oB,IAwJW6pB,CAAUhB,IAC/BA,EAAKI,aAAU9T,EACfwB,OAAOmF,OAAO+M,MASdiB,GAAuB,IAAI9B,IAuZ7B+B,G,WAjVJ,WAAYC,GAAK,oBACflK,KAAKmK,IAAMD,EACXlK,KAAKoK,kBAAoB,SAACtJ,GAAD,OAAWoJ,EAAIG,aAAavJ,I,6DAStCF,EAAQwH,GACvB,IAAMhsB,EAAO4jB,KAAKmK,IAAI3uB,QAChB8uB,EAAY9e,IAAK+X,QAAQ3C,GACzB7L,EAAWvJ,IAAKuJ,SAAS6L,GAChBZ,KAAKmK,IAAII,eAAeD,GAChCnrB,IAAI4V,GACX,IAIIyV,EAnXaC,EA+WXC,EAAelf,IAAKiM,QAAQmJ,GAC5BplB,EAAU,CAAC6tB,WAAYjtB,EAAKitB,YAkBlC,OAjBKjB,IAAUA,EAAWrB,IAGtB3qB,EAAKuuB,YACPnvB,EAAQovB,SAAWxuB,EAAKyuB,uBArXTJ,EAqX8C1V,EArXlCkP,GAAW5N,IAAI7K,IAAKsf,QAAQL,GAAUnqB,MAAM,GAAGyqB,gBAsXxE3uB,EAAK4uB,eAAiB5uB,EAAKwuB,SAC7BJ,EApF2B,SAAChf,EAAMgV,EAAUhlB,EAAS0tB,GAAa,IAC7Dd,EAAwBc,EAAxBd,SAAUgB,EAAcF,EAAdE,WACbL,EAAOiB,GAAqBhB,IAAIxI,GAE9ByK,EAAQlC,GAAQA,EAAKvtB,QAmC3B,OAlCIyvB,IAAUA,EAAM5B,WAAa7tB,EAAQ6tB,YAAc4B,EAAML,SAAWpvB,EAAQovB,YAC9EvN,IAAG6N,YAAY1K,GACfuI,OAAO1T,GAKL0T,GACFrB,GAAcqB,EAAMvD,GAAe4C,GACnCV,GAAcqB,EAAMrD,GAAS0D,KAK7BL,EAAO,CACLW,UAAWtB,EACXwB,YAAaR,EACb5tB,UACA2tB,QAAS9L,IAAG8N,UAAU3K,EAAUhlB,GAAS,SAAC4vB,EAAMvsB,GAC9C2oB,GAAQuB,EAAKa,aAAa,SAACR,GACzBA,EAAW9E,GAAW9D,EAAU,CAAC4K,OAAMvsB,YAEzC,IAAMwsB,EAAYD,EAAKE,SACnBF,EAAKpD,OAASnpB,EAAKmpB,MAAQqD,EAAYxsB,EAAKysB,SAAyB,IAAdD,IACzD7D,GAAQuB,EAAKW,WAAW,SAACtB,GAAD,OAAcA,EAAS5c,EAAM4f,UAI3DpB,GAAqBH,IAAIrJ,EAAUuI,IAM9B,WACLjB,GAAWiB,EAAMvD,GAAe4C,GAChCN,GAAWiB,EAAMrD,GAAS0D,GACtBrB,GAAWgB,EAAKW,aAClBM,GAAqB7T,OAAOqK,GAC5BnD,IAAG6N,YAAY1K,GACfuI,EAAKvtB,QAAUutB,EAAKI,aAAU9T,EAC9BwB,OAAOmF,OAAO+M,KAsCPwC,CAAuB3K,EAAQ8J,EAAclvB,EAAS,CAC7D4sB,WACAgB,WAAYpJ,KAAKmK,IAAIqB,YAGvBhB,EAASvB,GAAmBrI,EAAQ8J,EAAclvB,EAAS,CACzD4sB,WACAC,WAAYrI,KAAKoK,kBACjBhB,WAAYpJ,KAAKmK,IAAIqB,WAGlBhB,I,kCAUG1O,EAAMkF,EAAOyK,GAAY,WACnC,IAAIzL,KAAKmK,IAAIuB,OAAb,CAGA,IAAMnI,EAAU/X,IAAK+X,QAAQzH,GACvB/G,EAAWvJ,IAAKuJ,SAAS+G,GACzBrgB,EAASukB,KAAKmK,IAAII,eAAehH,GAEnCoI,EAAY3K,EAGhB,IAAIvlB,EAAO4a,IAAItB,GAAf,CAGA,IAAMyV,EAASxK,KAAK4L,iBAAiB9P,EAAtB,uCAA4B,WAAOtQ,EAAMqgB,GAAb,uBAAAhvB,EAAA,yDACpC,EAAKstB,IAAI2B,UAtUU,QAsUqBhQ,EAAM,GADV,oDAEpC+P,GAAiC,IAArBA,EAASP,QAFe,0CAIdlE,GAAOtL,GAJO,UAI/B+P,EAJ+B,QAKjC,EAAK1B,IAAIuB,OALwB,iDAO/BK,EAAKF,EAASG,QACdC,EAAKJ,EAASP,UACfS,GAAMA,GAAME,GAAMA,IAAON,EAAUL,UACtC,EAAKnB,IAAI+B,MAAM5H,GAAWxI,EAAM+P,GAElCF,EAAYE,EAZyB,kDAerC,EAAK1B,IAAIgC,QAAQ5I,EAASxO,GAfW,gCAkB9BtZ,EAAO4a,IAAItB,KAEdgX,EAAKF,EAASG,QACdC,EAAKJ,EAASP,UACfS,GAAMA,GAAME,GAAMA,IAAON,EAAUL,UACtC,EAAKnB,IAAI+B,MAAM5H,GAAWxI,EAAM+P,GAElCF,EAAYE,GAzB2B,0DAA5B,oCAAA7L,KAAA,gBA8Bf,KAAMyL,IAAczL,KAAKmK,IAAI3uB,QAAQ4wB,gBAAkBpM,KAAKmK,IAAIkC,aAAavQ,GAAO,CAClF,IAAKkE,KAAKmK,IAAI2B,UAAUzH,GAAQvI,EAAM,GAAI,OAC1CkE,KAAKmK,IAAI+B,MAAM7H,GAAQvI,EAAMkF,GAG/B,OAAOwJ,M,8EAWYxM,EAAOsM,EAAW9e,EAAMvH,G,+EACvC+b,KAAKmK,IAAIuB,O,oDAGPY,EAAOtO,EAAMwC,SACbhF,EAAMwE,KAAKmK,IAAII,eAAeD,GAE/BtK,KAAKmK,IAAI3uB,QAAQ+wB,e,wBAEpBvM,KAAKmK,IAAIqC,kB,SACclF,GAAW9b,G,UAA5BihB,E,QACFzM,KAAKmK,IAAIuB,O,0DACTlQ,EAAInF,IAAIpS,GACN+b,KAAKmK,IAAIuC,cAAc1D,IAAIsD,KAAUG,IACvCzM,KAAKmK,IAAIuC,cAAc7C,IAAIyC,EAAMG,GACjCzM,KAAKmK,IAAI+B,MAAM5H,GAAW9Y,EAAMwS,EAAMgD,SAGxCxF,EAAIrc,IAAI8E,GACR+b,KAAKmK,IAAIuC,cAAc7C,IAAIyC,EAAMG,GACjCzM,KAAKmK,IAAI+B,MAAM7H,GAAQ7Y,EAAMwS,EAAMgD,QAErChB,KAAKmK,IAAIwC,a,mBACF,G,YAIL3M,KAAKmK,IAAIuC,cAAcrW,IAAIiW,G,2CACtB,G,QAGTtM,KAAKmK,IAAIuC,cAAc7C,IAAIyC,GAAM,G,gJAGvBhC,EAAWmB,EAAYmB,EAAIC,EAAQrR,EAAK/V,EAAOqnB,GAAW,WAIpE,GAFAxC,EAAY9e,IAAKzN,KAAKusB,EAAWxD,IAE5B8F,EAAGG,UACND,EAAY9M,KAAKmK,IAAI2B,UAAU,UAAWxB,EAAW,MADvD,CAKA,IAAM0C,EAAWhN,KAAKmK,IAAII,eAAeqC,EAAGphB,MACtCyhB,EAAU,IAAI/tB,IAEhBge,EAAS8C,KAAKmK,IAAI+C,UAAU5C,EAAW,CACzC3L,WAAY,SAAAX,GAAK,OAAI4O,EAAGO,WAAWnP,IACnCa,gBAAiB,SAAAb,GAAK,OAAI4O,EAAGQ,UAAUpP,IACvCvY,MAAO,IACNgc,GAAGmD,GAJO,uCAIG,WAAO5G,GAAP,iBAAAnhB,EAAA,0DACV,EAAKstB,IAAIuB,OADC,uBAEZxO,OAAS7H,EAFG,6BAKRpR,EAAO+Z,EAAMxS,KACfoV,EAASpV,IAAKzN,KAAKusB,EAAWrmB,GAClCgpB,EAAQ9tB,IAAI8E,GAPE,KASV+Z,EAAMgD,MAAMG,kBATF,uCAS4B,EAAKkM,eAAerP,EAAOsM,EAAW1J,EAAQ3c,GAT1E,4FAaV,EAAKkmB,IAAIuB,OAbC,wBAcZxO,OAAS7H,EAdG,2BAoBVpR,IAAS4oB,IAAWA,GAAWG,EAAS3W,IAAIpS,MAC9C,EAAKkmB,IAAIqC,kBAGT5L,EAASpV,IAAKzN,KAAKyd,EAAKhQ,IAAKqV,SAASrF,EAAKoF,IAE3C,EAAK0M,aAAa1M,EAAQ6K,EAAYmB,EAAInnB,EAAQ,IA1BtC,4CAJH,kCAAAua,KAAA,gBAgCVyB,GAAGkD,GAAU3E,KAAKoK,mBAErB,OAAO,IAAIhK,SAAQ,SAAA3I,GAAO,OACxByF,EAAOqQ,KAAK1I,IAAS,WACnB,GAAI,EAAKsF,IAAIuB,OACXxO,OAAS7H,MADX,CAIA,IAAMmY,IAAeV,GAAYA,EAAUhD,QAE3CrS,IAKAuV,EAASS,cAAc7mB,QAAO,SAAC3C,GAC7B,OAAOA,IAASqmB,IACb2C,EAAQ5W,IAAIpS,MAIX2oB,EAAGG,SAAWH,EAAGO,WAAW,CAC5B3M,SAAUhV,IAAKiM,QAAQ6S,EAAWrmB,SAErCiC,SAAQ,SAACjC,GACV,EAAKkmB,IAAIgC,QAAQ7B,EAAWrmB,MAG9BiZ,OAAS7H,EAGLmY,GAAc,EAAKE,YAAYpD,GAAW,EAAOsC,EAAIC,EAAQrR,EAAK/V,EAAOqnB,a,0EAgBlEtR,EAAKwF,EAAOyK,EAAYhmB,EAAOonB,EAAQD,EAAIpP,G,uFACpDmQ,EAAY3N,KAAKmK,IAAII,eAAe/e,IAAK+X,QAAQ/H,IACjDoS,EAAUD,EAAUtX,IAAI7K,IAAKuJ,SAASyG,IACtCiQ,GAAczL,KAAKmK,IAAI3uB,QAAQ4wB,eAAmBS,GAAWe,GAC5DhB,EAAGG,UAAWH,EAAGiB,WAAWrS,IAAMwE,KAAKmK,IAAI+B,MAAM3H,GAAY/I,EAAKwF,GAIzE2M,EAAUxuB,IAAIqM,IAAKuJ,SAASyG,IAC5BwE,KAAKmK,IAAII,eAAe/O,KAKT,OADTsS,EAAS9N,KAAKmK,IAAI3uB,QAAQiK,QACTA,GAASqoB,IAAY9N,KAAKmK,IAAIuC,cAAcrW,IAAImH,G,oBAChEqP,E,kCACG7M,KAAK0N,YAAYlS,EAAKiQ,EAAYmB,EAAIC,EAAQrR,EAAK/V,O,eACrDua,KAAKmK,IAAIuB,O,mDAGflB,EAASxK,KAAK4L,iBAAiBpQ,GAAK,SAACuS,EAAS/M,GAExCA,GAA2B,IAAlBA,EAAMsK,SAEnB,EAAKoC,YAAYK,GAAS,EAAOnB,EAAIC,EAAQrR,EAAK/V,O,uCAG/C+kB,G,gMAaU5J,EAAQ6K,EAAYuC,EAASvoB,EAAOonB,G,wFAC/CoB,EAAQjO,KAAKmK,IAAIwC,YACnB3M,KAAKmK,IAAI+D,WAAWtN,KAAWZ,KAAKmK,IAAIuB,O,uBAC1CuC,I,mBACO,G,eAGHrB,EAAK5M,KAAKmK,IAAIgE,iBAAiBvN,EAAQnb,IACrCsnB,SAAWiB,IACjBpB,EAAGG,QAAUiB,EAAQjB,QACrBH,EAAGiB,WAAaG,EAAQH,WACxBjB,EAAGO,WAAa,SAAAnP,GAAK,OAAIgQ,EAAQb,WAAWnP,IAC5C4O,EAAGQ,UAAY,SAAApP,GAAK,OAAIgQ,EAAQZ,UAAUpP,K,kBAKtBuJ,GAAYqF,EAAG9N,YAAY8N,EAAGwB,W,UAA5CpN,E,QACFhB,KAAKmK,IAAIuB,O,uDACT1L,KAAKmK,IAAI+D,WAAWtB,EAAGwB,UAAWpN,G,wBACpCiN,I,mBACO,G,WAGHI,EAASrO,KAAKmK,IAAI3uB,QAAQ+wB,iBAAmB3L,EAAOlP,SAASyV,MAAYvG,EAAOlP,SAASyU,KAE3FnF,EAAME,c,qBACWmN,E,kCAAe/G,GAAW1G,G,iDAAUA,E,WAAjD0N,E,MACFtO,KAAKmK,IAAIuB,O,oEACE1L,KAAKuO,WAAW3B,EAAGwB,UAAWpN,EAAOyK,EAAYhmB,EAAOonB,EAAQD,EAAI0B,G,WAAnF9D,E,QACIxK,KAAKmK,IAAIuB,O,mDAET9K,IAAW0N,QAA6BjZ,IAAfiZ,GAC3BtO,KAAKmK,IAAIuC,cAAc7C,IAAIyE,GAAY,G,4BAEhCtN,EAAMG,iB,qBACIkN,E,kCAAe/G,GAAW1G,G,iDAAUA,E,WAAjD0N,E,MACFtO,KAAKmK,IAAIuB,O,0DACPjwB,EAAS+P,IAAK+X,QAAQqJ,EAAGwB,WAC/BpO,KAAKmK,IAAII,eAAe9uB,GAAQ0D,IAAIytB,EAAGwB,WACvCpO,KAAKmK,IAAI+B,MAAM7H,GAAQuI,EAAGwB,UAAWpN,G,UACtBhB,KAAKuO,WAAW9yB,EAAQulB,EAAOyK,EAAYhmB,EAAOmb,EAAQgM,EAAI0B,G,WAA7E9D,E,QACIxK,KAAKmK,IAAIuB,O,wDAGMrW,IAAfiZ,GACFtO,KAAKmK,IAAIuC,cAAc7C,IAAIre,IAAKiM,QAAQmJ,GAAS0N,G,wBAGnD9D,EAASxK,KAAKwO,YAAY5B,EAAGwB,UAAWpN,EAAOyK,G,eAEjDwC,IAEAjO,KAAKmK,IAAIsE,eAAe7N,EAAQ4J,G,mBACzB,G,sCAGHxK,KAAKmK,IAAIE,aAAT,M,wBACF4D,I,kBACOrN,G,gIAST8N,GAAa1K,YAA0B2K,KAExBC,GAAgBrsB,IAA3B4a,UAGR,IACEwL,GAAW+F,GAAWG,cACtB,MAAO/N,IACH/U,mHAAY+iB,uCAAuCC,QAAQjO,MAAMA,IAGvE,GAAI6H,GAAU,CAEZ,IAAMqG,GAAOjjB,EAAQW,QAAQH,MAAM,iBACnC,GAAIyiB,IAAQA,GAAK,IAAMA,GAAK,GAAI,CAC9B,IAAMC,GAAMj2B,OAAOk2B,SAASF,GAAK,GAAI,IAC/Bz1B,GAAMP,OAAOk2B,SAASF,GAAK,GAAI,IACzB,IAARC,IAAa11B,GAAM,KACrBovB,QAAWtT,I,IAMP8Z,GAuBNjL,GAvBFG,OACW+K,GAsBTlL,GAtBFI,UACY+K,GAqBVnL,GArBFK,WACAC,GAoBEN,GApBFM,UACU8K,GAmBRpL,GAnBFS,SACU4K,GAkBRrL,GAlBFU,SACS4K,GAiBPtL,GAjBFW,QACAE,GAgBEb,GAhBFa,gBACAC,GAeEd,GAfFc,iBACAC,GAcEf,GAdFe,gBACAC,GAaEhB,GAbFgB,cAEAE,GAWElB,GAXFkB,gBACAC,GAUEnB,GAVFmB,kBACAC,GASEpB,GATFoB,uBACAC,GAQErB,GARFqB,qBAEAiB,GAMEtC,GANFsC,cACAE,GAKExC,GALFwC,WACAd,GAIE1B,GAJF0B,UACAiB,GAGE3C,GAHF2C,cACU4I,GAERvL,GAFF6C,SACAC,GACE9C,GADF8C,YAKI0I,GAASd,GAAYvR,IAAGC,MACxBqS,GAAUf,GAAYvR,IAAGE,OACzBqS,GAAahB,GAAYvR,IAAGG,UAE5BqS,GAAgB,CAAEvS,KAAMoS,GAAQnS,MAAOoS,IAkBvCG,GAAmB,IAAI5H,IAMvB6H,GAAkB,IAAI7wB,IAAI,CAC9B,MAAO,MAAO,MAAO,MAAO,MAAO,OAAQ,OAAQ,SAgGrD,IAAM8wB,GAAmB,SAACxkB,GACxB,IADiC,EAC7BnN,EAAQ,EADqB,cAETyxB,GAAiBlZ,QAFR,IAEjC,2BAAiD,CAC/C,GAAgC,IADe,QACjCzQ,QAAQqF,MACpBnN,GAvGwB,GAyGtB,OAAO,GANoB,8BAWjC,OAAO,GAOH4xB,GAAY,SAACrP,EAAQnC,GAEzB,IADA,IAAIzjB,EAAI,GACA4lB,EAAOza,QAAQsY,KAAUmC,EAASpV,IAAK+X,QAAQ3C,MAAanC,GAAMzjB,IAC1E,OAAOA,GAKHk1B,GAAY,SAACC,EAAMnP,GAAP,OAChBmP,EAAK/2B,OAASksB,IAA0BtE,EAAME,eAC9CiP,EAAK/2B,OAASmsB,IAAwBvE,EAAMG,kBAC5CgP,EAAK/2B,OAASisB,IAAqBrE,EAAMC,UA6TvCmP,G,WAlTJ,WAAYjG,GAAK,oBACfnK,KAAKmK,IAAMA,E,yDAEA3e,EAAMwV,GACjB,IAAMqP,EAASrQ,KAAKmK,IAAImG,cACxB,GAAItQ,KAAKmK,IAAI+D,WAAW1iB,EAAMwV,GAK5B,OAJAqP,EAAOlxB,IAAIqM,GACPwV,GAASA,EAAME,eACjBmP,EAAOlxB,IAAIqM,EAAOgb,KAEb,EAGT6J,EAAOla,OAAO3K,GACd6kB,EAAOla,OAAO3K,EAAOgb,M,kCAGXhb,EAAMgV,EAAU+P,EAAU90B,EAAQ+0B,EAAYvsB,EAAMksB,EAAM/zB,GACpE,IAAMq0B,EAAQD,EAAWna,IAAIpS,GAAQmrB,GAAcD,GACnDnP,KAAK0Q,YAAYD,EAAOjlB,EAAMgV,EAAU+P,EAAU90B,EAAQ+0B,EAAYvsB,EAAMksB,EAAM/zB,K,2EAGlEoP,EAAMgV,EAAU+P,EAAU90B,EAAQ+0B,EAAYvsB,EAAMksB,EAAM/zB,G,gGAEpDszB,GAAOlkB,G,UAArBwV,E,QACFhB,KAAKmK,IAAIuB,O,qDACT1L,KAAKmK,IAAIuB,O,iDACTwE,GAAUC,EAAMnP,GAClBhB,KAAK2Q,YAAYnlB,EAAMgV,EAAU+P,EAAU90B,EAAQ+0B,EAAYvsB,EAAMksB,EAAM/zB,GAE3E4jB,KAAK0Q,YAAYlM,GAAWhZ,EAAMgV,EAAU+P,EAAU90B,EAAQ+0B,EAAYvsB,EAAMksB,EAAM/zB,G,kDAGrE,WAAf,KAAM6R,KACR+R,KAAK2Q,YAAYnlB,EAAMgV,EAAU+P,EAAU90B,EAAQ+0B,EAAYvsB,EAAMksB,EAAM/zB,GAE3E4jB,KAAK0Q,YAAYlM,GAAWhZ,EAAMgV,EAAU+P,EAAU90B,EAAQ+0B,EAAYvsB,EAAMksB,EAAM/zB,G,iKAKhFq0B,EAAOjlB,EAAMgV,EAAU+P,EAAU90B,EAAQ+0B,EAAYvsB,EAAMksB,EAAM/zB,GAC3E,IAAI4jB,KAAKmK,IAAIuB,SAAU1L,KAAK4Q,aAAaplB,GAEzC,GAAIilB,IAAUjM,GAAW,CACvB,IAAMtD,EAAciP,EAAK/2B,OAASksB,IAE9BpE,GAAesP,EAAWna,IAAIpS,KAChC+b,KAAKmK,IAAIgC,QAAQ1wB,EAAQwI,EAAMid,OAE5B,CACL,GAAIuP,IAAUtB,GAAU,CAItB,GAFIgB,EAAK/2B,OAASksB,IAAwBtF,KAAKmK,IAAII,eAAe/e,GAE9D2kB,EAAK/2B,OAASmsB,IAAwBnpB,EAAKmwB,eAAgB,CAE7D,IAAMsE,OAA0Bxb,IAAfjZ,EAAKqJ,WACpB4P,EAAY4a,GAAUzP,EAAU+P,GAAY,EAC9C,OAAOvQ,KAAK8Q,eAAetlB,GAAM,GAAO,EAAMqlB,GAKhD7Q,KAAKmK,IAAII,eAAe9uB,GAAQ0D,IAAI8E,GAKtC,IAAM8sB,EAAYZ,EAAK/2B,OAASksB,GAAyBmL,EAAQ/J,GAAa+J,EAC9EzQ,KAAKmK,IAAI+B,MAAM6E,EAAWvlB,GACtBulB,IAAc1B,IAAcrP,KAAK8Q,eAAetlB,GAAM,GAAO,M,yCAYlD4iB,EAAWmC,EAAUtvB,EAAW4sB,GAAY,WAC7D,IAAI7N,KAAKmK,IAAIuB,SACT1L,KAAKmK,IAAI+D,WAAWE,GAAxB,CACA,IAAMhyB,EAAO4jB,KAAKmK,IAAI3uB,QA+ChBgvB,EAtPR,SAA6B5J,EAAQ2P,EAAUnI,EAAUgB,EAAYe,GACnE,IAAIiE,EAAY5iB,IAAKsf,QAAQlK,GAAUpV,IAAK+X,QAAQ3C,GAAUA,EACxDoQ,EAAaxlB,IAAK+X,QAAQ6K,GAC5BrF,EAAO+G,GAAiB9G,IAAIoF,GAM5B4B,GAAiBgB,KACnB5C,EAAY4C,GAGd,IAbwE,EAd1CxlB,EAAMylB,EA2B9BC,EAAe1lB,IAAKiM,QAAQmJ,GAC5BuQ,EAAaD,IAAiBX,EAE9Ba,EAAmB,SAAC5Q,EAAUlL,EAAO6a,GACrCgB,IAAY3Q,EAAWA,EAASpU,QAAQmkB,EAAUW,IAEpD1Q,IAAa0Q,GACZ1Q,EAASra,QAAQ+qB,EAAe1lB,IAAKC,MACtC2c,EAAS5H,EAAUlL,EAAO6a,IAK1BkB,GAAgB,EA1BoD,cA2B9CvB,GAAiBlZ,QA3B6B,IA2BxE,2BAAmD,KAAxC6R,EAAwC,QACjD,GAA+D,IAA3D8H,EAASpqB,QAAQqF,IAAKiM,QAAQgR,GAAejd,IAAKC,KAAY,CAChE2iB,EAAY3F,EACZM,EAAO+G,GAAiB9G,IAAIoF,GAC5BiD,GAAgB,EAChB,QAhCoE,8BAyDxE,OArBItI,GAAQsI,EACVtI,EAAKW,UAAUvqB,IAAIiyB,IAEnBrI,EAAO,CACLW,UAAW,IAAIxqB,IAAI,CAACkyB,IACpBhI,aACAD,SAxD0B3d,EAwDM4iB,EAxDA6C,EAwDW,SAACzQ,EAAUlL,GACpD,IAAI6U,EAAIuB,OAAR,CACA,IAAMyE,EAAOxH,GAAS2I,QAAQ9Q,EAAUlL,GACxCyT,EAAKW,UAAUxjB,SAAQ,SAAA4P,GACrBA,EAAK0K,EAAUlL,EAAO6a,MAGxBpH,EAAKK,WAAW+G,EAAKM,MAAOjQ,EAAU2P,KA7DrC,CAAChyB,KADKwqB,GAAStO,MAAM7O,EAAMylB,MAiEhCnB,GAAiBjG,IAAIuE,EAAWrF,IAK3B,WACL,IAAMwI,EAAMxI,EAAKW,UAGjB,GADA6H,EAAIpb,OAAOib,IACNG,EAAIvJ,OACP8H,GAAiB3Z,OAAOiY,GACpBrF,EAAKI,SAAS,OAAOJ,EAAKI,QAAQhrB,OAAOqzB,MAAK,WAChDzI,EAAKK,WAAaL,EAAKI,aAAU9T,EACjCwB,OAAOmF,OAAO+M,OAqLL0I,CACbrD,EACAmC,EAhDiB,uCAAG,WAAO/P,EAAUlL,EAAO6a,GAAxB,uBAAAtzB,EAAA,0DAChB,EAAKstB,IAAIuB,OADO,2DAGHrW,IAAfjZ,EAAKqJ,OACLwqB,GAAUzP,EAAU+P,GAAYn0B,EAAKqJ,OAJnB,oDAMdmb,EAAS3f,EAAUuK,IAAKzN,KAC5BqwB,EAAW5iB,IAAKqV,SAASuN,EAAW5N,MAElCqN,GAAeA,EAAWjN,GATV,oDAWdnlB,EAAS+P,IAAK+X,QAAQ3C,GACtB3c,EAAOuH,IAAKuJ,SAAS6L,GACrB4P,EAAa,EAAKrG,IAAII,eAC1B4F,EAAK/2B,OAASksB,GAAyB1E,EAASnlB,IAI9Cs0B,GAAgB1Z,IAAIf,IAAU6a,EAAKM,QAAUrL,GAlB7B,2BAmBPhpB,EAAKs1B,UAAY7K,GAnBV,4CAsBA6I,GAAO9O,GAtBP,QAsBdI,EAtBc,sEAwBZ,EAAKmJ,IAAIuB,OAxBG,uDAyBZ,EAAKkF,aAAahQ,EAAQI,GAzBd,mDA0BZkP,GAAUC,EAAMnP,GAClB,EAAK2P,YAAY/P,EAAQJ,EAAU+P,EAAU90B,EAAQ+0B,EAAYvsB,EAAMksB,EAAM/zB,GAE7E,EAAKs0B,YAAYlM,GAAW5D,EAAQJ,EAAU+P,EAAU90B,EAAQ+0B,EAAYvsB,EAAMksB,EAAM/zB,GA7B1E,wBAgChB,EAAKu1B,YAAY/Q,EAAQJ,EAAU+P,EAAU90B,EAAQ+0B,EAAYvsB,EAAMksB,EAAM/zB,GAhC7D,qCAmCV+zB,EAAKM,MAnCK,cAoCb1L,IApCa,OAqCbC,GArCa,UAuCbC,IAvCa,OAwCbC,GAxCa,6CAsCT,EAAKyL,YAAY/P,EAAQJ,EAAU+P,EAAU90B,EAAQ+0B,EAAYvsB,EAAMksB,EAAM/zB,IAtCpE,iCAyCT,EAAKu1B,YAAY/Q,EAAQJ,EAAU+P,EAAU90B,EAAQ+0B,EAAYvsB,EAAMksB,EAAM/zB,IAzCpE,2DAAH,0DAkDjB4jB,KAAKmK,IAAIqB,SACTxL,KAAKmK,KAIP,OADAnK,KAAKmK,IAAIwC,aACFnC,K,sFAWoBiC,EAAUjM,EAAUvf,EAAW4vB,G,2EAEtD7Q,KAAKmK,IAAIuB,SAAU1L,KAAKmK,IAAIuC,cAAcrW,IAAImK,G,wDAElDR,KAAKmK,IAAIuC,cAAc7C,IAAIrJ,GAAU,GACrCR,KAAKmK,IAAIqC,kB,kBAGkBoD,GAAWnD,G,UAA9BmF,E,QACF5R,KAAKmK,IAAIuB,O,uDACT1L,KAAKmK,IAAI+D,WAAW0D,G,0CACf5R,KAAKmK,IAAIwC,c,QAGlB3M,KAAKmK,IAAIqC,kBAITxM,KAAK8Q,eAAec,GAAcnF,GAAU,SAAC7L,GAC3C,IAAIiR,EAAcpF,EAMlB,OALImF,GAAcA,IAAehM,GAC/BiM,EAAcjR,EAAOxU,QAAQwlB,EAAYnF,GAChC7L,IAAWgF,KACpBiM,EAAcrmB,IAAKzN,KAAK0uB,EAAU7L,IAE7B3f,EAAU4wB,MAChB,EAAOhB,G,sDAEN7Q,KAAKmK,IAAIE,aAAT,M,0CACKrK,KAAKmK,IAAIwC,c,qJAUdmF,EAAS9Q,EAAO+Q,EAAa31B,EAAM41B,GACzC,IAAMC,EAAKF,EAAYD,GACjBI,EAAQlR,EAAME,cACdiR,EAASnS,KAAKmK,IAAII,eAAe/e,IAAK+X,QAAQ0O,IAC9C5iB,EAAO7D,IAAKuJ,SAASkd,GAGvBC,GAAOlS,KAAKmK,IAAII,eAAe0H,GAC/BE,EAAO9b,IAAIhH,KACf8iB,EAAOhzB,IAAIkQ,GAENjT,EAAKgwB,gBAA8B,IAAb4F,GACzBhS,KAAKmK,IAAI+B,MAAMgG,EAAQ7C,GAAeF,GAAU8C,EAAIjR,M,gCAI9CuP,EAAU3P,EAAQgM,EAAImF,GAC9B,IAAI/R,KAAKmK,IAAIuB,OAAb,CACA,IAAMlB,EAASxK,KAAKoS,mBAClBxF,EAAGwB,UACH5iB,IAAKiM,QAAQ8Y,GAAY3D,EAAGwB,WAC5B2D,EACAnF,EAAGiB,YAEL7N,KAAKmK,IAAIsE,eAAe7N,EAAQ4J,M,8EAWb5J,EAAQ3f,EAAW+wB,EAAUK,G,0FAC5CrS,KAAKmK,IAAIuB,O,wDAGPtvB,EAAO4jB,KAAKmK,IAAI3uB,QAChBu2B,SAAqB9wB,IAAc4lB,GAAgB5lB,EAAY+lB,GAE/D4F,EAAK5M,KAAKmK,IAAIgE,iBAAiBvN,G,kBAIfiP,GAAcjD,EAAG9N,YAAY8N,EAAGwB,W,UAA9CpN,E,QACFhB,KAAKmK,IAAIuB,O,uDACT1L,KAAKmK,IAAI+D,WAAWtB,EAAGwB,UAAWpN,G,uBAC9B,K,YAEJA,EAAME,c,oBAEH0L,EAAGiB,YAAY7N,KAAKsS,QAAQP,EAAYnR,GAASI,EAAO+Q,EAAa31B,EAAM41B,KAG5EK,GAAcA,EAAaj2B,EAAKqJ,O,mDAGpCua,KAAKmK,IAAI+C,UAAUN,EAAGwB,UAAtB,aACEzP,WAAY,SAAAX,GAAK,OAAI4O,EAAGO,WAAWnP,IACnCa,gBAAiB,SAAAb,GAAK,OAAI4O,EAAGQ,UAAUpP,MApahCjkB,EAqaEqC,EAAKqJ,OAAS4sB,GAAc,GArapBE,MAAMx4B,GAAS,GAAK,CAAC0L,MAAO1L,MAsa5C0nB,GAAG8N,IAAY,SAACvR,GAEjB,IAAI,EAAKmM,IAAIuB,UAGT1N,EAAMgD,MAAME,eAAkB0L,EAAGO,WAAWnP,IAAhD,CAEA,IAAMwU,EAAahnB,IAAKzN,KAAK6uB,EAAGwB,UAAWpQ,EAAMxS,MAC1CgV,EAAYxC,EAAZwC,SAEP,GAAIoM,EAAGL,gBAAkBvO,EAAMgD,MAAMG,iBAAkB,CAGrD,IAAM0P,OAA0Bxb,IAAfjZ,EAAKqJ,WACpB4P,EAAY4a,GAAUuC,EAAYhnB,IAAKiM,QAAQmV,EAAGwB,YAAc,EAElE,EAAKqE,uBAAuBD,EAAYhS,EAAUuR,EAAalB,QAE/D,EAAKyB,QAAQE,EAAYxU,EAAMgD,MAAO+Q,EAAa31B,EAAM41B,OAE1DvQ,GAAG6N,GAAYG,IAAYhO,GAAG+N,IAAW,WAC1C,EAAKrF,IAAIwC,gB,wBAGX3M,KAAKsS,QAAQ1F,EAAGwB,UAAWpN,EAAO+Q,EAAa31B,EAAM41B,GACrDhS,KAAKmK,IAAIwC,a,0DAGN,EAAD,KAAU3M,KAAKmK,IAAIE,aAAT,QAEZrK,KAAKmK,IAAIwC,aACT3M,KAAKmK,IAAIwC,c,YAITvwB,EAAKitB,aAA2B,IAAb2I,E,2BACV/wB,IAAc4lB,G,iBAEvB7G,KAAK0S,eAAUrd,EAAWuL,EAAQgM,EAAImF,G,mDAInBnC,GAAWhD,EAAGwB,W,QAA/BmC,E,kEAEFvQ,KAAK0S,UAAUnC,EAAU3P,EAAQgM,EAAImF,G,kCAld7B,IAACh4B,I,iGA0dX44B,GA5UW,kBAAMhK,IAAYmH,GAAiB9H,KAAO,KA6UzDoI,GAAgBwC,OAASD,G,IAEjBE,GAAiBC,IAAjBD,aAGWE,GAAgBxwB,IAA3B4a,UAEF2F,GAAWf,GAAWL,QAS1ByC,GAkCED,GAlCFC,OACAC,GAiCEF,GAjCFE,SACQ4O,GAgCN9O,GAhCFG,OACW4O,GA+BT/O,GA/BFI,UACW4O,GA8BThP,GA9BFM,UACY2O,GA6BVjP,GA7BFK,WACAE,GA4BEP,GA5BFO,cACAC,GA2BER,GA3BFQ,OACU0O,GA0BRlP,GA1BFS,SAEAG,GAwBEZ,GAxBFY,UACSuO,GAuBPnP,GAvBFW,QAEAgB,GAqBE3B,GArBF2B,cACAC,GAoBE5B,GApBF4B,gBACAC,GAmBE7B,GAnBF6B,uBACAC,GAkBE9B,GAlBF8B,OACAC,GAiBE/B,GAjBF+B,YAEAC,GAeEhC,GAfFgC,MACaoN,GAcXpP,GAdFiC,YACMoN,GAaJrP,GAbFkC,KACAC,GAYEnC,GAZFmC,QACAC,GAWEpC,GAXFoC,SACAC,GAUErC,GAVFqC,SACAE,GASEvC,GATFuC,eACAE,GAQEzC,GARFyC,cACAC,GAOE1C,GAPF0C,YACe4M,GAMbtP,GANF2C,cACW4M,GAKTvP,GALF4C,UACU4M,GAIRxP,GAJF6C,SAEW4M,GAETzP,GAFFtX,UACAqa,GACE/C,GADF+C,QAGI2M,GAASb,GAAY1V,IAAGC,MACxBuW,GAAYd,GAAY1V,IAAGD,SAsB3B+E,GAAS,eAACpoB,EAAD,uDAAS,GAAT,OAAgBoB,MAAMC,QAAQrB,GAASA,EAAQ,CAACA,IAYzD+5B,GAAa,SAACC,GAIlB,IAAMtX,EAfQ,SAAV7hB,EAAWkb,GAAsB,IAAhBjb,EAAgB,uDAAP,GAQ9B,OAPAib,EAAK5P,SAAQ,SAAAjC,GACP9I,MAAMC,QAAQ6I,GAChBrJ,EAAQqJ,EAAMpJ,GAEdA,EAAOF,KAAKsJ,MAGTpJ,EAOOD,CAAQunB,GAAO4R,IAC7B,IAAKtX,EAAM1F,OAAM,SAAA3S,GAAC,cAAWA,IAAMwiB,MACjC,MAAM,IAAI1qB,UAAJ,6CAAoDugB,IAE5D,OAAOA,EAAMzY,IAAIgwB,KAGbC,GAAS,SAACt0B,GAEd,IADA,IAAIe,EAAMf,EAAOyM,QAAQyZ,GAAeK,IACjCxlB,EAAI6L,MAAMuZ,KACfplB,EAAMA,EAAI0L,QAAQ0Z,GAAiBI,IAErC,OAAOxlB,GAKHszB,GAAsB,SAACpT,GAAD,OAAYqT,GAAOzoB,IAAK0oB,UAAUD,GAAOrT,MAE/DuT,GAAmB,eAACC,EAAD,uDAAOX,GAAP,OAAuB,SAAC7S,GAC/C,cAAWA,IAAWgG,GAAoBhG,EACnCoT,GAAoBxoB,IAAK6oB,WAAWzT,GAAUA,EAASpV,IAAKzN,KAAKq2B,EAAKxT,MAazE0T,GAAQ,SAACl4B,EAAM8D,GAAP,YAA6BmV,IAAdjZ,EAAK8D,IAO5Bq0B,G,WAKJ,WAAY/Y,EAAKgZ,GAAe,oBAC9BxU,KAAKxU,KAAOgQ,EACZwE,KAAKyU,eAAiBD,EAEtBxU,KAAK/J,MAAQ,IAAI/W,I,gDAGf+E,GAAM,IACDgS,EAAS+J,KAAT/J,MACFA,GACDhS,IAASoiB,IAAWpiB,IAASqiB,IAAUrQ,EAAM9W,IAAI8E,K,sEAG1CA,G,4EACJgS,EAAS+J,KAAT/J,M,oDAEPA,EAAME,OAAOlS,KACTgS,EAAM+R,KAAO,G,wDAEXxM,EAAMwE,KAAKxU,K,mBAETqoB,GAAUrY,G,0DAEZwE,KAAKyU,gBACPzU,KAAKyU,eAAejpB,IAAK+X,QAAQ/H,GAAMhQ,IAAKuJ,SAASyG,I,2IAKvDvX,GAAM,IACDgS,EAAS+J,KAAT/J,MACP,GAAKA,EACL,OAAOA,EAAMI,IAAIpS,K,oCAML,IACLgS,EAAS+J,KAAT/J,MACP,GAAKA,EACL,mBAAWA,EAAMye,Y,gCAIjB1U,KAAK/J,MAAM6T,eACJ9J,KAAKxU,YACLwU,KAAKyU,sBACLzU,KAAK/J,MACZY,OAAOmF,OAAOgE,U,KAMZ2U,G,WACJ,WAAY/T,EAAQwN,EAAWC,EAAQlE,GAAK,oBAC1CnK,KAAKmK,IAAMA,EACXnK,KAAKxU,KAAOoV,EAASA,EAAOxU,QAAQ6Z,GAAawN,IACjDzT,KAAKoO,UAAYA,EACjBpO,KAAK4U,cAAgBppB,IAAKiM,QAAQ2W,GAClCpO,KAAK+M,QAAUqB,IAAcxN,EAEzBA,IAAW6S,KAAazT,KAAK+M,SAAU,GAC3C/M,KAAK6U,eAAc7U,KAAK+M,UAAWsB,SAAShZ,EAC5C2K,KAAK6N,aAAa7N,KAAK+M,SAAUjK,GAASlC,OAAQvL,EAAWsR,IAC7D3G,KAAK8U,SAAW9U,KAAK+U,YAAYnU,GACjCZ,KAAK8U,SAAS5uB,SAAQ,SAAClE,GACjBA,EAAM/G,OAAS,GAAG+G,EAAMnC,SAE9BmgB,KAAKuM,eAAiB8B,EACtBrO,KAAKlB,WAAauP,EAlBA,OACA,Q,6DAoBHrQ,GAQf,YALyB3I,IAArB2K,KAAK6U,cACP7U,KAAK6U,YAAc7W,EAAMgX,gBAAkBhV,KAAK4U,eACtC,CAACrE,SAAUvS,EAAMgX,cAAevI,SAAUzM,KAAK4U,gBAGvD5U,KAAK6U,YACA7W,EAAMwC,SAASpU,QAAQ4T,KAAK6U,YAAYtE,SAAUvQ,KAAK6U,YAAYpI,UAGrEzO,EAAMwC,W,gCAGLxC,GACR,OAAOxS,IAAKzN,KAAKiiB,KAAKoO,UACpB5iB,IAAKqV,SAASb,KAAKoO,UAAWpO,KAAKiV,iBAAiBjX,O,iCAI7CA,GAAO,IACTgD,EAAShD,EAATgD,MACP,GAAIA,GAASA,EAAMG,iBAAkB,OAAOnB,KAAKoN,UAAUpP,GAC3D,IAAMkT,EAAelR,KAAKkV,UAAUlX,GAGpC,QAFoBgC,KAAK+M,gBAAkB/M,KAAK6N,aAAe2F,IAC7DxT,KAAK6N,WAAWqD,KAEhBlR,KAAKmK,IAAIkC,aAAa6E,EAAclQ,IACpChB,KAAKmK,IAAIgL,oBAAoBnU,K,kCAGrBJ,GAAQ,WAClB,IAAKZ,KAAK+M,QAAS,MAAO,GAC1B,IAAM/qB,EAAQ,GAKd,OAJqB4e,EAAOlP,SAAS4hB,IAAiBxsB,GAASP,OAAOqa,GAAU,CAACA,IACpE1a,SAAQ,SAAC0a,GACpB5e,EAAMrH,KAAK6Q,IAAKqV,SAAS,EAAKuN,UAAWxN,GAAQjU,MAAMoZ,QAElD/jB,I,gCAGCgc,GACR,GAAIgC,KAAK+M,QAAS,CAChB,IAAMqI,EAAapV,KAAK+U,YAAY/U,KAAKiV,iBAAiBjX,IACtD9N,GAAW,EACf8P,KAAKqV,eAAiBrV,KAAK8U,SAAS10B,MAAK,SAAC4B,GACxC,OAAOA,EAAM+U,OAAM,SAACue,EAAMt6B,GAExB,OADIs6B,IAAS/O,KAAUrW,GAAW,GAC3BA,IAAaklB,EAAW,GAAGp6B,IAAM8nB,GAASwS,EAAMF,EAAW,GAAGp6B,GAAI2rB,UAI/E,OAAQ3G,KAAKqV,eAAiBrV,KAAKmK,IAAIkC,aAAarM,KAAKkV,UAAUlX,GAAQA,EAAMgD,W,KAY/EuU,G,kDAEN,WAAYC,GAAO,0BACjB,eAEA,IAAMp5B,EAAO,GACTo5B,GAAO3e,OAAO4e,OAAOr5B,EAAMo5B,GAG/B,EAAKE,SAAW,IAAIxN,IAEpB,EAAKyN,SAAW,IAAIzN,IAEpB,EAAKoI,cAAgB,IAAIpxB,IAGzB,EAAK02B,WAAa,IAAI1N,IAGtB,EAAKwE,cAAgB,IAAIxE,IAEzB,EAAK2N,SAAW,IAAI32B,IACpB,EAAKwsB,QAAS,EAGV4I,GAAMl4B,EAAM,gBAAeA,EAAKitB,YAAa,GAC7CiL,GAAMl4B,EAAM,mBAAkBA,EAAKgwB,eAAgB,GACnDkI,GAAMl4B,EAAM,4BAA2BA,EAAK05B,wBAAyB,GACrExB,GAAMl4B,EAAM,cAAaA,EAAKwuB,SAAW,KACzC0J,GAAMl4B,EAAM,oBAAmBA,EAAK4uB,eAAiB,KACrDsJ,GAAMl4B,EAAM,qBAAoBA,EAAK25B,iBAAkB,GAC3D35B,EAAKyuB,qBAAuBzuB,EAAK4uB,iBAAmB5uB,EAAKwuB,SAGrD0J,GAAMl4B,EAAM,iBAAgBA,EAAK45B,aAAe55B,EAAKuuB,YAGlCyF,GAAgBwC,WAClBx2B,EAAK45B,aAAc,GAIpC1B,GAAMl4B,EAAM,gBAAkBA,EAAK45B,cACrC55B,EAAKuuB,WAAa1D,IAKpB,IAAMgP,EAAUlqB,mHAAYmqB,oBAC5B,QAAgB7gB,IAAZ4gB,EAAuB,CACzB,IAAME,EAAWF,EAAQlL,cAGvB3uB,EAAKuuB,WADU,UAAbwL,GAAqC,MAAbA,IAEJ,SAAbA,GAAoC,MAAbA,KAGZA,GAGxB,IAAMC,EAAcrqB,mHAAYsqB,kBAC5BD,IACFh6B,EAAKwuB,SAAW5xB,OAAOk2B,SAASkH,EAAa,KAI3C9B,GAAMl4B,EAAM,YAAWA,EAAKk6B,QAAUl6B,EAAKuuB,aAAevuB,EAAK45B,aAC/D55B,EAAKk6B,SAAQ,EAAKC,gBAAkB,IAAIrO,KAExCoM,GAAMl4B,EAAM,oBAAmBA,EAAKmwB,gBAAiB,GAErD+H,GAAMl4B,EAAM,sBAAqBA,EAAKo6B,kBAAmB,IAC/B,IAA1Bp6B,EAAKo6B,mBAA2Bp6B,EAAKo6B,iBAAmB,IAC5D,IAAMC,EAAMr6B,EAAKo6B,iBACbC,IACGA,EAAIC,qBAAoBD,EAAIC,mBAAqB,KACjDD,EAAIE,eAAcF,EAAIE,aAAe,KAC1C,EAAKC,eAAiB,IAAI1O,KAExB9rB,EAAKs1B,UAASt1B,EAAKs1B,QAAUvP,GAAO/lB,EAAKs1B,UAE7C,IAAImF,EAAa,EA/EA,OAgFjB,EAAKlK,WAAa,aAChBkK,GACkB,EAAKC,cACrB,EAAKnK,WAAa+G,GAClB,EAAKqD,eAAgB,EAErBhrB,EAAQirB,UAAS,kBAAM,EAAKjW,KAAKqD,SAGrC,EAAKoH,SAAW,wCAAInwB,EAAJ,yBAAIA,EAAJ,uBAAa,KAAK0lB,KAAL,SAAU2D,IAAV,OAAqBrpB,KAClD,EAAK07B,eAAgB,EACrB,EAAKv7B,QAAUY,EAGXA,EAAK45B,YACP,EAAKiB,iBAAmB,IAAI7G,GAAJ,gBAExB,EAAK8G,eAAiB,IAAIjN,GAAJ,gBAIxBpT,OAAOmF,OAAO5f,GArGG,E,gDAiHf23B,EAAQoD,EAAUC,GAAW,aACApX,KAAKxkB,QAA7B44B,EADwB,EACxBA,IAAK2B,EADmB,EACnBA,gBACZ/V,KAAK0L,QAAS,EACd,IAAIjP,EAAQqX,GAAWC,GAoDvB,OAnDIK,IACF3X,EAAQA,EAAMzY,KAAI,SAACwH,GACjB,IAAM6rB,EA1RY,SAACzW,EAAQwT,GAC/B,OAAI5oB,IAAK6oB,WAAWzT,GACXA,EAELA,EAAOxT,WAAWmmB,IACbA,GAAS/nB,IAAKzN,KAAKq2B,EAAKxT,EAAOtgB,MAAM,IAEvCkL,IAAKzN,KAAKq2B,EAAKxT,GAmRF0W,CAAgB9rB,EAAM4oB,GAGtC,OAAI2B,IAAoBnnB,GAAOpD,GACtB6rB,EAEFzV,GAAcyV,OAKzB5a,EAAQA,EAAM7V,QAAO,SAAC4E,GACpB,OAAIA,EAAK4B,WAAWmmB,KAClB,EAAKjD,cAAcnxB,IAAIqM,EAAKlL,MAAM,KAC3B,IAIT,EAAKgwB,cAAcna,OAAO3K,GAC1B,EAAK8kB,cAAcna,OAAO3K,EAAOib,IAIjC,EAAK8Q,kBAAeliB,GAEb,MAGL2K,KAAKxkB,QAAQw6B,aAAehW,KAAKiX,kBAC9BjX,KAAK8W,cAAa9W,KAAK8W,YAAcra,EAAMxhB,QAC5C+kB,KAAKxkB,QAAQ6tB,aAAYrJ,KAAK8W,aAAe,GACjDra,EAAMvW,SAAQ,SAACsF,GAAD,OAAU,EAAKyrB,iBAAiBnG,eAAetlB,QAExDwU,KAAK8W,cAAa9W,KAAK8W,YAAc,GAC1C9W,KAAK8W,aAAera,EAAMxhB,OAC1BmlB,QAAQpJ,IACNyF,EAAMzY,IAAN,uCAAU,WAAMwH,GAAN,eAAA3O,EAAA,sEACU,EAAKq6B,eAAe5J,aAAa9hB,GAAO4rB,EAAW,EAAG,EAAGD,GADnE,cACFrgB,EADE,SAEC,EAAK6V,aAFN,kBAGD7V,GAHC,2CAAV,wDAKA0a,MAAK,SAAAgG,GACD,EAAK9L,QACT8L,EAAQ5wB,QAAO,SAAA3C,GAAI,OAAIA,KAAMiC,SAAQ,SAAAjC,GACnC,EAAK9E,IAAIqM,IAAK+X,QAAQtf,GAAOuH,IAAKuJ,SAASoiB,GAAYlzB,WAKtD+b,O,8BAQD+T,GAAQ,WACd,GAAI/T,KAAK0L,OAAQ,OAAO1L,KACxB,IAAMvD,EAAQqX,GAAWC,GAClBK,EAAOpU,KAAKxkB,QAAZ44B,IAqBP,OAnBA3X,EAAMvW,SAAQ,SAAC0a,GAERpV,IAAK6oB,WAAWzT,IAAY,EAAK+U,SAAStf,IAAIuK,KAC7CwT,IAAKxT,EAASpV,IAAKzN,KAAKq2B,EAAKxT,IACjCA,EAASpV,IAAKiM,QAAQmJ,IAGxB,EAAK6W,WAAW7W,GAEhB,EAAK0P,cAAcnxB,IAAIyhB,GACnB,EAAK8U,SAASrf,IAAIuK,IACpB,EAAK0P,cAAcnxB,IAAIyhB,EAAS6F,IAKlC,EAAK8Q,kBAAeliB,KAGf2K,O,8BAOD,WACN,GAAIA,KAAK0L,OAAQ,OAAO1L,KAAK0X,cAC7B1X,KAAK0L,QAAS,EAGd1L,KAAK2X,qBACL,IAAMC,EAAU,GAehB,OAdA5X,KAAK2V,SAASzvB,SAAQ,SAAA2xB,GAAU,OAAIA,EAAW3xB,SAAQ,SAAAskB,GACrD,IAAMjJ,EAAUiJ,IACZjJ,aAAmBnB,SAASwX,EAAQj9B,KAAK4mB,SAE/CvB,KAAK6V,SAAS3vB,SAAQ,SAAAgX,GAAM,OAAIA,EAAOwD,aACvCV,KAAKuX,kBAAeliB,EACpB2K,KAAK8W,YAAc,EACnB9W,KAAK+W,eAAgB,EACrB/W,KAAK0V,SAASxvB,SAAQ,SAAAga,GAAM,OAAIA,EAAO4X,aACvC,CAAC,UAAW,UAAW,UAAW,eAAgB,aAAa5xB,SAAQ,SAAAhG,GACrE,EAAK,IAAD,OAAKA,IAAO4pB,WAGlB9J,KAAK0X,cAAgBE,EAAQ38B,OAASmlB,QAAQpJ,IAAI4gB,GAASpG,MAAK,eAAmBpR,QAAQ3I,UACpFuI,KAAK0X,gB,mCAOD,WACLK,EAAY,GAKlB,OAJA/X,KAAK0V,SAASxvB,SAAQ,SAAC8X,EAAOxC,GAC5B,IAAMtb,EAAM,EAAK1E,QAAQ44B,IAAM5oB,IAAKqV,SAAS,EAAKrlB,QAAQ44B,IAAK5Y,GAAOA,EACtEuc,EAAU73B,GAAOmmB,IAAWrI,EAAMyP,cAAcpuB,UAE3C04B,I,kCAGGtH,EAAOp1B,GACjB2kB,KAAKe,KAAL,MAAAf,KAAA,YAAa3kB,IACTo1B,IAAU2C,IAAYpT,KAAKe,KAAL,MAAAf,KAAA,CAAUmE,IAAV,mBAAqB9oB,O,qEAgBrCo1B,EAAO7P,EAAQgI,EAAMC,EAAMC,G,8FACjC9I,KAAK0L,O,oDAEHtvB,EAAO4jB,KAAKxkB,QACdm4B,KAAa/S,EAASpV,IAAK0oB,UAAUtT,IACrCxkB,EAAKg4B,MAAKxT,EAASpV,IAAKqV,SAASzkB,EAAKg4B,IAAKxT,IAEzCvlB,EAAO,CAACo1B,EAAO7P,QACRvL,IAATyT,EAAoBztB,EAAKV,KAAKiuB,EAAMC,EAAMC,QAC5BzT,IAATwT,EAAoBxtB,EAAKV,KAAKiuB,EAAMC,QAC3BxT,IAATuT,GAAoBvtB,EAAKV,KAAKiuB,KAEjC6N,EAAMr6B,EAAKo6B,qBAELwB,EAAKhY,KAAK4W,eAAe5N,IAAIpI,I,wBACvCoX,EAAGC,WAAa,IAAIC,K,kBACblY,M,YAGL5jB,EAAKk6B,O,oBACH7F,IAAUyC,G,wBACZlT,KAAKuW,gBAAgB1M,IAAIjJ,EAAQvlB,GACjC88B,YAAW,WACT,EAAK5B,gBAAgBrwB,SAAQ,SAAC8X,EAAOxS,GACnC,EAAKuV,KAAL,QAAI,YAAS/C,IACb,EAAK+C,KAAL,QAAI,CAAMoD,IAAN,mBAAiBnG,KACrB,EAAKuY,gBAAgBpgB,OAAO3K,QAEN,kBAAhBpP,EAAKk6B,OAAsBl6B,EAAKk6B,OAAS,K,kBAC5CtW,M,QAELyQ,IAAUuC,IAAYhT,KAAKuW,gBAAgBlgB,IAAIuK,KACjD6P,EAAQp1B,EAAK,GAAK43B,GAClBjT,KAAKuW,gBAAgBpgB,OAAOyK,I,YAI5B6V,GAAQhG,IAAUuC,IAAYvC,IAAUwC,KAAgBjT,KAAK+W,c,wBACzDqB,EAAU,SAAC5iB,EAAKwL,GAChBxL,GACFib,EAAQp1B,EAAK,GAAK+3B,GAClB/3B,EAAK,GAAKma,EACV,EAAK6iB,YAAY5H,EAAOp1B,IACf2lB,IAEL3lB,EAAKJ,OAAS,EAChBI,EAAK,GAAK2lB,EAEV3lB,EAAKV,KAAKqmB,GAEZ,EAAKqX,YAAY5H,EAAOp1B,KAI5B2kB,KAAKsY,kBAAkB1X,EAAQ6V,EAAIC,mBAAoBjG,EAAO2H,G,kBACvDpY,M,WAGLyQ,IAAUwC,G,sBACSjT,KAAK8L,UAAUmH,GAAarS,EAAQ,I,0CACjCZ,M,YAGtB5jB,EAAKmjB,iBAAuBlK,IAATuT,GACpB6H,IAAUuC,IAAYvC,IAAU0C,IAAgB1C,IAAUwC,G,wBAErDzS,EAAWpkB,EAAKg4B,IAAM5oB,IAAKzN,KAAK3B,EAAKg4B,IAAKxT,GAAUA,E,oBAG1CgT,GAAOpT,G,QAArBQ,E,qEAGGA,IAAShB,KAAK0L,O,mDACnBrwB,EAAKV,KAAKqmB,G,eAEZhB,KAAKqY,YAAY5H,EAAOp1B,G,kBAEjB2kB,M,6JAQIc,GACX,IAAM7S,EAAO6S,GAASA,EAAM7S,KAM5B,OALI6S,GAAkB,WAAT7S,GAA8B,YAATA,KAC9B+R,KAAKxkB,QAAQs6B,wBAAoC,UAAT7nB,GAA6B,WAATA,IAE9D+R,KAAKe,KAAKqS,GAAYtS,GAEjBA,GAASd,KAAK0L,S,gCAUb6M,EAAY/sB,EAAMgtB,GACrBxY,KAAK4V,WAAWvf,IAAIkiB,IACvBvY,KAAK4V,WAAW/L,IAAI0O,EAAY,IAAIrQ,KAItC,IASIuQ,EATEC,EAAS1Y,KAAK4V,WAAW5M,IAAIuP,GAE7BI,EAAaD,EAAO1P,IAAIxd,GAE9B,GAAImtB,EAEF,OADAA,EAAWt6B,SACJ,EAIT,IAAMyrB,EAAQ,WACZ,IAAM7lB,EAAOy0B,EAAO1P,IAAIxd,GAClBnN,EAAQ4F,EAAOA,EAAK5F,MAAQ,EAIlC,OAHAq6B,EAAOviB,OAAO3K,GACdotB,aAAaH,GACTx0B,GAAM20B,aAAa30B,EAAKw0B,eACrBp6B,GAGHw6B,EAAM,CAACJ,cADbA,EAAgBN,WAAWrO,EAAO0O,GACN1O,QAAOzrB,MAAO,GAE1C,OADAq6B,EAAO7O,IAAIre,EAAMqtB,GACVA,I,wCAIP,OAAO7Y,KAAK8W,gB,wCAWIlW,EAAQkY,EAAWrI,EAAO2H,GAAS,IAC/CW,EAD+C,OAG/CvY,EAAWI,EACXZ,KAAKxkB,QAAQ44B,MAAQ5oB,IAAK6oB,WAAWzT,KACvCJ,EAAWhV,IAAKzN,KAAKiiB,KAAKxkB,QAAQ44B,IAAKxT,IAGzC,IAAMoY,EAAM,IAAId,KA8BXlY,KAAK4W,eAAevgB,IAAIuK,KAC3BZ,KAAK4W,eAAe/M,IAAIjJ,EAAQ,CAC9BqX,WAAYe,EACZC,WAAY,WAGV,OAFA,EAAKrC,eAAezgB,OAAOyK,GAC3BgY,aAAaG,GACNtI,KAGXsI,EAAiBZ,YArCM,SAAnB3B,EAAoB0C,GACxB7b,IAAGC,KAAKkD,GAAU,SAAChL,EAAK2jB,GACtB,IAAI3jB,GAAQ,EAAKohB,eAAevgB,IAAIuK,GAApC,CAKA,IAAMoY,EAAMhgC,OAAO,IAAIk/B,MAEnBgB,GAAYC,EAAQnR,OAASkR,EAASlR,OACxC,EAAK4O,eAAe5N,IAAIpI,GAAQqX,WAAae,GAGpCA,EADA,EAAKpC,eAAe5N,IAAIpI,GACfqX,YAEVa,GACR,EAAKlC,eAAezgB,OAAOyK,GAC3BwX,OAAQ/iB,EAAW8jB,IAEnBJ,EAAiBZ,WACf3B,EACA,EAAKh7B,QAAQg7B,iBAAiBG,aAC9BwC,QAnBE3jB,GAAoB,WAAbA,EAAIvH,MAAmBmqB,EAAQ5iB,QAoC5CwK,KAAKxkB,QAAQg7B,iBAAiBG,iB,wCAMlC,mBAAW3W,KAAKsQ,cAAcoE,Y,iCASrBlpB,EAAMwV,GACf,GAAIhB,KAAKxkB,QAAQ86B,QAAUtQ,GAAOrlB,KAAK6K,GAAO,OAAO,EACrD,IAAKwU,KAAKuX,aAAc,KACfnD,EAAOpU,KAAKxkB,QAAZ44B,IACDgF,EAAMpZ,KAAKxkB,QAAQk2B,QAEnBA,EAAU0H,GAAOA,EAAIp1B,IAAImwB,GAAiBC,IAC1C3X,EAAQ0F,GAAOuP,GAClB9qB,QAAO,SAAC4E,GAAD,cAAiBA,IAASob,KAAgBhY,GAAOpD,MACxDxH,KAAI,SAACwH,GAAD,OAAUA,EAAOib,MAClB3Q,EAAOkK,KAAKqZ,kBAAkBr1B,IAAImwB,GAAiBC,IAAMt2B,OAAO4zB,EAASjV,GAC/EuD,KAAKuX,aAAezU,GAAShN,OAAMT,EAAWsR,IAGhD,OAAO3G,KAAKuX,aAAa,CAAC/rB,EAAMwV,M,mCAGrBxV,EAAM8R,GACjB,OAAQ0C,KAAKkO,WAAW1iB,EAAM8R,K,uCASf9R,EAAM/F,GACrB,IAAM2oB,EAAY3oB,GAASua,KAAKxkB,QAAQu6B,kBAAoBnnB,GAAOpD,GAAQA,EAtuE5D,SAAoB9K,EAAKtE,GAC1Bya,OAAO4e,OAAO,CAAE6D,iBAAiB,GAAQl9B,GAG3Ck9B,iBAAmB9V,IAAW9iB,EAAIyF,QAfpC,KAeqD,IAC7DzF,EAAMA,EAAI0L,QAAQsX,GAhBV,MAoBNC,GAAUhjB,KAAKD,KACjBA,GArBQ,KAyBVA,GAAO,IAGP,GACEA,EAAM4iB,GAAiB5iB,SAChBkO,GAAOlO,IAAQkjB,GAAOjjB,KAAKD,IAGpC,OAAOA,EAAI0L,QAAQtS,GAAS,MAgtEsDy/B,CAAW/tB,GACvF6iB,EAASrO,KAAKxkB,QAAQ+wB,eAE5B,OAAO,IAAIoI,GAAYnpB,EAAM4iB,EAAWC,EAAQrO,Q,qCAWnCsK,GACRtK,KAAKwZ,eAAcxZ,KAAKwZ,aAAexZ,KAAKmM,QAAQ7C,KAAKtJ,OAC9D,IAAMxE,EAAMhQ,IAAKiM,QAAQ6S,GAEzB,OADKtK,KAAK0V,SAASrf,IAAImF,IAAMwE,KAAK0V,SAAS7L,IAAIrO,EAAK,IAAI+Y,GAAS/Y,EAAKwE,KAAKwZ,eACpExZ,KAAK0V,SAAS1M,IAAIxN,K,0CAYPwF,GAClB,GAAIhB,KAAKxkB,QAAQs6B,uBAAwB,OAAO,EAGhD,IACM2D,EAAU,KADLzY,GAAShoB,OAAOk2B,SAASlO,EAAM0Y,KAAM,KAE1CC,EAAK3gC,OAAOk2B,SAASuK,EAAG/W,SAAS,GAAG,GAAI,IAC9C,OAAO7b,QAAQ,EAAI8yB,K,8BAWbrP,EAAWrmB,EAAMid,GAAa,WAI9BN,EAASpV,IAAKzN,KAAKusB,EAAWrmB,GAC9Buc,EAAWhV,IAAKiM,QAAQmJ,GAO9B,GANAM,EAA6B,MAAfA,EACVA,EACAlB,KAAK0V,SAASrf,IAAIuK,IAAWZ,KAAK0V,SAASrf,IAAImK,GAI9CR,KAAK8L,UAAU,SAAUlL,EAAQ,KAAtC,CAGKM,GAAgBlB,KAAKxkB,QAAQw6B,aAAsC,IAAvBhW,KAAK0V,SAAS1N,MAC7DhI,KAAK7gB,IAAImrB,EAAWrmB,GAAM,GAKjB+b,KAAKuK,eAAe3J,GACI6M,cAGXvnB,SAAQ,SAAA0zB,GAAM,OAAI,EAAKzN,QAAQvL,EAAQgZ,MAG/D,IAAMn+B,EAASukB,KAAKuK,eAAeD,GAC7BuP,EAAap+B,EAAO4a,IAAIpS,GAC9BxI,EAAOq+B,OAAO71B,GAGd,IAAI81B,EAAUnZ,EAEd,GADIZ,KAAKxkB,QAAQ44B,MAAK2F,EAAUvuB,IAAKqV,SAASb,KAAKxkB,QAAQ44B,IAAKxT,IAC5DZ,KAAKxkB,QAAQg7B,kBAAoBxW,KAAK4W,eAAevgB,IAAI0jB,GAE3D,GADc/Z,KAAK4W,eAAe5N,IAAI+Q,GAASd,eACjCjG,GAAU,OAK1BhT,KAAK0V,SAASvf,OAAOyK,GACrBZ,KAAK0V,SAASvf,OAAOqK,GACrB,IAAMuQ,EAAY7P,EAAcuD,GAAgByO,GAC5C2G,IAAe7Z,KAAKkO,WAAWtN,IAASZ,KAAKkM,MAAM6E,EAAWnQ,GAG7DZ,KAAKxkB,QAAQw6B,aAChBhW,KAAKyX,WAAW7W,M,iCAQTA,GACT,IAAMgX,EAAU5X,KAAK2V,SAAS3M,IAAIpI,GAClC,GAAKgX,EAAL,CACAA,EAAQ1xB,SAAQ,SAAAskB,GAAM,OAAIA,OAC1BxK,KAAK2V,SAASxf,OAAOyK,GACrB,IAAMpF,EAAMhQ,IAAK+X,QAAQ3C,GACzBZ,KAAKuK,eAAe/O,GAAKse,OAAOtuB,IAAKuJ,SAAS6L,O,qCAQjCpV,EAAMgf,GACnB,GAAKA,EAAL,CACA,IAAI1U,EAAOkK,KAAK2V,SAAS3M,IAAIxd,GACxBsK,IACHA,EAAO,GACPkK,KAAK2V,SAAS9L,IAAIre,EAAMsK,IAE1BA,EAAKnb,KAAK6vB,M,gCAGF/L,EAAMriB,GAAM,WACpB,IAAI4jB,KAAK0L,OAAT,CACA,IAAMlwB,EAAU,aAACpC,KAAM+qB,GAAQ5E,YAAY,EAAMhC,OAAO,GAASnhB,GAC7D8gB,EAASyE,GAAWlD,EAAMjjB,GAW9B,OAVAwkB,KAAK6V,SAAS12B,IAAI+d,GAClBA,EAAOqQ,KAAKzI,IAAW,WACrB5H,OAAS7H,KAEX6H,EAAOqQ,KAAK8F,IAAW,WACjBnW,IACF,EAAK2Y,SAAS1f,OAAO+G,GACrBA,OAAS7H,MAGN6H,O,GAnoBe2V,IAypBpBmH,GAAW,CACdzE,UAjBiBA,GAkBjBlb,MAVa,SAACoC,EAAOjhB,GACpB,IAAM2tB,EAAU,IAAIoM,GAAU/5B,GAE9B,OADA2tB,EAAQhqB,IAAIsd,GACL0M,IAUH8Q,G,WACF,WAAYC,EAAMC,GAAiB,oBAC/Bna,KAAKoa,kBAAoB,IAAIlS,IAC7BlI,KAAKma,gBAAkBA,EACvBna,KAAKka,KAAOA,EACZla,KAAKmJ,QAAUnJ,KAAKqa,cAAc,M,oDAGlCra,KAAKmJ,QAAQ5uB,QADT,oBAEkBylB,KAAKoa,kBAAkB1F,UAFzC,IAEJ,2BAAuD,SAC3Cn6B,SAHR,iC,8BAMAgd,GACJyI,KAAKmJ,QAAQmR,QAAQ/iB,GACrB,IAAMgjB,EAAmBva,KAAKoa,kBAAkBpR,IAAIzR,GAChDgjB,IACAva,KAAKoa,kBAAkBjkB,OAAOoB,GAC9BgjB,EAAiBhgC,W,4BAGnBgd,EAAIijB,GACN,GAAIA,EAAuB,CACvB,IAAMrR,EAAUnJ,KAAKoa,kBAAkBpR,IAAIzR,IAAOyI,KAAKqa,cAAc9iB,GACrE4R,EAAQhqB,IAAIoY,GACZyI,KAAKoa,kBAAkBvQ,IAAItS,EAAI4R,QAG/BnJ,KAAKmJ,QAAQhqB,IAAIoY,K,oCAGXkjB,GACV,IAAMP,EAAOla,KAAKka,KACZQ,EAAyB,UAAf1uB,qBACVwuB,EAA+C,OAAvBC,EACxBE,EAAe,SAACpjB,GAClB,IAAMqjB,EAAYH,GAAsBljB,EACpCmjB,IAIAvR,EAAQmR,QAAQM,GAChBzR,EAAQhqB,IAAIy7B,IAEhBV,EAAKW,WAAWD,EAAWJ,IAEzBrR,EAAU6Q,GACX3f,MAAM,GAAI2F,KAAKma,iBACf1Y,GAAG,SAAUkZ,GACblZ,GAAG,SAAUkZ,GAClB,OAAOxR,M,KAIT2R,G,WACF,WAAYC,EAASC,GAAS,+BAC1Bhb,KAAKib,WAAa,EAClBjb,KAAKkb,aAAe,KACpBlb,KAAKmb,eAAiB,IAAIj8B,IAC1B8gB,KAAKob,OAAQ,EACbpb,KAAKgb,QAAUA,EACfA,EAAQzgC,MAAQylB,KAAKzlB,MAAM+uB,KAAKtJ,MAChCA,KAAKqb,MAAQN,EAAQ/2B,KAAI,SAAA0U,GAAM,OAAI,IAAI4iB,GAAK,EAAM5iB,MAClDsH,KAAKib,WAAaF,EAAQtgC,QAAO,SAACwgC,EAAD,OAAe5gB,EAAf,EAAeA,MAAf,OAA2BA,GAAqC,kBAArBA,EAAM4gB,WAC5En+B,KAAKtD,IAAIyhC,EAAY5gB,EAAM4gB,YAC3BA,IAAYjb,KAAKib,YACvBjb,KAAKub,SAAU,EACfxvB,EAAQirB,UAAS,kBAAM,EAAKwE,S,oDAGxBxb,KAAKkb,cACLtC,aAAa5Y,KAAKkb,cAFlB,oBAGelb,KAAKqb,OAHpB,IAGJ,2BAA+B,SACtB9gC,SAJL,8BAMJylB,KAAKgb,QAAQrD,uB,2BAEZlH,EAAO12B,GACRimB,KAAKgb,QAAQja,KAAK0P,EAAO12B,K,iCAElBwd,GAAI,WACPA,GACAyI,KAAKmb,eAAeh8B,IAAIoY,GAExByI,KAAKub,QACLvb,KAAKob,OAAQ,GAGbpb,KAAKkb,cACLtC,aAAa5Y,KAAKkb,cACtBlb,KAAKkb,aAAe/C,YAAW,WAC3B,EAAK+C,aAAe,KADa,oBAEhB,EAAKC,gBAFW,IAEjC,2BAAsC,KAA3B5jB,EAA2B,QAClC,EAAKwJ,KAAK,SAAUxJ,IAHS,8BAKjC,EAAK4jB,eAAerR,QACpB,EAAK/I,KAAK,WACV,EAAKya,QACNxb,KAAKib,e,gJAGRjb,KAAKub,SAAU,EACfvb,KAAKe,KAAK,QAAS,CACf9S,KAAM,U,uBAGa+R,KAAKqb,O,gEAAbnB,E,kBACDA,EAAKsB,M,+IAEfxb,KAAKub,SAAU,EACfvb,KAAKe,KAAK,QAAS,CACf9S,KAAM,Q,kDAIV+R,KAAKub,SAAU,EACfvb,KAAKe,KAAK,QAAS,CACf9S,KAAM,QACN6S,MAAK,O,QAGTd,KAAKob,QACLpb,KAAKob,OAAQ,EACbpb,KAAK6a,c,oIAIXS,G,WACF,WAAYnS,EAASzQ,GAAQ,oBACzBsH,KAAKrjB,MAAQ,CAAE8+B,QAAS,IACxBzb,KAAK0b,WAAa,GAClB1b,KAAK2b,aAAc,EACnB3b,KAAKmJ,QAAUA,EACfnJ,KAAK0L,QAAS,EACd1L,KAAK4b,QAAU,IAAI18B,IACnB8gB,KAAK6b,UAAYnjB,EAAO2B,SAAW3B,EAAO2B,MAAMwhB,UAChD7b,KAAKxkB,QAlpGb,SAAsBkd,GAAwG,IAAhGN,EAAgG,uDAA5E,CAAEC,SAAU,GAAIC,aAASjD,GAAauD,EAAsC,uDAAfkjB,IACrGC,EAAU5jB,GAAkBC,GAC5BY,EAAeP,GAAkBC,EAAQqjB,EAASnjB,GAClDqC,EAAOjC,EAAaS,OACtBsiB,EAAQlgC,QACRgb,OAAO4e,OAAOsG,EAASA,EAAQlgC,QAEnC,IAAMmgC,EAAqBniB,YAAcnB,EAAO7c,QACd,IAA9BmgC,EAAmB/gC,QACnB+gC,EAAmBrhC,KAAK,IAC5B,IAAMugB,EAAgB8gB,EAAmBh4B,KAAI,SAAAi4B,GAAmB,OAAIjhB,GAAmBihB,EAAqBF,EAAS9gB,MAGrH,OAFAV,YAAmBwhB,EAASllB,OAAOD,KAAKoC,GAAclb,OAAO+Y,OAAOD,KAAKsE,EAAc,IAAItU,QAAO,SAAAs1B,GAAM,MAAe,2BAAXA,KAAsCrlB,OAAOD,KAAKc,IAAiB,SAAU,cAAe,SAAU,SAAU,QAAS,sBAAuB,YAAauD,EAAM,sBAC/QjC,EAAand,OAASqf,EACflC,EAqoGYmjB,CAAazjB,GAC5BsH,KAAKoc,QAAUpc,KAAKxkB,QAAQK,OAC5BmkB,KAAKqc,YAAcrc,KAAKoc,QAAQp4B,KAAI,SAAAnI,GAChC,GAAIA,EAAOigB,MAAQjgB,EAAO2f,IACtB,OAAO/D,kBAAQ5b,EAAOigB,MAAQjgB,EAAO2f,QAG7C,IAAM8gB,EAAetc,KAAKxkB,QAAQ6e,OAAS,GAC3C2F,KAAKpZ,OA1sGQ,SAAsB21B,EAASC,EAAShhC,GACzD,IAAMgc,EAAiBhc,GAAWA,EAAQic,QACpCglB,EAAa,SAACllB,GAChB,OAAOA,aAAcvC,OACfuC,EACA,CACE5W,KAAMwW,GAAaxC,QAAQ2C,GAAiBC,EAAIC,GAC3C7K,MAAMlB,OACN1N,KAAK,KAAM,CAAEoS,KAAK,MAG7BusB,EAAkBtlB,GAAYmlB,GAASv4B,IAAIy4B,GAC3CE,EAAkBvlB,GAAYolB,GAASx4B,IAAIy4B,GACjD,OAAO,SAAUllB,GACb,GAAkB,kBAAPA,EACP,OAAO,EACX,GAAI,KAAK5W,KAAK4W,GACV,OAAO,EACXA,EAAKA,EAAG5K,MAAMlB,OAAK1N,KAAK,KACxB,IAAK,IAAI/C,EAAI,EAAGA,EAAI2hC,EAAgB1hC,SAAUD,EAAG,CAE7C,GADgB2hC,EAAgB3hC,GACpB2F,KAAK4W,GACb,OAAO,EAEf,IAAK,IAAIvc,EAAI,EAAGA,EAAI0hC,EAAgBzhC,SAAUD,EAAG,CAE7C,GADgB0hC,EAAgB1hC,GACpB2F,KAAK4W,GACb,OAAO,EAEf,OAAQmlB,EAAgBzhC,QA6qGV2hC,CAAaN,EAAaC,QAASD,EAAaE,SAC9Dxc,KAAK6c,YAAc,IAAI5C,GAAYja,KAAhB,2BACZsc,EAAatC,UADD,IAEfjE,iBAAiB,EACjB3J,eAAe,K,oDAInBpM,KAAK0L,QAAS,EACd1L,KAAK6c,YAAYtiC,U,iCAEVgd,EAAIijB,GAEX,GADAxa,KAAK2b,aAAc,EACfnB,EAAuB,qBACFxa,KAAKrjB,MAAM8+B,SADT,IACvB,2BAAyC,KAA9B7iC,EAA8B,SACa,IAA9CA,EAAOkkC,sBAAsB32B,QAAQoR,KAGzC3e,EAAOmkC,aAAe,OALH,+BAQ3B/c,KAAKmJ,QAAQ0R,WAAWtjB,K,yJAGnByI,KAAK2b,Y,wDAEV3b,KAAK2b,aAAc,EACbngC,E,2BACCwkB,KAAKxkB,S,IACRmB,MAAOqjB,KAAKrjB,QAEVuB,EAAQg6B,KAAKc,MACnBhZ,KAAKmJ,QAAQpI,KAAK,QAAS,CACvB9S,KAAM,eACN5M,MAAO2e,KAAKxkB,QAAQ6F,MACpBxF,OAAQmkB,KAAKqc,c,kBAGQW,YAAexhC,EAASwkB,KAAKmJ,QAAQ6R,S,UAApDngC,E,QACFmlB,KAAK0L,O,sDAGT1L,KAAKid,mBAAmBpiC,G,KACxBmlB,KAAK6b,U,uCAAoBzb,QAAQpJ,IAAIgJ,KAAKoc,QAAQp4B,KAAI,SAAAnI,GAAM,OAAIhB,EAAOqiC,MAAMrhC,O,QAC7EmkB,KAAKmJ,QAAQpI,KAAK,QAAS,CACvB9S,KAAM,aACNkvB,SAAUjF,KAAKc,MAAQ96B,EACvBmD,MAAO2e,KAAKxkB,QAAQ6F,MACpBxF,OAAQmkB,KAAKqc,YACbxhC,W,sDAIAmlB,KAAK0L,O,mDAGT,GAAIvwB,MAAMC,QAAQ,KAAMsgC,YAAa,eAChB,KAAMA,YADU,IACjC,2BAAWnkB,EAAwB,QAC/ByI,KAAKmL,UAAU5T,GAFc,+B,MAKjC,KAAMA,KACNyI,KAAKrjB,MAAM8+B,QAAUzb,KAAKrjB,MAAM8+B,QAAQ70B,QAAO,SAAAhO,GAAM,OAAIA,EAAO2e,KAAO,KAAMA,O,8JAKtE1c,GACf,IAAMuiC,EAAoBpd,KAAK4b,QAC/B5b,KAAK4b,QAAU,IAAI18B,IACnB8gB,KAAK0b,WAAa7gC,EAAO6gC,WACzB1b,KAAKrjB,MAAQ9B,EAAO8B,MAJG,oBAKNqjB,KAAK0b,YALC,IAKvB,2BAAkC,KAAvBnkB,EAAuB,QAC9ByI,KAAKmL,UAAU5T,IANI,kDAQFyI,KAAKrjB,MAAM8+B,SART,IAQvB,2BAAyC,OAA9B7iC,EAA8B,sBACjBA,EAAOkkC,uBADU,IACrC,2BAAkD,KAAvCO,EAAuC,QAC9Crd,KAAKmL,UAAUkS,GAAO,IAFW,gCARlB,kDAaND,GAbM,IAavB,2BAAoC,KAAzB7lB,EAAyB,QAC3ByI,KAAK4b,QAAQvlB,IAAIkB,IAClByI,KAAK6c,YAAYvC,QAAQ/iB,IAfV,iC,gCAmBjBA,GAAmC,IAA/BijB,EAA+B,wDACzC,GAAKxa,KAAKpZ,OAAO2Q,GAAjB,CAGA,GADAyI,KAAK4b,QAAQz8B,IAAIoY,GACbyI,KAAKqc,YAAYj8B,MAAK,SAAA0b,GAAI,OAAIA,IAASvE,KACvC,MAAM,IAAI3E,MAAM,sCAIpBoN,KAAK6c,YAAYxiB,MAAM9C,EAAIijB,Q,0CCzmOnC3hC,EAAQykC,WAAa,WAAc,MAAO,MAE1CzkC,EAAQ0kC,SAAW,WACf,MAAwB,qBAAbC,SACAA,SAASD,SAER,IAGhB1kC,EAAQ4kC,QAAU,WAAc,MAAO,IAEvC5kC,EAAQ6kC,OAAS,WAAc,OAAO,GAEtC7kC,EAAQ8kC,QAAU,WACd,OAAO3kC,OAAO4kC,WAGlB/kC,EAAQglC,SAAW,WACf,OAAO7kC,OAAO4kC,WAGlB/kC,EAAQilC,KAAO,WAAc,MAAO,IAEpCjlC,EAAQO,KAAO,WAAc,MAAO,WAEpCP,EAAQklC,QAAU,WACd,MAAyB,qBAAdC,UACAA,UAAUC,WAEd,IAGXplC,EAAQqlC,kBACNrlC,EAAQslC,qBACR,WAAc,MAAO,IAEvBtlC,EAAQulC,KAAO,WAAc,MAAO,cAEpCvlC,EAAQmT,SAAW,WAAc,MAAO,WAExCnT,EAAQwlC,OAASxlC,EAAQylC,OAAS,WAC9B,MAAO,QAGXzlC,EAAQ0lC,IAAM,KAEd1lC,EAAQ2lC,QAAU,WACjB,MAAO","file":"static/js/4.10611cca.chunk.js","sourcesContent":["/*\n  @license\n\tRollup.js v2.19.0\n\tSun, 05 Jul 2020 05:21:42 GMT - commit 8339c37e7b003ee4aeec5d1f399a1ec43fbf1178\n\n\n\thttps://github.com/rollup/rollup\n\n\tReleased under the MIT License.\n*/\nimport { createCommonjsModule, defaultOnWarn, ensureArray as ensureArray$1, warnUnknownOptions, getCjsExportFromNamespace, fseventsImporter, rollupInternal } from './rollup.js';\nimport path, { sep, resolve } from 'path';\nimport 'crypto';\nimport fs from 'fs';\nimport events from 'events';\nimport util from 'util';\nimport stream from 'stream';\nimport os, { platform } from 'os';\n\nvar utils = createCommonjsModule(function (module, exports) {\n\nexports.isInteger = num => {\n  if (typeof num === 'number') {\n    return Number.isInteger(num);\n  }\n  if (typeof num === 'string' && num.trim() !== '') {\n    return Number.isInteger(Number(num));\n  }\n  return false;\n};\n\n/**\n * Find a node of the given type\n */\n\nexports.find = (node, type) => node.nodes.find(node => node.type === type);\n\n/**\n * Find a node of the given type\n */\n\nexports.exceedsLimit = (min, max, step = 1, limit) => {\n  if (limit === false) return false;\n  if (!exports.isInteger(min) || !exports.isInteger(max)) return false;\n  return ((Number(max) - Number(min)) / Number(step)) >= limit;\n};\n\n/**\n * Escape the given node with '\\\\' before node.value\n */\n\nexports.escapeNode = (block, n = 0, type) => {\n  let node = block.nodes[n];\n  if (!node) return;\n\n  if ((type && node.type === type) || node.type === 'open' || node.type === 'close') {\n    if (node.escaped !== true) {\n      node.value = '\\\\' + node.value;\n      node.escaped = true;\n    }\n  }\n};\n\n/**\n * Returns true if the given brace node should be enclosed in literal braces\n */\n\nexports.encloseBrace = node => {\n  if (node.type !== 'brace') return false;\n  if ((node.commas >> 0 + node.ranges >> 0) === 0) {\n    node.invalid = true;\n    return true;\n  }\n  return false;\n};\n\n/**\n * Returns true if a brace node is invalid.\n */\n\nexports.isInvalidBrace = block => {\n  if (block.type !== 'brace') return false;\n  if (block.invalid === true || block.dollar) return true;\n  if ((block.commas >> 0 + block.ranges >> 0) === 0) {\n    block.invalid = true;\n    return true;\n  }\n  if (block.open !== true || block.close !== true) {\n    block.invalid = true;\n    return true;\n  }\n  return false;\n};\n\n/**\n * Returns true if a node is an open or close node\n */\n\nexports.isOpenOrClose = node => {\n  if (node.type === 'open' || node.type === 'close') {\n    return true;\n  }\n  return node.open === true || node.close === true;\n};\n\n/**\n * Reduce an array of text nodes.\n */\n\nexports.reduce = nodes => nodes.reduce((acc, node) => {\n  if (node.type === 'text') acc.push(node.value);\n  if (node.type === 'range') node.type = 'text';\n  return acc;\n}, []);\n\n/**\n * Flatten an array\n */\n\nexports.flatten = (...args) => {\n  const result = [];\n  const flat = arr => {\n    for (let i = 0; i < arr.length; i++) {\n      let ele = arr[i];\n      Array.isArray(ele) ? flat(ele) : ele !== void 0 && result.push(ele);\n    }\n    return result;\n  };\n  flat(args);\n  return result;\n};\n});\n\nvar stringify = (ast, options = {}) => {\n  let stringify = (node, parent = {}) => {\n    let invalidBlock = options.escapeInvalid && utils.isInvalidBrace(parent);\n    let invalidNode = node.invalid === true && options.escapeInvalid === true;\n    let output = '';\n\n    if (node.value) {\n      if ((invalidBlock || invalidNode) && utils.isOpenOrClose(node)) {\n        return '\\\\' + node.value;\n      }\n      return node.value;\n    }\n\n    if (node.value) {\n      return node.value;\n    }\n\n    if (node.nodes) {\n      for (let child of node.nodes) {\n        output += stringify(child);\n      }\n    }\n    return output;\n  };\n\n  return stringify(ast);\n};\n\n/*!\n * is-number <https://github.com/jonschlinkert/is-number>\n *\n * Copyright (c) 2014-present, Jon Schlinkert.\n * Released under the MIT License.\n */\n\nvar isNumber = function(num) {\n  if (typeof num === 'number') {\n    return num - num === 0;\n  }\n  if (typeof num === 'string' && num.trim() !== '') {\n    return Number.isFinite ? Number.isFinite(+num) : isFinite(+num);\n  }\n  return false;\n};\n\nconst toRegexRange = (min, max, options) => {\n  if (isNumber(min) === false) {\n    throw new TypeError('toRegexRange: expected the first argument to be a number');\n  }\n\n  if (max === void 0 || min === max) {\n    return String(min);\n  }\n\n  if (isNumber(max) === false) {\n    throw new TypeError('toRegexRange: expected the second argument to be a number.');\n  }\n\n  let opts = { relaxZeros: true, ...options };\n  if (typeof opts.strictZeros === 'boolean') {\n    opts.relaxZeros = opts.strictZeros === false;\n  }\n\n  let relax = String(opts.relaxZeros);\n  let shorthand = String(opts.shorthand);\n  let capture = String(opts.capture);\n  let wrap = String(opts.wrap);\n  let cacheKey = min + ':' + max + '=' + relax + shorthand + capture + wrap;\n\n  if (toRegexRange.cache.hasOwnProperty(cacheKey)) {\n    return toRegexRange.cache[cacheKey].result;\n  }\n\n  let a = Math.min(min, max);\n  let b = Math.max(min, max);\n\n  if (Math.abs(a - b) === 1) {\n    let result = min + '|' + max;\n    if (opts.capture) {\n      return `(${result})`;\n    }\n    if (opts.wrap === false) {\n      return result;\n    }\n    return `(?:${result})`;\n  }\n\n  let isPadded = hasPadding(min) || hasPadding(max);\n  let state = { min, max, a, b };\n  let positives = [];\n  let negatives = [];\n\n  if (isPadded) {\n    state.isPadded = isPadded;\n    state.maxLen = String(state.max).length;\n  }\n\n  if (a < 0) {\n    let newMin = b < 0 ? Math.abs(b) : 1;\n    negatives = splitToPatterns(newMin, Math.abs(a), state, opts);\n    a = state.a = 0;\n  }\n\n  if (b >= 0) {\n    positives = splitToPatterns(a, b, state, opts);\n  }\n\n  state.negatives = negatives;\n  state.positives = positives;\n  state.result = collatePatterns(negatives, positives);\n\n  if (opts.capture === true) {\n    state.result = `(${state.result})`;\n  } else if (opts.wrap !== false && (positives.length + negatives.length) > 1) {\n    state.result = `(?:${state.result})`;\n  }\n\n  toRegexRange.cache[cacheKey] = state;\n  return state.result;\n};\n\nfunction collatePatterns(neg, pos, options) {\n  let onlyNegative = filterPatterns(neg, pos, '-', false) || [];\n  let onlyPositive = filterPatterns(pos, neg, '', false) || [];\n  let intersected = filterPatterns(neg, pos, '-?', true) || [];\n  let subpatterns = onlyNegative.concat(intersected).concat(onlyPositive);\n  return subpatterns.join('|');\n}\n\nfunction splitToRanges(min, max) {\n  let nines = 1;\n  let zeros = 1;\n\n  let stop = countNines(min, nines);\n  let stops = new Set([max]);\n\n  while (min <= stop && stop <= max) {\n    stops.add(stop);\n    nines += 1;\n    stop = countNines(min, nines);\n  }\n\n  stop = countZeros(max + 1, zeros) - 1;\n\n  while (min < stop && stop <= max) {\n    stops.add(stop);\n    zeros += 1;\n    stop = countZeros(max + 1, zeros) - 1;\n  }\n\n  stops = [...stops];\n  stops.sort(compare);\n  return stops;\n}\n\n/**\n * Convert a range to a regex pattern\n * @param {Number} `start`\n * @param {Number} `stop`\n * @return {String}\n */\n\nfunction rangeToPattern(start, stop, options) {\n  if (start === stop) {\n    return { pattern: start, count: [], digits: 0 };\n  }\n\n  let zipped = zip(start, stop);\n  let digits = zipped.length;\n  let pattern = '';\n  let count = 0;\n\n  for (let i = 0; i < digits; i++) {\n    let [startDigit, stopDigit] = zipped[i];\n\n    if (startDigit === stopDigit) {\n      pattern += startDigit;\n\n    } else if (startDigit !== '0' || stopDigit !== '9') {\n      pattern += toCharacterClass(startDigit, stopDigit);\n\n    } else {\n      count++;\n    }\n  }\n\n  if (count) {\n    pattern += options.shorthand === true ? '\\\\d' : '[0-9]';\n  }\n\n  return { pattern, count: [count], digits };\n}\n\nfunction splitToPatterns(min, max, tok, options) {\n  let ranges = splitToRanges(min, max);\n  let tokens = [];\n  let start = min;\n  let prev;\n\n  for (let i = 0; i < ranges.length; i++) {\n    let max = ranges[i];\n    let obj = rangeToPattern(String(start), String(max), options);\n    let zeros = '';\n\n    if (!tok.isPadded && prev && prev.pattern === obj.pattern) {\n      if (prev.count.length > 1) {\n        prev.count.pop();\n      }\n\n      prev.count.push(obj.count[0]);\n      prev.string = prev.pattern + toQuantifier(prev.count);\n      start = max + 1;\n      continue;\n    }\n\n    if (tok.isPadded) {\n      zeros = padZeros(max, tok, options);\n    }\n\n    obj.string = zeros + obj.pattern + toQuantifier(obj.count);\n    tokens.push(obj);\n    start = max + 1;\n    prev = obj;\n  }\n\n  return tokens;\n}\n\nfunction filterPatterns(arr, comparison, prefix, intersection, options) {\n  let result = [];\n\n  for (let ele of arr) {\n    let { string } = ele;\n\n    // only push if _both_ are negative...\n    if (!intersection && !contains(comparison, 'string', string)) {\n      result.push(prefix + string);\n    }\n\n    // or _both_ are positive\n    if (intersection && contains(comparison, 'string', string)) {\n      result.push(prefix + string);\n    }\n  }\n  return result;\n}\n\n/**\n * Zip strings\n */\n\nfunction zip(a, b) {\n  let arr = [];\n  for (let i = 0; i < a.length; i++) arr.push([a[i], b[i]]);\n  return arr;\n}\n\nfunction compare(a, b) {\n  return a > b ? 1 : b > a ? -1 : 0;\n}\n\nfunction contains(arr, key, val) {\n  return arr.some(ele => ele[key] === val);\n}\n\nfunction countNines(min, len) {\n  return Number(String(min).slice(0, -len) + '9'.repeat(len));\n}\n\nfunction countZeros(integer, zeros) {\n  return integer - (integer % Math.pow(10, zeros));\n}\n\nfunction toQuantifier(digits) {\n  let [start = 0, stop = ''] = digits;\n  if (stop || start > 1) {\n    return `{${start + (stop ? ',' + stop : '')}}`;\n  }\n  return '';\n}\n\nfunction toCharacterClass(a, b, options) {\n  return `[${a}${(b - a === 1) ? '' : '-'}${b}]`;\n}\n\nfunction hasPadding(str) {\n  return /^-?(0+)\\d/.test(str);\n}\n\nfunction padZeros(value, tok, options) {\n  if (!tok.isPadded) {\n    return value;\n  }\n\n  let diff = Math.abs(tok.maxLen - String(value).length);\n  let relax = options.relaxZeros !== false;\n\n  switch (diff) {\n    case 0:\n      return '';\n    case 1:\n      return relax ? '0?' : '0';\n    case 2:\n      return relax ? '0{0,2}' : '00';\n    default: {\n      return relax ? `0{0,${diff}}` : `0{${diff}}`;\n    }\n  }\n}\n\n/**\n * Cache\n */\n\ntoRegexRange.cache = {};\ntoRegexRange.clearCache = () => (toRegexRange.cache = {});\n\n/**\n * Expose `toRegexRange`\n */\n\nvar toRegexRange_1 = toRegexRange;\n\nconst isObject = val => val !== null && typeof val === 'object' && !Array.isArray(val);\n\nconst transform = toNumber => {\n  return value => toNumber === true ? Number(value) : String(value);\n};\n\nconst isValidValue = value => {\n  return typeof value === 'number' || (typeof value === 'string' && value !== '');\n};\n\nconst isNumber$1 = num => Number.isInteger(+num);\n\nconst zeros = input => {\n  let value = `${input}`;\n  let index = -1;\n  if (value[0] === '-') value = value.slice(1);\n  if (value === '0') return false;\n  while (value[++index] === '0');\n  return index > 0;\n};\n\nconst stringify$1 = (start, end, options) => {\n  if (typeof start === 'string' || typeof end === 'string') {\n    return true;\n  }\n  return options.stringify === true;\n};\n\nconst pad = (input, maxLength, toNumber) => {\n  if (maxLength > 0) {\n    let dash = input[0] === '-' ? '-' : '';\n    if (dash) input = input.slice(1);\n    input = (dash + input.padStart(dash ? maxLength - 1 : maxLength, '0'));\n  }\n  if (toNumber === false) {\n    return String(input);\n  }\n  return input;\n};\n\nconst toMaxLen = (input, maxLength) => {\n  let negative = input[0] === '-' ? '-' : '';\n  if (negative) {\n    input = input.slice(1);\n    maxLength--;\n  }\n  while (input.length < maxLength) input = '0' + input;\n  return negative ? ('-' + input) : input;\n};\n\nconst toSequence = (parts, options) => {\n  parts.negatives.sort((a, b) => a < b ? -1 : a > b ? 1 : 0);\n  parts.positives.sort((a, b) => a < b ? -1 : a > b ? 1 : 0);\n\n  let prefix = options.capture ? '' : '?:';\n  let positives = '';\n  let negatives = '';\n  let result;\n\n  if (parts.positives.length) {\n    positives = parts.positives.join('|');\n  }\n\n  if (parts.negatives.length) {\n    negatives = `-(${prefix}${parts.negatives.join('|')})`;\n  }\n\n  if (positives && negatives) {\n    result = `${positives}|${negatives}`;\n  } else {\n    result = positives || negatives;\n  }\n\n  if (options.wrap) {\n    return `(${prefix}${result})`;\n  }\n\n  return result;\n};\n\nconst toRange = (a, b, isNumbers, options) => {\n  if (isNumbers) {\n    return toRegexRange_1(a, b, { wrap: false, ...options });\n  }\n\n  let start = String.fromCharCode(a);\n  if (a === b) return start;\n\n  let stop = String.fromCharCode(b);\n  return `[${start}-${stop}]`;\n};\n\nconst toRegex = (start, end, options) => {\n  if (Array.isArray(start)) {\n    let wrap = options.wrap === true;\n    let prefix = options.capture ? '' : '?:';\n    return wrap ? `(${prefix}${start.join('|')})` : start.join('|');\n  }\n  return toRegexRange_1(start, end, options);\n};\n\nconst rangeError = (...args) => {\n  return new RangeError('Invalid range arguments: ' + util.inspect(...args));\n};\n\nconst invalidRange = (start, end, options) => {\n  if (options.strictRanges === true) throw rangeError([start, end]);\n  return [];\n};\n\nconst invalidStep = (step, options) => {\n  if (options.strictRanges === true) {\n    throw new TypeError(`Expected step \"${step}\" to be a number`);\n  }\n  return [];\n};\n\nconst fillNumbers = (start, end, step = 1, options = {}) => {\n  let a = Number(start);\n  let b = Number(end);\n\n  if (!Number.isInteger(a) || !Number.isInteger(b)) {\n    if (options.strictRanges === true) throw rangeError([start, end]);\n    return [];\n  }\n\n  // fix negative zero\n  if (a === 0) a = 0;\n  if (b === 0) b = 0;\n\n  let descending = a > b;\n  let startString = String(start);\n  let endString = String(end);\n  let stepString = String(step);\n  step = Math.max(Math.abs(step), 1);\n\n  let padded = zeros(startString) || zeros(endString) || zeros(stepString);\n  let maxLen = padded ? Math.max(startString.length, endString.length, stepString.length) : 0;\n  let toNumber = padded === false && stringify$1(start, end, options) === false;\n  let format = options.transform || transform(toNumber);\n\n  if (options.toRegex && step === 1) {\n    return toRange(toMaxLen(start, maxLen), toMaxLen(end, maxLen), true, options);\n  }\n\n  let parts = { negatives: [], positives: [] };\n  let push = num => parts[num < 0 ? 'negatives' : 'positives'].push(Math.abs(num));\n  let range = [];\n  let index = 0;\n\n  while (descending ? a >= b : a <= b) {\n    if (options.toRegex === true && step > 1) {\n      push(a);\n    } else {\n      range.push(pad(format(a, index), maxLen, toNumber));\n    }\n    a = descending ? a - step : a + step;\n    index++;\n  }\n\n  if (options.toRegex === true) {\n    return step > 1\n      ? toSequence(parts, options)\n      : toRegex(range, null, { wrap: false, ...options });\n  }\n\n  return range;\n};\n\nconst fillLetters = (start, end, step = 1, options = {}) => {\n  if ((!isNumber$1(start) && start.length > 1) || (!isNumber$1(end) && end.length > 1)) {\n    return invalidRange(start, end, options);\n  }\n\n\n  let format = options.transform || (val => String.fromCharCode(val));\n  let a = `${start}`.charCodeAt(0);\n  let b = `${end}`.charCodeAt(0);\n\n  let descending = a > b;\n  let min = Math.min(a, b);\n  let max = Math.max(a, b);\n\n  if (options.toRegex && step === 1) {\n    return toRange(min, max, false, options);\n  }\n\n  let range = [];\n  let index = 0;\n\n  while (descending ? a >= b : a <= b) {\n    range.push(format(a, index));\n    a = descending ? a - step : a + step;\n    index++;\n  }\n\n  if (options.toRegex === true) {\n    return toRegex(range, null, { wrap: false, options });\n  }\n\n  return range;\n};\n\nconst fill = (start, end, step, options = {}) => {\n  if (end == null && isValidValue(start)) {\n    return [start];\n  }\n\n  if (!isValidValue(start) || !isValidValue(end)) {\n    return invalidRange(start, end, options);\n  }\n\n  if (typeof step === 'function') {\n    return fill(start, end, 1, { transform: step });\n  }\n\n  if (isObject(step)) {\n    return fill(start, end, 0, step);\n  }\n\n  let opts = { ...options };\n  if (opts.capture === true) opts.wrap = true;\n  step = step || opts.step || 1;\n\n  if (!isNumber$1(step)) {\n    if (step != null && !isObject(step)) return invalidStep(step, opts);\n    return fill(start, end, 1, step);\n  }\n\n  if (isNumber$1(start) && isNumber$1(end)) {\n    return fillNumbers(start, end, step, opts);\n  }\n\n  return fillLetters(start, end, Math.max(Math.abs(step), 1), opts);\n};\n\nvar fillRange = fill;\n\nconst compile = (ast, options = {}) => {\n  let walk = (node, parent = {}) => {\n    let invalidBlock = utils.isInvalidBrace(parent);\n    let invalidNode = node.invalid === true && options.escapeInvalid === true;\n    let invalid = invalidBlock === true || invalidNode === true;\n    let prefix = options.escapeInvalid === true ? '\\\\' : '';\n    let output = '';\n\n    if (node.isOpen === true) {\n      return prefix + node.value;\n    }\n    if (node.isClose === true) {\n      return prefix + node.value;\n    }\n\n    if (node.type === 'open') {\n      return invalid ? (prefix + node.value) : '(';\n    }\n\n    if (node.type === 'close') {\n      return invalid ? (prefix + node.value) : ')';\n    }\n\n    if (node.type === 'comma') {\n      return node.prev.type === 'comma' ? '' : (invalid ? node.value : '|');\n    }\n\n    if (node.value) {\n      return node.value;\n    }\n\n    if (node.nodes && node.ranges > 0) {\n      let args = utils.reduce(node.nodes);\n      let range = fillRange(...args, { ...options, wrap: false, toRegex: true });\n\n      if (range.length !== 0) {\n        return args.length > 1 && range.length > 1 ? `(${range})` : range;\n      }\n    }\n\n    if (node.nodes) {\n      for (let child of node.nodes) {\n        output += walk(child, node);\n      }\n    }\n    return output;\n  };\n\n  return walk(ast);\n};\n\nvar compile_1 = compile;\n\nconst append = (queue = '', stash = '', enclose = false) => {\n  let result = [];\n\n  queue = [].concat(queue);\n  stash = [].concat(stash);\n\n  if (!stash.length) return queue;\n  if (!queue.length) {\n    return enclose ? utils.flatten(stash).map(ele => `{${ele}}`) : stash;\n  }\n\n  for (let item of queue) {\n    if (Array.isArray(item)) {\n      for (let value of item) {\n        result.push(append(value, stash, enclose));\n      }\n    } else {\n      for (let ele of stash) {\n        if (enclose === true && typeof ele === 'string') ele = `{${ele}}`;\n        result.push(Array.isArray(ele) ? append(item, ele, enclose) : (item + ele));\n      }\n    }\n  }\n  return utils.flatten(result);\n};\n\nconst expand = (ast, options = {}) => {\n  let rangeLimit = options.rangeLimit === void 0 ? 1000 : options.rangeLimit;\n\n  let walk = (node, parent = {}) => {\n    node.queue = [];\n\n    let p = parent;\n    let q = parent.queue;\n\n    while (p.type !== 'brace' && p.type !== 'root' && p.parent) {\n      p = p.parent;\n      q = p.queue;\n    }\n\n    if (node.invalid || node.dollar) {\n      q.push(append(q.pop(), stringify(node, options)));\n      return;\n    }\n\n    if (node.type === 'brace' && node.invalid !== true && node.nodes.length === 2) {\n      q.push(append(q.pop(), ['{}']));\n      return;\n    }\n\n    if (node.nodes && node.ranges > 0) {\n      let args = utils.reduce(node.nodes);\n\n      if (utils.exceedsLimit(...args, options.step, rangeLimit)) {\n        throw new RangeError('expanded array length exceeds range limit. Use options.rangeLimit to increase or disable the limit.');\n      }\n\n      let range = fillRange(...args, options);\n      if (range.length === 0) {\n        range = stringify(node, options);\n      }\n\n      q.push(append(q.pop(), range));\n      node.nodes = [];\n      return;\n    }\n\n    let enclose = utils.encloseBrace(node);\n    let queue = node.queue;\n    let block = node;\n\n    while (block.type !== 'brace' && block.type !== 'root' && block.parent) {\n      block = block.parent;\n      queue = block.queue;\n    }\n\n    for (let i = 0; i < node.nodes.length; i++) {\n      let child = node.nodes[i];\n\n      if (child.type === 'comma' && node.type === 'brace') {\n        if (i === 1) queue.push('');\n        queue.push('');\n        continue;\n      }\n\n      if (child.type === 'close') {\n        q.push(append(q.pop(), queue, enclose));\n        continue;\n      }\n\n      if (child.value && child.type !== 'open') {\n        queue.push(append(queue.pop(), child.value));\n        continue;\n      }\n\n      if (child.nodes) {\n        walk(child, node);\n      }\n    }\n\n    return queue;\n  };\n\n  return utils.flatten(walk(ast));\n};\n\nvar expand_1 = expand;\n\nvar constants = {\n  MAX_LENGTH: 1024 * 64,\n\n  // Digits\n  CHAR_0: '0', /* 0 */\n  CHAR_9: '9', /* 9 */\n\n  // Alphabet chars.\n  CHAR_UPPERCASE_A: 'A', /* A */\n  CHAR_LOWERCASE_A: 'a', /* a */\n  CHAR_UPPERCASE_Z: 'Z', /* Z */\n  CHAR_LOWERCASE_Z: 'z', /* z */\n\n  CHAR_LEFT_PARENTHESES: '(', /* ( */\n  CHAR_RIGHT_PARENTHESES: ')', /* ) */\n\n  CHAR_ASTERISK: '*', /* * */\n\n  // Non-alphabetic chars.\n  CHAR_AMPERSAND: '&', /* & */\n  CHAR_AT: '@', /* @ */\n  CHAR_BACKSLASH: '\\\\', /* \\ */\n  CHAR_BACKTICK: '`', /* ` */\n  CHAR_CARRIAGE_RETURN: '\\r', /* \\r */\n  CHAR_CIRCUMFLEX_ACCENT: '^', /* ^ */\n  CHAR_COLON: ':', /* : */\n  CHAR_COMMA: ',', /* , */\n  CHAR_DOLLAR: '$', /* . */\n  CHAR_DOT: '.', /* . */\n  CHAR_DOUBLE_QUOTE: '\"', /* \" */\n  CHAR_EQUAL: '=', /* = */\n  CHAR_EXCLAMATION_MARK: '!', /* ! */\n  CHAR_FORM_FEED: '\\f', /* \\f */\n  CHAR_FORWARD_SLASH: '/', /* / */\n  CHAR_HASH: '#', /* # */\n  CHAR_HYPHEN_MINUS: '-', /* - */\n  CHAR_LEFT_ANGLE_BRACKET: '<', /* < */\n  CHAR_LEFT_CURLY_BRACE: '{', /* { */\n  CHAR_LEFT_SQUARE_BRACKET: '[', /* [ */\n  CHAR_LINE_FEED: '\\n', /* \\n */\n  CHAR_NO_BREAK_SPACE: '\\u00A0', /* \\u00A0 */\n  CHAR_PERCENT: '%', /* % */\n  CHAR_PLUS: '+', /* + */\n  CHAR_QUESTION_MARK: '?', /* ? */\n  CHAR_RIGHT_ANGLE_BRACKET: '>', /* > */\n  CHAR_RIGHT_CURLY_BRACE: '}', /* } */\n  CHAR_RIGHT_SQUARE_BRACKET: ']', /* ] */\n  CHAR_SEMICOLON: ';', /* ; */\n  CHAR_SINGLE_QUOTE: '\\'', /* ' */\n  CHAR_SPACE: ' ', /*   */\n  CHAR_TAB: '\\t', /* \\t */\n  CHAR_UNDERSCORE: '_', /* _ */\n  CHAR_VERTICAL_LINE: '|', /* | */\n  CHAR_ZERO_WIDTH_NOBREAK_SPACE: '\\uFEFF' /* \\uFEFF */\n};\n\n/**\n * Constants\n */\n\nconst {\n  MAX_LENGTH,\n  CHAR_BACKSLASH, /* \\ */\n  CHAR_BACKTICK, /* ` */\n  CHAR_COMMA, /* , */\n  CHAR_DOT, /* . */\n  CHAR_LEFT_PARENTHESES, /* ( */\n  CHAR_RIGHT_PARENTHESES, /* ) */\n  CHAR_LEFT_CURLY_BRACE, /* { */\n  CHAR_RIGHT_CURLY_BRACE, /* } */\n  CHAR_LEFT_SQUARE_BRACKET, /* [ */\n  CHAR_RIGHT_SQUARE_BRACKET, /* ] */\n  CHAR_DOUBLE_QUOTE, /* \" */\n  CHAR_SINGLE_QUOTE, /* ' */\n  CHAR_NO_BREAK_SPACE,\n  CHAR_ZERO_WIDTH_NOBREAK_SPACE\n} = constants;\n\n/**\n * parse\n */\n\nconst parse = (input, options = {}) => {\n  if (typeof input !== 'string') {\n    throw new TypeError('Expected a string');\n  }\n\n  let opts = options || {};\n  let max = typeof opts.maxLength === 'number' ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;\n  if (input.length > max) {\n    throw new SyntaxError(`Input length (${input.length}), exceeds max characters (${max})`);\n  }\n\n  let ast = { type: 'root', input, nodes: [] };\n  let stack = [ast];\n  let block = ast;\n  let prev = ast;\n  let brackets = 0;\n  let length = input.length;\n  let index = 0;\n  let depth = 0;\n  let value;\n\n  /**\n   * Helpers\n   */\n\n  const advance = () => input[index++];\n  const push = node => {\n    if (node.type === 'text' && prev.type === 'dot') {\n      prev.type = 'text';\n    }\n\n    if (prev && prev.type === 'text' && node.type === 'text') {\n      prev.value += node.value;\n      return;\n    }\n\n    block.nodes.push(node);\n    node.parent = block;\n    node.prev = prev;\n    prev = node;\n    return node;\n  };\n\n  push({ type: 'bos' });\n\n  while (index < length) {\n    block = stack[stack.length - 1];\n    value = advance();\n\n    /**\n     * Invalid chars\n     */\n\n    if (value === CHAR_ZERO_WIDTH_NOBREAK_SPACE || value === CHAR_NO_BREAK_SPACE) {\n      continue;\n    }\n\n    /**\n     * Escaped chars\n     */\n\n    if (value === CHAR_BACKSLASH) {\n      push({ type: 'text', value: (options.keepEscaping ? value : '') + advance() });\n      continue;\n    }\n\n    /**\n     * Right square bracket (literal): ']'\n     */\n\n    if (value === CHAR_RIGHT_SQUARE_BRACKET) {\n      push({ type: 'text', value: '\\\\' + value });\n      continue;\n    }\n\n    /**\n     * Left square bracket: '['\n     */\n\n    if (value === CHAR_LEFT_SQUARE_BRACKET) {\n      brackets++;\n      let next;\n\n      while (index < length && (next = advance())) {\n        value += next;\n\n        if (next === CHAR_LEFT_SQUARE_BRACKET) {\n          brackets++;\n          continue;\n        }\n\n        if (next === CHAR_BACKSLASH) {\n          value += advance();\n          continue;\n        }\n\n        if (next === CHAR_RIGHT_SQUARE_BRACKET) {\n          brackets--;\n\n          if (brackets === 0) {\n            break;\n          }\n        }\n      }\n\n      push({ type: 'text', value });\n      continue;\n    }\n\n    /**\n     * Parentheses\n     */\n\n    if (value === CHAR_LEFT_PARENTHESES) {\n      block = push({ type: 'paren', nodes: [] });\n      stack.push(block);\n      push({ type: 'text', value });\n      continue;\n    }\n\n    if (value === CHAR_RIGHT_PARENTHESES) {\n      if (block.type !== 'paren') {\n        push({ type: 'text', value });\n        continue;\n      }\n      block = stack.pop();\n      push({ type: 'text', value });\n      block = stack[stack.length - 1];\n      continue;\n    }\n\n    /**\n     * Quotes: '|\"|`\n     */\n\n    if (value === CHAR_DOUBLE_QUOTE || value === CHAR_SINGLE_QUOTE || value === CHAR_BACKTICK) {\n      let open = value;\n      let next;\n\n      if (options.keepQuotes !== true) {\n        value = '';\n      }\n\n      while (index < length && (next = advance())) {\n        if (next === CHAR_BACKSLASH) {\n          value += next + advance();\n          continue;\n        }\n\n        if (next === open) {\n          if (options.keepQuotes === true) value += next;\n          break;\n        }\n\n        value += next;\n      }\n\n      push({ type: 'text', value });\n      continue;\n    }\n\n    /**\n     * Left curly brace: '{'\n     */\n\n    if (value === CHAR_LEFT_CURLY_BRACE) {\n      depth++;\n\n      let dollar = prev.value && prev.value.slice(-1) === '$' || block.dollar === true;\n      let brace = {\n        type: 'brace',\n        open: true,\n        close: false,\n        dollar,\n        depth,\n        commas: 0,\n        ranges: 0,\n        nodes: []\n      };\n\n      block = push(brace);\n      stack.push(block);\n      push({ type: 'open', value });\n      continue;\n    }\n\n    /**\n     * Right curly brace: '}'\n     */\n\n    if (value === CHAR_RIGHT_CURLY_BRACE) {\n      if (block.type !== 'brace') {\n        push({ type: 'text', value });\n        continue;\n      }\n\n      let type = 'close';\n      block = stack.pop();\n      block.close = true;\n\n      push({ type, value });\n      depth--;\n\n      block = stack[stack.length - 1];\n      continue;\n    }\n\n    /**\n     * Comma: ','\n     */\n\n    if (value === CHAR_COMMA && depth > 0) {\n      if (block.ranges > 0) {\n        block.ranges = 0;\n        let open = block.nodes.shift();\n        block.nodes = [open, { type: 'text', value: stringify(block) }];\n      }\n\n      push({ type: 'comma', value });\n      block.commas++;\n      continue;\n    }\n\n    /**\n     * Dot: '.'\n     */\n\n    if (value === CHAR_DOT && depth > 0 && block.commas === 0) {\n      let siblings = block.nodes;\n\n      if (depth === 0 || siblings.length === 0) {\n        push({ type: 'text', value });\n        continue;\n      }\n\n      if (prev.type === 'dot') {\n        block.range = [];\n        prev.value += value;\n        prev.type = 'range';\n\n        if (block.nodes.length !== 3 && block.nodes.length !== 5) {\n          block.invalid = true;\n          block.ranges = 0;\n          prev.type = 'text';\n          continue;\n        }\n\n        block.ranges++;\n        block.args = [];\n        continue;\n      }\n\n      if (prev.type === 'range') {\n        siblings.pop();\n\n        let before = siblings[siblings.length - 1];\n        before.value += prev.value + value;\n        prev = before;\n        block.ranges--;\n        continue;\n      }\n\n      push({ type: 'dot', value });\n      continue;\n    }\n\n    /**\n     * Text\n     */\n\n    push({ type: 'text', value });\n  }\n\n  // Mark imbalanced braces and brackets as invalid\n  do {\n    block = stack.pop();\n\n    if (block.type !== 'root') {\n      block.nodes.forEach(node => {\n        if (!node.nodes) {\n          if (node.type === 'open') node.isOpen = true;\n          if (node.type === 'close') node.isClose = true;\n          if (!node.nodes) node.type = 'text';\n          node.invalid = true;\n        }\n      });\n\n      // get the location of the block on parent.nodes (block's siblings)\n      let parent = stack[stack.length - 1];\n      let index = parent.nodes.indexOf(block);\n      // replace the (invalid) block with it's nodes\n      parent.nodes.splice(index, 1, ...block.nodes);\n    }\n  } while (stack.length > 0);\n\n  push({ type: 'eos' });\n  return ast;\n};\n\nvar parse_1 = parse;\n\n/**\n * Expand the given pattern or create a regex-compatible string.\n *\n * ```js\n * const braces = require('braces');\n * console.log(braces('{a,b,c}', { compile: true })); //=> ['(a|b|c)']\n * console.log(braces('{a,b,c}')); //=> ['a', 'b', 'c']\n * ```\n * @param {String} `str`\n * @param {Object} `options`\n * @return {String}\n * @api public\n */\n\nconst braces = (input, options = {}) => {\n  let output = [];\n\n  if (Array.isArray(input)) {\n    for (let pattern of input) {\n      let result = braces.create(pattern, options);\n      if (Array.isArray(result)) {\n        output.push(...result);\n      } else {\n        output.push(result);\n      }\n    }\n  } else {\n    output = [].concat(braces.create(input, options));\n  }\n\n  if (options && options.expand === true && options.nodupes === true) {\n    output = [...new Set(output)];\n  }\n  return output;\n};\n\n/**\n * Parse the given `str` with the given `options`.\n *\n * ```js\n * // braces.parse(pattern, [, options]);\n * const ast = braces.parse('a/{b,c}/d');\n * console.log(ast);\n * ```\n * @param {String} pattern Brace pattern to parse\n * @param {Object} options\n * @return {Object} Returns an AST\n * @api public\n */\n\nbraces.parse = (input, options = {}) => parse_1(input, options);\n\n/**\n * Creates a braces string from an AST, or an AST node.\n *\n * ```js\n * const braces = require('braces');\n * let ast = braces.parse('foo/{a,b}/bar');\n * console.log(stringify(ast.nodes[2])); //=> '{a,b}'\n * ```\n * @param {String} `input` Brace pattern or AST.\n * @param {Object} `options`\n * @return {Array} Returns an array of expanded values.\n * @api public\n */\n\nbraces.stringify = (input, options = {}) => {\n  if (typeof input === 'string') {\n    return stringify(braces.parse(input, options), options);\n  }\n  return stringify(input, options);\n};\n\n/**\n * Compiles a brace pattern into a regex-compatible, optimized string.\n * This method is called by the main [braces](#braces) function by default.\n *\n * ```js\n * const braces = require('braces');\n * console.log(braces.compile('a/{b,c}/d'));\n * //=> ['a/(b|c)/d']\n * ```\n * @param {String} `input` Brace pattern or AST.\n * @param {Object} `options`\n * @return {Array} Returns an array of expanded values.\n * @api public\n */\n\nbraces.compile = (input, options = {}) => {\n  if (typeof input === 'string') {\n    input = braces.parse(input, options);\n  }\n  return compile_1(input, options);\n};\n\n/**\n * Expands a brace pattern into an array. This method is called by the\n * main [braces](#braces) function when `options.expand` is true. Before\n * using this method it's recommended that you read the [performance notes](#performance))\n * and advantages of using [.compile](#compile) instead.\n *\n * ```js\n * const braces = require('braces');\n * console.log(braces.expand('a/{b,c}/d'));\n * //=> ['a/b/d', 'a/c/d'];\n * ```\n * @param {String} `pattern` Brace pattern\n * @param {Object} `options`\n * @return {Array} Returns an array of expanded values.\n * @api public\n */\n\nbraces.expand = (input, options = {}) => {\n  if (typeof input === 'string') {\n    input = braces.parse(input, options);\n  }\n\n  let result = expand_1(input, options);\n\n  // filter out empty strings if specified\n  if (options.noempty === true) {\n    result = result.filter(Boolean);\n  }\n\n  // filter out duplicates if specified\n  if (options.nodupes === true) {\n    result = [...new Set(result)];\n  }\n\n  return result;\n};\n\n/**\n * Processes a brace pattern and returns either an expanded array\n * (if `options.expand` is true), a highly optimized regex-compatible string.\n * This method is called by the main [braces](#braces) function.\n *\n * ```js\n * const braces = require('braces');\n * console.log(braces.create('user-{200..300}/project-{a,b,c}-{1..10}'))\n * //=> 'user-(20[0-9]|2[1-9][0-9]|300)/project-(a|b|c)-([1-9]|10)'\n * ```\n * @param {String} `pattern` Brace pattern\n * @param {Object} `options`\n * @return {Array} Returns an array of expanded values.\n * @api public\n */\n\nbraces.create = (input, options = {}) => {\n  if (input === '' || input.length < 3) {\n    return [input];\n  }\n\n return options.expand !== true\n    ? braces.compile(input, options)\n    : braces.expand(input, options);\n};\n\n/**\n * Expose \"braces\"\n */\n\nvar braces_1 = braces;\n\nconst WIN_SLASH = '\\\\\\\\/';\nconst WIN_NO_SLASH = `[^${WIN_SLASH}]`;\n\n/**\n * Posix glob regex\n */\n\nconst DOT_LITERAL = '\\\\.';\nconst PLUS_LITERAL = '\\\\+';\nconst QMARK_LITERAL = '\\\\?';\nconst SLASH_LITERAL = '\\\\/';\nconst ONE_CHAR = '(?=.)';\nconst QMARK = '[^/]';\nconst END_ANCHOR = `(?:${SLASH_LITERAL}|$)`;\nconst START_ANCHOR = `(?:^|${SLASH_LITERAL})`;\nconst DOTS_SLASH = `${DOT_LITERAL}{1,2}${END_ANCHOR}`;\nconst NO_DOT = `(?!${DOT_LITERAL})`;\nconst NO_DOTS = `(?!${START_ANCHOR}${DOTS_SLASH})`;\nconst NO_DOT_SLASH = `(?!${DOT_LITERAL}{0,1}${END_ANCHOR})`;\nconst NO_DOTS_SLASH = `(?!${DOTS_SLASH})`;\nconst QMARK_NO_DOT = `[^.${SLASH_LITERAL}]`;\nconst STAR = `${QMARK}*?`;\n\nconst POSIX_CHARS = {\n  DOT_LITERAL,\n  PLUS_LITERAL,\n  QMARK_LITERAL,\n  SLASH_LITERAL,\n  ONE_CHAR,\n  QMARK,\n  END_ANCHOR,\n  DOTS_SLASH,\n  NO_DOT,\n  NO_DOTS,\n  NO_DOT_SLASH,\n  NO_DOTS_SLASH,\n  QMARK_NO_DOT,\n  STAR,\n  START_ANCHOR\n};\n\n/**\n * Windows glob regex\n */\n\nconst WINDOWS_CHARS = {\n  ...POSIX_CHARS,\n\n  SLASH_LITERAL: `[${WIN_SLASH}]`,\n  QMARK: WIN_NO_SLASH,\n  STAR: `${WIN_NO_SLASH}*?`,\n  DOTS_SLASH: `${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$)`,\n  NO_DOT: `(?!${DOT_LITERAL})`,\n  NO_DOTS: `(?!(?:^|[${WIN_SLASH}])${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$))`,\n  NO_DOT_SLASH: `(?!${DOT_LITERAL}{0,1}(?:[${WIN_SLASH}]|$))`,\n  NO_DOTS_SLASH: `(?!${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$))`,\n  QMARK_NO_DOT: `[^.${WIN_SLASH}]`,\n  START_ANCHOR: `(?:^|[${WIN_SLASH}])`,\n  END_ANCHOR: `(?:[${WIN_SLASH}]|$)`\n};\n\n/**\n * POSIX Bracket Regex\n */\n\nconst POSIX_REGEX_SOURCE = {\n  alnum: 'a-zA-Z0-9',\n  alpha: 'a-zA-Z',\n  ascii: '\\\\x00-\\\\x7F',\n  blank: ' \\\\t',\n  cntrl: '\\\\x00-\\\\x1F\\\\x7F',\n  digit: '0-9',\n  graph: '\\\\x21-\\\\x7E',\n  lower: 'a-z',\n  print: '\\\\x20-\\\\x7E ',\n  punct: '\\\\-!\"#$%&\\'()\\\\*+,./:;<=>?@[\\\\]^_`{|}~',\n  space: ' \\\\t\\\\r\\\\n\\\\v\\\\f',\n  upper: 'A-Z',\n  word: 'A-Za-z0-9_',\n  xdigit: 'A-Fa-f0-9'\n};\n\nvar constants$1 = {\n  MAX_LENGTH: 1024 * 64,\n  POSIX_REGEX_SOURCE,\n\n  // regular expressions\n  REGEX_BACKSLASH: /\\\\(?![*+?^${}(|)[\\]])/g,\n  REGEX_NON_SPECIAL_CHARS: /^[^@![\\].,$*+?^{}()|\\\\/]+/,\n  REGEX_SPECIAL_CHARS: /[-*+?.^${}(|)[\\]]/,\n  REGEX_SPECIAL_CHARS_BACKREF: /(\\\\?)((\\W)(\\3*))/g,\n  REGEX_SPECIAL_CHARS_GLOBAL: /([-*+?.^${}(|)[\\]])/g,\n  REGEX_REMOVE_BACKSLASH: /(?:\\[.*?[^\\\\]\\]|\\\\(?=.))/g,\n\n  // Replace globs with equivalent patterns to reduce parsing time.\n  REPLACEMENTS: {\n    '***': '*',\n    '**/**': '**',\n    '**/**/**': '**'\n  },\n\n  // Digits\n  CHAR_0: 48, /* 0 */\n  CHAR_9: 57, /* 9 */\n\n  // Alphabet chars.\n  CHAR_UPPERCASE_A: 65, /* A */\n  CHAR_LOWERCASE_A: 97, /* a */\n  CHAR_UPPERCASE_Z: 90, /* Z */\n  CHAR_LOWERCASE_Z: 122, /* z */\n\n  CHAR_LEFT_PARENTHESES: 40, /* ( */\n  CHAR_RIGHT_PARENTHESES: 41, /* ) */\n\n  CHAR_ASTERISK: 42, /* * */\n\n  // Non-alphabetic chars.\n  CHAR_AMPERSAND: 38, /* & */\n  CHAR_AT: 64, /* @ */\n  CHAR_BACKWARD_SLASH: 92, /* \\ */\n  CHAR_CARRIAGE_RETURN: 13, /* \\r */\n  CHAR_CIRCUMFLEX_ACCENT: 94, /* ^ */\n  CHAR_COLON: 58, /* : */\n  CHAR_COMMA: 44, /* , */\n  CHAR_DOT: 46, /* . */\n  CHAR_DOUBLE_QUOTE: 34, /* \" */\n  CHAR_EQUAL: 61, /* = */\n  CHAR_EXCLAMATION_MARK: 33, /* ! */\n  CHAR_FORM_FEED: 12, /* \\f */\n  CHAR_FORWARD_SLASH: 47, /* / */\n  CHAR_GRAVE_ACCENT: 96, /* ` */\n  CHAR_HASH: 35, /* # */\n  CHAR_HYPHEN_MINUS: 45, /* - */\n  CHAR_LEFT_ANGLE_BRACKET: 60, /* < */\n  CHAR_LEFT_CURLY_BRACE: 123, /* { */\n  CHAR_LEFT_SQUARE_BRACKET: 91, /* [ */\n  CHAR_LINE_FEED: 10, /* \\n */\n  CHAR_NO_BREAK_SPACE: 160, /* \\u00A0 */\n  CHAR_PERCENT: 37, /* % */\n  CHAR_PLUS: 43, /* + */\n  CHAR_QUESTION_MARK: 63, /* ? */\n  CHAR_RIGHT_ANGLE_BRACKET: 62, /* > */\n  CHAR_RIGHT_CURLY_BRACE: 125, /* } */\n  CHAR_RIGHT_SQUARE_BRACKET: 93, /* ] */\n  CHAR_SEMICOLON: 59, /* ; */\n  CHAR_SINGLE_QUOTE: 39, /* ' */\n  CHAR_SPACE: 32, /*   */\n  CHAR_TAB: 9, /* \\t */\n  CHAR_UNDERSCORE: 95, /* _ */\n  CHAR_VERTICAL_LINE: 124, /* | */\n  CHAR_ZERO_WIDTH_NOBREAK_SPACE: 65279, /* \\uFEFF */\n\n  SEP: path.sep,\n\n  /**\n   * Create EXTGLOB_CHARS\n   */\n\n  extglobChars(chars) {\n    return {\n      '!': { type: 'negate', open: '(?:(?!(?:', close: `))${chars.STAR})` },\n      '?': { type: 'qmark', open: '(?:', close: ')?' },\n      '+': { type: 'plus', open: '(?:', close: ')+' },\n      '*': { type: 'star', open: '(?:', close: ')*' },\n      '@': { type: 'at', open: '(?:', close: ')' }\n    };\n  },\n\n  /**\n   * Create GLOB_CHARS\n   */\n\n  globChars(win32) {\n    return win32 === true ? WINDOWS_CHARS : POSIX_CHARS;\n  }\n};\n\nvar utils$1 = createCommonjsModule(function (module, exports) {\n\n\nconst win32 = process.platform === 'win32';\nconst {\n  REGEX_BACKSLASH,\n  REGEX_REMOVE_BACKSLASH,\n  REGEX_SPECIAL_CHARS,\n  REGEX_SPECIAL_CHARS_GLOBAL\n} = constants$1;\n\nexports.isObject = val => val !== null && typeof val === 'object' && !Array.isArray(val);\nexports.hasRegexChars = str => REGEX_SPECIAL_CHARS.test(str);\nexports.isRegexChar = str => str.length === 1 && exports.hasRegexChars(str);\nexports.escapeRegex = str => str.replace(REGEX_SPECIAL_CHARS_GLOBAL, '\\\\$1');\nexports.toPosixSlashes = str => str.replace(REGEX_BACKSLASH, '/');\n\nexports.removeBackslashes = str => {\n  return str.replace(REGEX_REMOVE_BACKSLASH, match => {\n    return match === '\\\\' ? '' : match;\n  });\n};\n\nexports.supportsLookbehinds = () => {\n  const segs = process.version.slice(1).split('.').map(Number);\n  if (segs.length === 3 && segs[0] >= 9 || (segs[0] === 8 && segs[1] >= 10)) {\n    return true;\n  }\n  return false;\n};\n\nexports.isWindows = options => {\n  if (options && typeof options.windows === 'boolean') {\n    return options.windows;\n  }\n  return win32 === true || path.sep === '\\\\';\n};\n\nexports.escapeLast = (input, char, lastIdx) => {\n  const idx = input.lastIndexOf(char, lastIdx);\n  if (idx === -1) return input;\n  if (input[idx - 1] === '\\\\') return exports.escapeLast(input, char, idx - 1);\n  return `${input.slice(0, idx)}\\\\${input.slice(idx)}`;\n};\n\nexports.removePrefix = (input, state = {}) => {\n  let output = input;\n  if (output.startsWith('./')) {\n    output = output.slice(2);\n    state.prefix = './';\n  }\n  return output;\n};\n\nexports.wrapOutput = (input, state = {}, options = {}) => {\n  const prepend = options.contains ? '' : '^';\n  const append = options.contains ? '' : '$';\n\n  let output = `${prepend}(?:${input})${append}`;\n  if (state.negated === true) {\n    output = `(?:^(?!${output}).*$)`;\n  }\n  return output;\n};\n});\n\nconst {\n  CHAR_ASTERISK,             /* * */\n  CHAR_AT,                   /* @ */\n  CHAR_BACKWARD_SLASH,       /* \\ */\n  CHAR_COMMA: CHAR_COMMA$1,                /* , */\n  CHAR_DOT: CHAR_DOT$1,                  /* . */\n  CHAR_EXCLAMATION_MARK,     /* ! */\n  CHAR_FORWARD_SLASH,        /* / */\n  CHAR_LEFT_CURLY_BRACE: CHAR_LEFT_CURLY_BRACE$1,     /* { */\n  CHAR_LEFT_PARENTHESES: CHAR_LEFT_PARENTHESES$1,     /* ( */\n  CHAR_LEFT_SQUARE_BRACKET: CHAR_LEFT_SQUARE_BRACKET$1,  /* [ */\n  CHAR_PLUS,                 /* + */\n  CHAR_QUESTION_MARK,        /* ? */\n  CHAR_RIGHT_CURLY_BRACE: CHAR_RIGHT_CURLY_BRACE$1,    /* } */\n  CHAR_RIGHT_PARENTHESES: CHAR_RIGHT_PARENTHESES$1,    /* ) */\n  CHAR_RIGHT_SQUARE_BRACKET: CHAR_RIGHT_SQUARE_BRACKET$1  /* ] */\n} = constants$1;\n\nconst isPathSeparator = code => {\n  return code === CHAR_FORWARD_SLASH || code === CHAR_BACKWARD_SLASH;\n};\n\nconst depth = token => {\n  if (token.isPrefix !== true) {\n    token.depth = token.isGlobstar ? Infinity : 1;\n  }\n};\n\n/**\n * Quickly scans a glob pattern and returns an object with a handful of\n * useful properties, like `isGlob`, `path` (the leading non-glob, if it exists),\n * `glob` (the actual pattern), and `negated` (true if the path starts with `!`).\n *\n * ```js\n * const pm = require('picomatch');\n * console.log(pm.scan('foo/bar/*.js'));\n * { isGlob: true, input: 'foo/bar/*.js', base: 'foo/bar', glob: '*.js' }\n * ```\n * @param {String} `str`\n * @param {Object} `options`\n * @return {Object} Returns an object with tokens and regex source string.\n * @api public\n */\n\nconst scan = (input, options) => {\n  const opts = options || {};\n\n  const length = input.length - 1;\n  const scanToEnd = opts.parts === true || opts.scanToEnd === true;\n  const slashes = [];\n  const tokens = [];\n  const parts = [];\n\n  let str = input;\n  let index = -1;\n  let start = 0;\n  let lastIndex = 0;\n  let isBrace = false;\n  let isBracket = false;\n  let isGlob = false;\n  let isExtglob = false;\n  let isGlobstar = false;\n  let braceEscaped = false;\n  let backslashes = false;\n  let negated = false;\n  let finished = false;\n  let braces = 0;\n  let prev;\n  let code;\n  let token = { value: '', depth: 0, isGlob: false };\n\n  const eos = () => index >= length;\n  const peek = () => str.charCodeAt(index + 1);\n  const advance = () => {\n    prev = code;\n    return str.charCodeAt(++index);\n  };\n\n  while (index < length) {\n    code = advance();\n    let next;\n\n    if (code === CHAR_BACKWARD_SLASH) {\n      backslashes = token.backslashes = true;\n      code = advance();\n\n      if (code === CHAR_LEFT_CURLY_BRACE$1) {\n        braceEscaped = true;\n      }\n      continue;\n    }\n\n    if (braceEscaped === true || code === CHAR_LEFT_CURLY_BRACE$1) {\n      braces++;\n\n      while (eos() !== true && (code = advance())) {\n        if (code === CHAR_BACKWARD_SLASH) {\n          backslashes = token.backslashes = true;\n          advance();\n          continue;\n        }\n\n        if (code === CHAR_LEFT_CURLY_BRACE$1) {\n          braces++;\n          continue;\n        }\n\n        if (braceEscaped !== true && code === CHAR_DOT$1 && (code = advance()) === CHAR_DOT$1) {\n          isBrace = token.isBrace = true;\n          isGlob = token.isGlob = true;\n          finished = true;\n\n          if (scanToEnd === true) {\n            continue;\n          }\n\n          break;\n        }\n\n        if (braceEscaped !== true && code === CHAR_COMMA$1) {\n          isBrace = token.isBrace = true;\n          isGlob = token.isGlob = true;\n          finished = true;\n\n          if (scanToEnd === true) {\n            continue;\n          }\n\n          break;\n        }\n\n        if (code === CHAR_RIGHT_CURLY_BRACE$1) {\n          braces--;\n\n          if (braces === 0) {\n            braceEscaped = false;\n            isBrace = token.isBrace = true;\n            finished = true;\n            break;\n          }\n        }\n      }\n\n      if (scanToEnd === true) {\n        continue;\n      }\n\n      break;\n    }\n\n    if (code === CHAR_FORWARD_SLASH) {\n      slashes.push(index);\n      tokens.push(token);\n      token = { value: '', depth: 0, isGlob: false };\n\n      if (finished === true) continue;\n      if (prev === CHAR_DOT$1 && index === (start + 1)) {\n        start += 2;\n        continue;\n      }\n\n      lastIndex = index + 1;\n      continue;\n    }\n\n    if (opts.noext !== true) {\n      const isExtglobChar = code === CHAR_PLUS\n        || code === CHAR_AT\n        || code === CHAR_ASTERISK\n        || code === CHAR_QUESTION_MARK\n        || code === CHAR_EXCLAMATION_MARK;\n\n      if (isExtglobChar === true && peek() === CHAR_LEFT_PARENTHESES$1) {\n        isGlob = token.isGlob = true;\n        isExtglob = token.isExtglob = true;\n        finished = true;\n\n        if (scanToEnd === true) {\n          while (eos() !== true && (code = advance())) {\n            if (code === CHAR_BACKWARD_SLASH) {\n              backslashes = token.backslashes = true;\n              code = advance();\n              continue;\n            }\n\n            if (code === CHAR_RIGHT_PARENTHESES$1) {\n              isGlob = token.isGlob = true;\n              finished = true;\n              break;\n            }\n          }\n          continue;\n        }\n        break;\n      }\n    }\n\n    if (code === CHAR_ASTERISK) {\n      if (prev === CHAR_ASTERISK) isGlobstar = token.isGlobstar = true;\n      isGlob = token.isGlob = true;\n      finished = true;\n\n      if (scanToEnd === true) {\n        continue;\n      }\n      break;\n    }\n\n    if (code === CHAR_QUESTION_MARK) {\n      isGlob = token.isGlob = true;\n      finished = true;\n\n      if (scanToEnd === true) {\n        continue;\n      }\n      break;\n    }\n\n    if (code === CHAR_LEFT_SQUARE_BRACKET$1) {\n      while (eos() !== true && (next = advance())) {\n        if (next === CHAR_BACKWARD_SLASH) {\n          backslashes = token.backslashes = true;\n          advance();\n          continue;\n        }\n\n        if (next === CHAR_RIGHT_SQUARE_BRACKET$1) {\n          isBracket = token.isBracket = true;\n          isGlob = token.isGlob = true;\n          finished = true;\n\n          if (scanToEnd === true) {\n            continue;\n          }\n          break;\n        }\n      }\n    }\n\n    if (opts.nonegate !== true && code === CHAR_EXCLAMATION_MARK && index === start) {\n      negated = token.negated = true;\n      start++;\n      continue;\n    }\n\n    if (opts.noparen !== true && code === CHAR_LEFT_PARENTHESES$1) {\n      isGlob = token.isGlob = true;\n\n      if (scanToEnd === true) {\n        while (eos() !== true && (code = advance())) {\n          if (code === CHAR_LEFT_PARENTHESES$1) {\n            backslashes = token.backslashes = true;\n            code = advance();\n            continue;\n          }\n\n          if (code === CHAR_RIGHT_PARENTHESES$1) {\n            finished = true;\n            break;\n          }\n        }\n        continue;\n      }\n      break;\n    }\n\n    if (isGlob === true) {\n      finished = true;\n\n      if (scanToEnd === true) {\n        continue;\n      }\n\n      break;\n    }\n  }\n\n  if (opts.noext === true) {\n    isExtglob = false;\n    isGlob = false;\n  }\n\n  let base = str;\n  let prefix = '';\n  let glob = '';\n\n  if (start > 0) {\n    prefix = str.slice(0, start);\n    str = str.slice(start);\n    lastIndex -= start;\n  }\n\n  if (base && isGlob === true && lastIndex > 0) {\n    base = str.slice(0, lastIndex);\n    glob = str.slice(lastIndex);\n  } else if (isGlob === true) {\n    base = '';\n    glob = str;\n  } else {\n    base = str;\n  }\n\n  if (base && base !== '' && base !== '/' && base !== str) {\n    if (isPathSeparator(base.charCodeAt(base.length - 1))) {\n      base = base.slice(0, -1);\n    }\n  }\n\n  if (opts.unescape === true) {\n    if (glob) glob = utils$1.removeBackslashes(glob);\n\n    if (base && backslashes === true) {\n      base = utils$1.removeBackslashes(base);\n    }\n  }\n\n  const state = {\n    prefix,\n    input,\n    start,\n    base,\n    glob,\n    isBrace,\n    isBracket,\n    isGlob,\n    isExtglob,\n    isGlobstar,\n    negated\n  };\n\n  if (opts.tokens === true) {\n    state.maxDepth = 0;\n    if (!isPathSeparator(code)) {\n      tokens.push(token);\n    }\n    state.tokens = tokens;\n  }\n\n  if (opts.parts === true || opts.tokens === true) {\n    let prevIndex;\n\n    for (let idx = 0; idx < slashes.length; idx++) {\n      const n = prevIndex ? prevIndex + 1 : start;\n      const i = slashes[idx];\n      const value = input.slice(n, i);\n      if (opts.tokens) {\n        if (idx === 0 && start !== 0) {\n          tokens[idx].isPrefix = true;\n          tokens[idx].value = prefix;\n        } else {\n          tokens[idx].value = value;\n        }\n        depth(tokens[idx]);\n        state.maxDepth += tokens[idx].depth;\n      }\n      if (idx !== 0 || value !== '') {\n        parts.push(value);\n      }\n      prevIndex = i;\n    }\n\n    if (prevIndex && prevIndex + 1 < input.length) {\n      const value = input.slice(prevIndex + 1);\n      parts.push(value);\n\n      if (opts.tokens) {\n        tokens[tokens.length - 1].value = value;\n        depth(tokens[tokens.length - 1]);\n        state.maxDepth += tokens[tokens.length - 1].depth;\n      }\n    }\n\n    state.slashes = slashes;\n    state.parts = parts;\n  }\n\n  return state;\n};\n\nvar scan_1 = scan;\n\n/**\n * Constants\n */\n\nconst {\n  MAX_LENGTH: MAX_LENGTH$1,\n  POSIX_REGEX_SOURCE: POSIX_REGEX_SOURCE$1,\n  REGEX_NON_SPECIAL_CHARS,\n  REGEX_SPECIAL_CHARS_BACKREF,\n  REPLACEMENTS\n} = constants$1;\n\n/**\n * Helpers\n */\n\nconst expandRange = (args, options) => {\n  if (typeof options.expandRange === 'function') {\n    return options.expandRange(...args, options);\n  }\n\n  args.sort();\n  const value = `[${args.join('-')}]`;\n\n  return value;\n};\n\n/**\n * Create the message for a syntax error\n */\n\nconst syntaxError = (type, char) => {\n  return `Missing ${type}: \"${char}\" - use \"\\\\\\\\${char}\" to match literal characters`;\n};\n\n/**\n * Parse the given input string.\n * @param {String} input\n * @param {Object} options\n * @return {Object}\n */\n\nconst parse$1 = (input, options) => {\n  if (typeof input !== 'string') {\n    throw new TypeError('Expected a string');\n  }\n\n  input = REPLACEMENTS[input] || input;\n\n  const opts = { ...options };\n  const max = typeof opts.maxLength === 'number' ? Math.min(MAX_LENGTH$1, opts.maxLength) : MAX_LENGTH$1;\n\n  let len = input.length;\n  if (len > max) {\n    throw new SyntaxError(`Input length: ${len}, exceeds maximum allowed length: ${max}`);\n  }\n\n  const bos = { type: 'bos', value: '', output: opts.prepend || '' };\n  const tokens = [bos];\n\n  const capture = opts.capture ? '' : '?:';\n  const win32 = utils$1.isWindows(options);\n\n  // create constants based on platform, for windows or posix\n  const PLATFORM_CHARS = constants$1.globChars(win32);\n  const EXTGLOB_CHARS = constants$1.extglobChars(PLATFORM_CHARS);\n\n  const {\n    DOT_LITERAL,\n    PLUS_LITERAL,\n    SLASH_LITERAL,\n    ONE_CHAR,\n    DOTS_SLASH,\n    NO_DOT,\n    NO_DOT_SLASH,\n    NO_DOTS_SLASH,\n    QMARK,\n    QMARK_NO_DOT,\n    STAR,\n    START_ANCHOR\n  } = PLATFORM_CHARS;\n\n  const globstar = (opts) => {\n    return `(${capture}(?:(?!${START_ANCHOR}${opts.dot ? DOTS_SLASH : DOT_LITERAL}).)*?)`;\n  };\n\n  const nodot = opts.dot ? '' : NO_DOT;\n  const qmarkNoDot = opts.dot ? QMARK : QMARK_NO_DOT;\n  let star = opts.bash === true ? globstar(opts) : STAR;\n\n  if (opts.capture) {\n    star = `(${star})`;\n  }\n\n  // minimatch options support\n  if (typeof opts.noext === 'boolean') {\n    opts.noextglob = opts.noext;\n  }\n\n  const state = {\n    input,\n    index: -1,\n    start: 0,\n    dot: opts.dot === true,\n    consumed: '',\n    output: '',\n    prefix: '',\n    backtrack: false,\n    negated: false,\n    brackets: 0,\n    braces: 0,\n    parens: 0,\n    quotes: 0,\n    globstar: false,\n    tokens\n  };\n\n  input = utils$1.removePrefix(input, state);\n  len = input.length;\n\n  const extglobs = [];\n  const braces = [];\n  const stack = [];\n  let prev = bos;\n  let value;\n\n  /**\n   * Tokenizing helpers\n   */\n\n  const eos = () => state.index === len - 1;\n  const peek = state.peek = (n = 1) => input[state.index + n];\n  const advance = state.advance = () => input[++state.index];\n  const remaining = () => input.slice(state.index + 1);\n  const consume = (value = '', num = 0) => {\n    state.consumed += value;\n    state.index += num;\n  };\n  const append = token => {\n    state.output += token.output != null ? token.output : token.value;\n    consume(token.value);\n  };\n\n  const negate = () => {\n    let count = 1;\n\n    while (peek() === '!' && (peek(2) !== '(' || peek(3) === '?')) {\n      advance();\n      state.start++;\n      count++;\n    }\n\n    if (count % 2 === 0) {\n      return false;\n    }\n\n    state.negated = true;\n    state.start++;\n    return true;\n  };\n\n  const increment = type => {\n    state[type]++;\n    stack.push(type);\n  };\n\n  const decrement = type => {\n    state[type]--;\n    stack.pop();\n  };\n\n  /**\n   * Push tokens onto the tokens array. This helper speeds up\n   * tokenizing by 1) helping us avoid backtracking as much as possible,\n   * and 2) helping us avoid creating extra tokens when consecutive\n   * characters are plain text. This improves performance and simplifies\n   * lookbehinds.\n   */\n\n  const push = tok => {\n    if (prev.type === 'globstar') {\n      const isBrace = state.braces > 0 && (tok.type === 'comma' || tok.type === 'brace');\n      const isExtglob = tok.extglob === true || (extglobs.length && (tok.type === 'pipe' || tok.type === 'paren'));\n\n      if (tok.type !== 'slash' && tok.type !== 'paren' && !isBrace && !isExtglob) {\n        state.output = state.output.slice(0, -prev.output.length);\n        prev.type = 'star';\n        prev.value = '*';\n        prev.output = star;\n        state.output += prev.output;\n      }\n    }\n\n    if (extglobs.length && tok.type !== 'paren' && !EXTGLOB_CHARS[tok.value]) {\n      extglobs[extglobs.length - 1].inner += tok.value;\n    }\n\n    if (tok.value || tok.output) append(tok);\n    if (prev && prev.type === 'text' && tok.type === 'text') {\n      prev.value += tok.value;\n      prev.output = (prev.output || '') + tok.value;\n      return;\n    }\n\n    tok.prev = prev;\n    tokens.push(tok);\n    prev = tok;\n  };\n\n  const extglobOpen = (type, value) => {\n    const token = { ...EXTGLOB_CHARS[value], conditions: 1, inner: '' };\n\n    token.prev = prev;\n    token.parens = state.parens;\n    token.output = state.output;\n    const output = (opts.capture ? '(' : '') + token.open;\n\n    increment('parens');\n    push({ type, value, output: state.output ? '' : ONE_CHAR });\n    push({ type: 'paren', extglob: true, value: advance(), output });\n    extglobs.push(token);\n  };\n\n  const extglobClose = token => {\n    let output = token.close + (opts.capture ? ')' : '');\n\n    if (token.type === 'negate') {\n      let extglobStar = star;\n\n      if (token.inner && token.inner.length > 1 && token.inner.includes('/')) {\n        extglobStar = globstar(opts);\n      }\n\n      if (extglobStar !== star || eos() || /^\\)+$/.test(remaining())) {\n        output = token.close = `)$))${extglobStar}`;\n      }\n\n      if (token.prev.type === 'bos' && eos()) {\n        state.negatedExtglob = true;\n      }\n    }\n\n    push({ type: 'paren', extglob: true, value, output });\n    decrement('parens');\n  };\n\n  /**\n   * Fast paths\n   */\n\n  if (opts.fastpaths !== false && !/(^[*!]|[/()[\\]{}\"])/.test(input)) {\n    let backslashes = false;\n\n    let output = input.replace(REGEX_SPECIAL_CHARS_BACKREF, (m, esc, chars, first, rest, index) => {\n      if (first === '\\\\') {\n        backslashes = true;\n        return m;\n      }\n\n      if (first === '?') {\n        if (esc) {\n          return esc + first + (rest ? QMARK.repeat(rest.length) : '');\n        }\n        if (index === 0) {\n          return qmarkNoDot + (rest ? QMARK.repeat(rest.length) : '');\n        }\n        return QMARK.repeat(chars.length);\n      }\n\n      if (first === '.') {\n        return DOT_LITERAL.repeat(chars.length);\n      }\n\n      if (first === '*') {\n        if (esc) {\n          return esc + first + (rest ? star : '');\n        }\n        return star;\n      }\n      return esc ? m : `\\\\${m}`;\n    });\n\n    if (backslashes === true) {\n      if (opts.unescape === true) {\n        output = output.replace(/\\\\/g, '');\n      } else {\n        output = output.replace(/\\\\+/g, m => {\n          return m.length % 2 === 0 ? '\\\\\\\\' : (m ? '\\\\' : '');\n        });\n      }\n    }\n\n    if (output === input && opts.contains === true) {\n      state.output = input;\n      return state;\n    }\n\n    state.output = utils$1.wrapOutput(output, state, options);\n    return state;\n  }\n\n  /**\n   * Tokenize input until we reach end-of-string\n   */\n\n  while (!eos()) {\n    value = advance();\n\n    if (value === '\\u0000') {\n      continue;\n    }\n\n    /**\n     * Escaped characters\n     */\n\n    if (value === '\\\\') {\n      const next = peek();\n\n      if (next === '/' && opts.bash !== true) {\n        continue;\n      }\n\n      if (next === '.' || next === ';') {\n        continue;\n      }\n\n      if (!next) {\n        value += '\\\\';\n        push({ type: 'text', value });\n        continue;\n      }\n\n      // collapse slashes to reduce potential for exploits\n      const match = /^\\\\+/.exec(remaining());\n      let slashes = 0;\n\n      if (match && match[0].length > 2) {\n        slashes = match[0].length;\n        state.index += slashes;\n        if (slashes % 2 !== 0) {\n          value += '\\\\';\n        }\n      }\n\n      if (opts.unescape === true) {\n        value = advance() || '';\n      } else {\n        value += advance() || '';\n      }\n\n      if (state.brackets === 0) {\n        push({ type: 'text', value });\n        continue;\n      }\n    }\n\n    /**\n     * If we're inside a regex character class, continue\n     * until we reach the closing bracket.\n     */\n\n    if (state.brackets > 0 && (value !== ']' || prev.value === '[' || prev.value === '[^')) {\n      if (opts.posix !== false && value === ':') {\n        const inner = prev.value.slice(1);\n        if (inner.includes('[')) {\n          prev.posix = true;\n\n          if (inner.includes(':')) {\n            const idx = prev.value.lastIndexOf('[');\n            const pre = prev.value.slice(0, idx);\n            const rest = prev.value.slice(idx + 2);\n            const posix = POSIX_REGEX_SOURCE$1[rest];\n            if (posix) {\n              prev.value = pre + posix;\n              state.backtrack = true;\n              advance();\n\n              if (!bos.output && tokens.indexOf(prev) === 1) {\n                bos.output = ONE_CHAR;\n              }\n              continue;\n            }\n          }\n        }\n      }\n\n      if ((value === '[' && peek() !== ':') || (value === '-' && peek() === ']')) {\n        value = `\\\\${value}`;\n      }\n\n      if (value === ']' && (prev.value === '[' || prev.value === '[^')) {\n        value = `\\\\${value}`;\n      }\n\n      if (opts.posix === true && value === '!' && prev.value === '[') {\n        value = '^';\n      }\n\n      prev.value += value;\n      append({ value });\n      continue;\n    }\n\n    /**\n     * If we're inside a quoted string, continue\n     * until we reach the closing double quote.\n     */\n\n    if (state.quotes === 1 && value !== '\"') {\n      value = utils$1.escapeRegex(value);\n      prev.value += value;\n      append({ value });\n      continue;\n    }\n\n    /**\n     * Double quotes\n     */\n\n    if (value === '\"') {\n      state.quotes = state.quotes === 1 ? 0 : 1;\n      if (opts.keepQuotes === true) {\n        push({ type: 'text', value });\n      }\n      continue;\n    }\n\n    /**\n     * Parentheses\n     */\n\n    if (value === '(') {\n      increment('parens');\n      push({ type: 'paren', value });\n      continue;\n    }\n\n    if (value === ')') {\n      if (state.parens === 0 && opts.strictBrackets === true) {\n        throw new SyntaxError(syntaxError('opening', '('));\n      }\n\n      const extglob = extglobs[extglobs.length - 1];\n      if (extglob && state.parens === extglob.parens + 1) {\n        extglobClose(extglobs.pop());\n        continue;\n      }\n\n      push({ type: 'paren', value, output: state.parens ? ')' : '\\\\)' });\n      decrement('parens');\n      continue;\n    }\n\n    /**\n     * Square brackets\n     */\n\n    if (value === '[') {\n      if (opts.nobracket === true || !remaining().includes(']')) {\n        if (opts.nobracket !== true && opts.strictBrackets === true) {\n          throw new SyntaxError(syntaxError('closing', ']'));\n        }\n\n        value = `\\\\${value}`;\n      } else {\n        increment('brackets');\n      }\n\n      push({ type: 'bracket', value });\n      continue;\n    }\n\n    if (value === ']') {\n      if (opts.nobracket === true || (prev && prev.type === 'bracket' && prev.value.length === 1)) {\n        push({ type: 'text', value, output: `\\\\${value}` });\n        continue;\n      }\n\n      if (state.brackets === 0) {\n        if (opts.strictBrackets === true) {\n          throw new SyntaxError(syntaxError('opening', '['));\n        }\n\n        push({ type: 'text', value, output: `\\\\${value}` });\n        continue;\n      }\n\n      decrement('brackets');\n\n      const prevValue = prev.value.slice(1);\n      if (prev.posix !== true && prevValue[0] === '^' && !prevValue.includes('/')) {\n        value = `/${value}`;\n      }\n\n      prev.value += value;\n      append({ value });\n\n      // when literal brackets are explicitly disabled\n      // assume we should match with a regex character class\n      if (opts.literalBrackets === false || utils$1.hasRegexChars(prevValue)) {\n        continue;\n      }\n\n      const escaped = utils$1.escapeRegex(prev.value);\n      state.output = state.output.slice(0, -prev.value.length);\n\n      // when literal brackets are explicitly enabled\n      // assume we should escape the brackets to match literal characters\n      if (opts.literalBrackets === true) {\n        state.output += escaped;\n        prev.value = escaped;\n        continue;\n      }\n\n      // when the user specifies nothing, try to match both\n      prev.value = `(${capture}${escaped}|${prev.value})`;\n      state.output += prev.value;\n      continue;\n    }\n\n    /**\n     * Braces\n     */\n\n    if (value === '{' && opts.nobrace !== true) {\n      increment('braces');\n\n      const open = {\n        type: 'brace',\n        value,\n        output: '(',\n        outputIndex: state.output.length,\n        tokensIndex: state.tokens.length\n      };\n\n      braces.push(open);\n      push(open);\n      continue;\n    }\n\n    if (value === '}') {\n      const brace = braces[braces.length - 1];\n\n      if (opts.nobrace === true || !brace) {\n        push({ type: 'text', value, output: value });\n        continue;\n      }\n\n      let output = ')';\n\n      if (brace.dots === true) {\n        const arr = tokens.slice();\n        const range = [];\n\n        for (let i = arr.length - 1; i >= 0; i--) {\n          tokens.pop();\n          if (arr[i].type === 'brace') {\n            break;\n          }\n          if (arr[i].type !== 'dots') {\n            range.unshift(arr[i].value);\n          }\n        }\n\n        output = expandRange(range, opts);\n        state.backtrack = true;\n      }\n\n      if (brace.comma !== true && brace.dots !== true) {\n        const out = state.output.slice(0, brace.outputIndex);\n        const toks = state.tokens.slice(brace.tokensIndex);\n        brace.value = brace.output = '\\\\{';\n        value = output = '\\\\}';\n        state.output = out;\n        for (const t of toks) {\n          state.output += (t.output || t.value);\n        }\n      }\n\n      push({ type: 'brace', value, output });\n      decrement('braces');\n      braces.pop();\n      continue;\n    }\n\n    /**\n     * Pipes\n     */\n\n    if (value === '|') {\n      if (extglobs.length > 0) {\n        extglobs[extglobs.length - 1].conditions++;\n      }\n      push({ type: 'text', value });\n      continue;\n    }\n\n    /**\n     * Commas\n     */\n\n    if (value === ',') {\n      let output = value;\n\n      const brace = braces[braces.length - 1];\n      if (brace && stack[stack.length - 1] === 'braces') {\n        brace.comma = true;\n        output = '|';\n      }\n\n      push({ type: 'comma', value, output });\n      continue;\n    }\n\n    /**\n     * Slashes\n     */\n\n    if (value === '/') {\n      // if the beginning of the glob is \"./\", advance the start\n      // to the current index, and don't add the \"./\" characters\n      // to the state. This greatly simplifies lookbehinds when\n      // checking for BOS characters like \"!\" and \".\" (not \"./\")\n      if (prev.type === 'dot' && state.index === state.start + 1) {\n        state.start = state.index + 1;\n        state.consumed = '';\n        state.output = '';\n        tokens.pop();\n        prev = bos; // reset \"prev\" to the first token\n        continue;\n      }\n\n      push({ type: 'slash', value, output: SLASH_LITERAL });\n      continue;\n    }\n\n    /**\n     * Dots\n     */\n\n    if (value === '.') {\n      if (state.braces > 0 && prev.type === 'dot') {\n        if (prev.value === '.') prev.output = DOT_LITERAL;\n        const brace = braces[braces.length - 1];\n        prev.type = 'dots';\n        prev.output += value;\n        prev.value += value;\n        brace.dots = true;\n        continue;\n      }\n\n      if ((state.braces + state.parens) === 0 && prev.type !== 'bos' && prev.type !== 'slash') {\n        push({ type: 'text', value, output: DOT_LITERAL });\n        continue;\n      }\n\n      push({ type: 'dot', value, output: DOT_LITERAL });\n      continue;\n    }\n\n    /**\n     * Question marks\n     */\n\n    if (value === '?') {\n      const isGroup = prev && prev.value === '(';\n      if (!isGroup && opts.noextglob !== true && peek() === '(' && peek(2) !== '?') {\n        extglobOpen('qmark', value);\n        continue;\n      }\n\n      if (prev && prev.type === 'paren') {\n        const next = peek();\n        let output = value;\n\n        if (next === '<' && !utils$1.supportsLookbehinds()) {\n          throw new Error('Node.js v10 or higher is required for regex lookbehinds');\n        }\n\n        if ((prev.value === '(' && !/[!=<:]/.test(next)) || (next === '<' && !/<([!=]|\\w+>)/.test(remaining()))) {\n          output = `\\\\${value}`;\n        }\n\n        push({ type: 'text', value, output });\n        continue;\n      }\n\n      if (opts.dot !== true && (prev.type === 'slash' || prev.type === 'bos')) {\n        push({ type: 'qmark', value, output: QMARK_NO_DOT });\n        continue;\n      }\n\n      push({ type: 'qmark', value, output: QMARK });\n      continue;\n    }\n\n    /**\n     * Exclamation\n     */\n\n    if (value === '!') {\n      if (opts.noextglob !== true && peek() === '(') {\n        if (peek(2) !== '?' || !/[!=<:]/.test(peek(3))) {\n          extglobOpen('negate', value);\n          continue;\n        }\n      }\n\n      if (opts.nonegate !== true && state.index === 0) {\n        negate();\n        continue;\n      }\n    }\n\n    /**\n     * Plus\n     */\n\n    if (value === '+') {\n      if (opts.noextglob !== true && peek() === '(' && peek(2) !== '?') {\n        extglobOpen('plus', value);\n        continue;\n      }\n\n      if ((prev && prev.value === '(') || opts.regex === false) {\n        push({ type: 'plus', value, output: PLUS_LITERAL });\n        continue;\n      }\n\n      if ((prev && (prev.type === 'bracket' || prev.type === 'paren' || prev.type === 'brace')) || state.parens > 0) {\n        push({ type: 'plus', value });\n        continue;\n      }\n\n      push({ type: 'plus', value: PLUS_LITERAL });\n      continue;\n    }\n\n    /**\n     * Plain text\n     */\n\n    if (value === '@') {\n      if (opts.noextglob !== true && peek() === '(' && peek(2) !== '?') {\n        push({ type: 'at', extglob: true, value, output: '' });\n        continue;\n      }\n\n      push({ type: 'text', value });\n      continue;\n    }\n\n    /**\n     * Plain text\n     */\n\n    if (value !== '*') {\n      if (value === '$' || value === '^') {\n        value = `\\\\${value}`;\n      }\n\n      const match = REGEX_NON_SPECIAL_CHARS.exec(remaining());\n      if (match) {\n        value += match[0];\n        state.index += match[0].length;\n      }\n\n      push({ type: 'text', value });\n      continue;\n    }\n\n    /**\n     * Stars\n     */\n\n    if (prev && (prev.type === 'globstar' || prev.star === true)) {\n      prev.type = 'star';\n      prev.star = true;\n      prev.value += value;\n      prev.output = star;\n      state.backtrack = true;\n      state.globstar = true;\n      consume(value);\n      continue;\n    }\n\n    let rest = remaining();\n    if (opts.noextglob !== true && /^\\([^?]/.test(rest)) {\n      extglobOpen('star', value);\n      continue;\n    }\n\n    if (prev.type === 'star') {\n      if (opts.noglobstar === true) {\n        consume(value);\n        continue;\n      }\n\n      const prior = prev.prev;\n      const before = prior.prev;\n      const isStart = prior.type === 'slash' || prior.type === 'bos';\n      const afterStar = before && (before.type === 'star' || before.type === 'globstar');\n\n      if (opts.bash === true && (!isStart || (rest[0] && rest[0] !== '/'))) {\n        push({ type: 'star', value, output: '' });\n        continue;\n      }\n\n      const isBrace = state.braces > 0 && (prior.type === 'comma' || prior.type === 'brace');\n      const isExtglob = extglobs.length && (prior.type === 'pipe' || prior.type === 'paren');\n      if (!isStart && prior.type !== 'paren' && !isBrace && !isExtglob) {\n        push({ type: 'star', value, output: '' });\n        continue;\n      }\n\n      // strip consecutive `/**/`\n      while (rest.slice(0, 3) === '/**') {\n        const after = input[state.index + 4];\n        if (after && after !== '/') {\n          break;\n        }\n        rest = rest.slice(3);\n        consume('/**', 3);\n      }\n\n      if (prior.type === 'bos' && eos()) {\n        prev.type = 'globstar';\n        prev.value += value;\n        prev.output = globstar(opts);\n        state.output = prev.output;\n        state.globstar = true;\n        consume(value);\n        continue;\n      }\n\n      if (prior.type === 'slash' && prior.prev.type !== 'bos' && !afterStar && eos()) {\n        state.output = state.output.slice(0, -(prior.output + prev.output).length);\n        prior.output = `(?:${prior.output}`;\n\n        prev.type = 'globstar';\n        prev.output = globstar(opts) + (opts.strictSlashes ? ')' : '|$)');\n        prev.value += value;\n        state.globstar = true;\n        state.output += prior.output + prev.output;\n        consume(value);\n        continue;\n      }\n\n      if (prior.type === 'slash' && prior.prev.type !== 'bos' && rest[0] === '/') {\n        const end = rest[1] !== void 0 ? '|$' : '';\n\n        state.output = state.output.slice(0, -(prior.output + prev.output).length);\n        prior.output = `(?:${prior.output}`;\n\n        prev.type = 'globstar';\n        prev.output = `${globstar(opts)}${SLASH_LITERAL}|${SLASH_LITERAL}${end})`;\n        prev.value += value;\n\n        state.output += prior.output + prev.output;\n        state.globstar = true;\n\n        consume(value + advance());\n\n        push({ type: 'slash', value: '/', output: '' });\n        continue;\n      }\n\n      if (prior.type === 'bos' && rest[0] === '/') {\n        prev.type = 'globstar';\n        prev.value += value;\n        prev.output = `(?:^|${SLASH_LITERAL}|${globstar(opts)}${SLASH_LITERAL})`;\n        state.output = prev.output;\n        state.globstar = true;\n        consume(value + advance());\n        push({ type: 'slash', value: '/', output: '' });\n        continue;\n      }\n\n      // remove single star from output\n      state.output = state.output.slice(0, -prev.output.length);\n\n      // reset previous token to globstar\n      prev.type = 'globstar';\n      prev.output = globstar(opts);\n      prev.value += value;\n\n      // reset output with globstar\n      state.output += prev.output;\n      state.globstar = true;\n      consume(value);\n      continue;\n    }\n\n    const token = { type: 'star', value, output: star };\n\n    if (opts.bash === true) {\n      token.output = '.*?';\n      if (prev.type === 'bos' || prev.type === 'slash') {\n        token.output = nodot + token.output;\n      }\n      push(token);\n      continue;\n    }\n\n    if (prev && (prev.type === 'bracket' || prev.type === 'paren') && opts.regex === true) {\n      token.output = value;\n      push(token);\n      continue;\n    }\n\n    if (state.index === state.start || prev.type === 'slash' || prev.type === 'dot') {\n      if (prev.type === 'dot') {\n        state.output += NO_DOT_SLASH;\n        prev.output += NO_DOT_SLASH;\n\n      } else if (opts.dot === true) {\n        state.output += NO_DOTS_SLASH;\n        prev.output += NO_DOTS_SLASH;\n\n      } else {\n        state.output += nodot;\n        prev.output += nodot;\n      }\n\n      if (peek() !== '*') {\n        state.output += ONE_CHAR;\n        prev.output += ONE_CHAR;\n      }\n    }\n\n    push(token);\n  }\n\n  while (state.brackets > 0) {\n    if (opts.strictBrackets === true) throw new SyntaxError(syntaxError('closing', ']'));\n    state.output = utils$1.escapeLast(state.output, '[');\n    decrement('brackets');\n  }\n\n  while (state.parens > 0) {\n    if (opts.strictBrackets === true) throw new SyntaxError(syntaxError('closing', ')'));\n    state.output = utils$1.escapeLast(state.output, '(');\n    decrement('parens');\n  }\n\n  while (state.braces > 0) {\n    if (opts.strictBrackets === true) throw new SyntaxError(syntaxError('closing', '}'));\n    state.output = utils$1.escapeLast(state.output, '{');\n    decrement('braces');\n  }\n\n  if (opts.strictSlashes !== true && (prev.type === 'star' || prev.type === 'bracket')) {\n    push({ type: 'maybe_slash', value: '', output: `${SLASH_LITERAL}?` });\n  }\n\n  // rebuild the output if we had to backtrack at any point\n  if (state.backtrack === true) {\n    state.output = '';\n\n    for (const token of state.tokens) {\n      state.output += token.output != null ? token.output : token.value;\n\n      if (token.suffix) {\n        state.output += token.suffix;\n      }\n    }\n  }\n\n  return state;\n};\n\n/**\n * Fast paths for creating regular expressions for common glob patterns.\n * This can significantly speed up processing and has very little downside\n * impact when none of the fast paths match.\n */\n\nparse$1.fastpaths = (input, options) => {\n  const opts = { ...options };\n  const max = typeof opts.maxLength === 'number' ? Math.min(MAX_LENGTH$1, opts.maxLength) : MAX_LENGTH$1;\n  const len = input.length;\n  if (len > max) {\n    throw new SyntaxError(`Input length: ${len}, exceeds maximum allowed length: ${max}`);\n  }\n\n  input = REPLACEMENTS[input] || input;\n  const win32 = utils$1.isWindows(options);\n\n  // create constants based on platform, for windows or posix\n  const {\n    DOT_LITERAL,\n    SLASH_LITERAL,\n    ONE_CHAR,\n    DOTS_SLASH,\n    NO_DOT,\n    NO_DOTS,\n    NO_DOTS_SLASH,\n    STAR,\n    START_ANCHOR\n  } = constants$1.globChars(win32);\n\n  const nodot = opts.dot ? NO_DOTS : NO_DOT;\n  const slashDot = opts.dot ? NO_DOTS_SLASH : NO_DOT;\n  const capture = opts.capture ? '' : '?:';\n  const state = { negated: false, prefix: '' };\n  let star = opts.bash === true ? '.*?' : STAR;\n\n  if (opts.capture) {\n    star = `(${star})`;\n  }\n\n  const globstar = (opts) => {\n    if (opts.noglobstar === true) return star;\n    return `(${capture}(?:(?!${START_ANCHOR}${opts.dot ? DOTS_SLASH : DOT_LITERAL}).)*?)`;\n  };\n\n  const create = str => {\n    switch (str) {\n      case '*':\n        return `${nodot}${ONE_CHAR}${star}`;\n\n      case '.*':\n        return `${DOT_LITERAL}${ONE_CHAR}${star}`;\n\n      case '*.*':\n        return `${nodot}${star}${DOT_LITERAL}${ONE_CHAR}${star}`;\n\n      case '*/*':\n        return `${nodot}${star}${SLASH_LITERAL}${ONE_CHAR}${slashDot}${star}`;\n\n      case '**':\n        return nodot + globstar(opts);\n\n      case '**/*':\n        return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${slashDot}${ONE_CHAR}${star}`;\n\n      case '**/*.*':\n        return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${slashDot}${star}${DOT_LITERAL}${ONE_CHAR}${star}`;\n\n      case '**/.*':\n        return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${DOT_LITERAL}${ONE_CHAR}${star}`;\n\n      default: {\n        const match = /^(.*?)\\.(\\w+)$/.exec(str);\n        if (!match) return;\n\n        const source = create(match[1]);\n        if (!source) return;\n\n        return source + DOT_LITERAL + match[2];\n      }\n    }\n  };\n\n  const output = utils$1.removePrefix(input, state);\n  let source = create(output);\n\n  if (source && opts.strictSlashes !== true) {\n    source += `${SLASH_LITERAL}?`;\n  }\n\n  return source;\n};\n\nvar parse_1$1 = parse$1;\n\nconst isObject$1 = val => val && typeof val === 'object' && !Array.isArray(val);\n\n/**\n * Creates a matcher function from one or more glob patterns. The\n * returned function takes a string to match as its first argument,\n * and returns true if the string is a match. The returned matcher\n * function also takes a boolean as the second argument that, when true,\n * returns an object with additional information.\n *\n * ```js\n * const picomatch = require('picomatch');\n * // picomatch(glob[, options]);\n *\n * const isMatch = picomatch('*.!(*a)');\n * console.log(isMatch('a.a')); //=> false\n * console.log(isMatch('a.b')); //=> true\n * ```\n * @name picomatch\n * @param {String|Array} `globs` One or more glob patterns.\n * @param {Object=} `options`\n * @return {Function=} Returns a matcher function.\n * @api public\n */\n\nconst picomatch = (glob, options, returnState = false) => {\n  if (Array.isArray(glob)) {\n    const fns = glob.map(input => picomatch(input, options, returnState));\n    const arrayMatcher = str => {\n      for (const isMatch of fns) {\n        const state = isMatch(str);\n        if (state) return state;\n      }\n      return false;\n    };\n    return arrayMatcher;\n  }\n\n  const isState = isObject$1(glob) && glob.tokens && glob.input;\n\n  if (glob === '' || (typeof glob !== 'string' && !isState)) {\n    throw new TypeError('Expected pattern to be a non-empty string');\n  }\n\n  const opts = options || {};\n  const posix = utils$1.isWindows(options);\n  const regex = isState\n    ? picomatch.compileRe(glob, options)\n    : picomatch.makeRe(glob, options, false, true);\n\n  const state = regex.state;\n  delete regex.state;\n\n  let isIgnored = () => false;\n  if (opts.ignore) {\n    const ignoreOpts = { ...options, ignore: null, onMatch: null, onResult: null };\n    isIgnored = picomatch(opts.ignore, ignoreOpts, returnState);\n  }\n\n  const matcher = (input, returnObject = false) => {\n    const { isMatch, match, output } = picomatch.test(input, regex, options, { glob, posix });\n    const result = { glob, state, regex, posix, input, output, match, isMatch };\n\n    if (typeof opts.onResult === 'function') {\n      opts.onResult(result);\n    }\n\n    if (isMatch === false) {\n      result.isMatch = false;\n      return returnObject ? result : false;\n    }\n\n    if (isIgnored(input)) {\n      if (typeof opts.onIgnore === 'function') {\n        opts.onIgnore(result);\n      }\n      result.isMatch = false;\n      return returnObject ? result : false;\n    }\n\n    if (typeof opts.onMatch === 'function') {\n      opts.onMatch(result);\n    }\n    return returnObject ? result : true;\n  };\n\n  if (returnState) {\n    matcher.state = state;\n  }\n\n  return matcher;\n};\n\n/**\n * Test `input` with the given `regex`. This is used by the main\n * `picomatch()` function to test the input string.\n *\n * ```js\n * const picomatch = require('picomatch');\n * // picomatch.test(input, regex[, options]);\n *\n * console.log(picomatch.test('foo/bar', /^(?:([^/]*?)\\/([^/]*?))$/));\n * // { isMatch: true, match: [ 'foo/', 'foo', 'bar' ], output: 'foo/bar' }\n * ```\n * @param {String} `input` String to test.\n * @param {RegExp} `regex`\n * @return {Object} Returns an object with matching info.\n * @api public\n */\n\npicomatch.test = (input, regex, options, { glob, posix } = {}) => {\n  if (typeof input !== 'string') {\n    throw new TypeError('Expected input to be a string');\n  }\n\n  if (input === '') {\n    return { isMatch: false, output: '' };\n  }\n\n  const opts = options || {};\n  const format = opts.format || (posix ? utils$1.toPosixSlashes : null);\n  let match = input === glob;\n  let output = (match && format) ? format(input) : input;\n\n  if (match === false) {\n    output = format ? format(input) : input;\n    match = output === glob;\n  }\n\n  if (match === false || opts.capture === true) {\n    if (opts.matchBase === true || opts.basename === true) {\n      match = picomatch.matchBase(input, regex, options, posix);\n    } else {\n      match = regex.exec(output);\n    }\n  }\n\n  return { isMatch: Boolean(match), match, output };\n};\n\n/**\n * Match the basename of a filepath.\n *\n * ```js\n * const picomatch = require('picomatch');\n * // picomatch.matchBase(input, glob[, options]);\n * console.log(picomatch.matchBase('foo/bar.js', '*.js'); // true\n * ```\n * @param {String} `input` String to test.\n * @param {RegExp|String} `glob` Glob pattern or regex created by [.makeRe](#makeRe).\n * @return {Boolean}\n * @api public\n */\n\npicomatch.matchBase = (input, glob, options, posix = utils$1.isWindows(options)) => {\n  const regex = glob instanceof RegExp ? glob : picomatch.makeRe(glob, options);\n  return regex.test(path.basename(input));\n};\n\n/**\n * Returns true if **any** of the given glob `patterns` match the specified `string`.\n *\n * ```js\n * const picomatch = require('picomatch');\n * // picomatch.isMatch(string, patterns[, options]);\n *\n * console.log(picomatch.isMatch('a.a', ['b.*', '*.a'])); //=> true\n * console.log(picomatch.isMatch('a.a', 'b.*')); //=> false\n * ```\n * @param {String|Array} str The string to test.\n * @param {String|Array} patterns One or more glob patterns to use for matching.\n * @param {Object} [options] See available [options](#options).\n * @return {Boolean} Returns true if any patterns match `str`\n * @api public\n */\n\npicomatch.isMatch = (str, patterns, options) => picomatch(patterns, options)(str);\n\n/**\n * Parse a glob pattern to create the source string for a regular\n * expression.\n *\n * ```js\n * const picomatch = require('picomatch');\n * const result = picomatch.parse(pattern[, options]);\n * ```\n * @param {String} `pattern`\n * @param {Object} `options`\n * @return {Object} Returns an object with useful properties and output to be used as a regex source string.\n * @api public\n */\n\npicomatch.parse = (pattern, options) => {\n  if (Array.isArray(pattern)) return pattern.map(p => picomatch.parse(p, options));\n  return parse_1$1(pattern, { ...options, fastpaths: false });\n};\n\n/**\n * Scan a glob pattern to separate the pattern into segments.\n *\n * ```js\n * const picomatch = require('picomatch');\n * // picomatch.scan(input[, options]);\n *\n * const result = picomatch.scan('!./foo/*.js');\n * console.log(result);\n * { prefix: '!./',\n *   input: '!./foo/*.js',\n *   start: 3,\n *   base: 'foo',\n *   glob: '*.js',\n *   isBrace: false,\n *   isBracket: false,\n *   isGlob: true,\n *   isExtglob: false,\n *   isGlobstar: false,\n *   negated: true }\n * ```\n * @param {String} `input` Glob pattern to scan.\n * @param {Object} `options`\n * @return {Object} Returns an object with\n * @api public\n */\n\npicomatch.scan = (input, options) => scan_1(input, options);\n\n/**\n * Create a regular expression from a parsed glob pattern.\n *\n * ```js\n * const picomatch = require('picomatch');\n * const state = picomatch.parse('*.js');\n * // picomatch.compileRe(state[, options]);\n *\n * console.log(picomatch.compileRe(state));\n * //=> /^(?:(?!\\.)(?=.)[^/]*?\\.js)$/\n * ```\n * @param {String} `state` The object returned from the `.parse` method.\n * @param {Object} `options`\n * @return {RegExp} Returns a regex created from the given pattern.\n * @api public\n */\n\npicomatch.compileRe = (parsed, options, returnOutput = false, returnState = false) => {\n  if (returnOutput === true) {\n    return parsed.output;\n  }\n\n  const opts = options || {};\n  const prepend = opts.contains ? '' : '^';\n  const append = opts.contains ? '' : '$';\n\n  let source = `${prepend}(?:${parsed.output})${append}`;\n  if (parsed && parsed.negated === true) {\n    source = `^(?!${source}).*$`;\n  }\n\n  const regex = picomatch.toRegex(source, options);\n  if (returnState === true) {\n    regex.state = parsed;\n  }\n\n  return regex;\n};\n\npicomatch.makeRe = (input, options, returnOutput = false, returnState = false) => {\n  if (!input || typeof input !== 'string') {\n    throw new TypeError('Expected a non-empty string');\n  }\n\n  const opts = options || {};\n  let parsed = { negated: false, fastpaths: true };\n  let prefix = '';\n  let output;\n\n  if (input.startsWith('./')) {\n    input = input.slice(2);\n    prefix = parsed.prefix = './';\n  }\n\n  if (opts.fastpaths !== false && (input[0] === '.' || input[0] === '*')) {\n    output = parse_1$1.fastpaths(input, options);\n  }\n\n  if (output === undefined) {\n    parsed = parse_1$1(input, options);\n    parsed.prefix = prefix + (parsed.prefix || '');\n  } else {\n    parsed.output = output;\n  }\n\n  return picomatch.compileRe(parsed, options, returnOutput, returnState);\n};\n\n/**\n * Create a regular expression from the given regex source string.\n *\n * ```js\n * const picomatch = require('picomatch');\n * // picomatch.toRegex(source[, options]);\n *\n * const { output } = picomatch.parse('*.js');\n * console.log(picomatch.toRegex(output));\n * //=> /^(?:(?!\\.)(?=.)[^/]*?\\.js)$/\n * ```\n * @param {String} `source` Regular expression source string.\n * @param {Object} `options`\n * @return {RegExp}\n * @api public\n */\n\npicomatch.toRegex = (source, options) => {\n  try {\n    const opts = options || {};\n    return new RegExp(source, opts.flags || (opts.nocase ? 'i' : ''));\n  } catch (err) {\n    if (options && options.debug === true) throw err;\n    return /$^/;\n  }\n};\n\n/**\n * Picomatch constants.\n * @return {Object}\n */\n\npicomatch.constants = constants$1;\n\n/**\n * Expose \"picomatch\"\n */\n\nvar picomatch_1 = picomatch;\n\nvar picomatch$1 = picomatch_1;\n\nconst isEmptyString = val => typeof val === 'string' && (val === '' || val === './');\n\n/**\n * Returns an array of strings that match one or more glob patterns.\n *\n * ```js\n * const mm = require('micromatch');\n * // mm(list, patterns[, options]);\n *\n * console.log(mm(['a.js', 'a.txt'], ['*.js']));\n * //=> [ 'a.js' ]\n * ```\n * @param {String|Array<string>} list List of strings to match.\n * @param {String|Array<string>} patterns One or more glob patterns to use for matching.\n * @param {Object} options See available [options](#options)\n * @return {Array} Returns an array of matches\n * @summary false\n * @api public\n */\n\nconst micromatch = (list, patterns, options) => {\n  patterns = [].concat(patterns);\n  list = [].concat(list);\n\n  let omit = new Set();\n  let keep = new Set();\n  let items = new Set();\n  let negatives = 0;\n\n  let onResult = state => {\n    items.add(state.output);\n    if (options && options.onResult) {\n      options.onResult(state);\n    }\n  };\n\n  for (let i = 0; i < patterns.length; i++) {\n    let isMatch = picomatch$1(String(patterns[i]), { ...options, onResult }, true);\n    let negated = isMatch.state.negated || isMatch.state.negatedExtglob;\n    if (negated) negatives++;\n\n    for (let item of list) {\n      let matched = isMatch(item, true);\n\n      let match = negated ? !matched.isMatch : matched.isMatch;\n      if (!match) continue;\n\n      if (negated) {\n        omit.add(matched.output);\n      } else {\n        omit.delete(matched.output);\n        keep.add(matched.output);\n      }\n    }\n  }\n\n  let result = negatives === patterns.length ? [...items] : [...keep];\n  let matches = result.filter(item => !omit.has(item));\n\n  if (options && matches.length === 0) {\n    if (options.failglob === true) {\n      throw new Error(`No matches found for \"${patterns.join(', ')}\"`);\n    }\n\n    if (options.nonull === true || options.nullglob === true) {\n      return options.unescape ? patterns.map(p => p.replace(/\\\\/g, '')) : patterns;\n    }\n  }\n\n  return matches;\n};\n\n/**\n * Backwards compatibility\n */\n\nmicromatch.match = micromatch;\n\n/**\n * Returns a matcher function from the given glob `pattern` and `options`.\n * The returned function takes a string to match as its only argument and returns\n * true if the string is a match.\n *\n * ```js\n * const mm = require('micromatch');\n * // mm.matcher(pattern[, options]);\n *\n * const isMatch = mm.matcher('*.!(*a)');\n * console.log(isMatch('a.a')); //=> false\n * console.log(isMatch('a.b')); //=> true\n * ```\n * @param {String} `pattern` Glob pattern\n * @param {Object} `options`\n * @return {Function} Returns a matcher function.\n * @api public\n */\n\nmicromatch.matcher = (pattern, options) => picomatch$1(pattern, options);\n\n/**\n * Returns true if **any** of the given glob `patterns` match the specified `string`.\n *\n * ```js\n * const mm = require('micromatch');\n * // mm.isMatch(string, patterns[, options]);\n *\n * console.log(mm.isMatch('a.a', ['b.*', '*.a'])); //=> true\n * console.log(mm.isMatch('a.a', 'b.*')); //=> false\n * ```\n * @param {String} str The string to test.\n * @param {String|Array} patterns One or more glob patterns to use for matching.\n * @param {Object} [options] See available [options](#options).\n * @return {Boolean} Returns true if any patterns match `str`\n * @api public\n */\n\nmicromatch.isMatch = (str, patterns, options) => picomatch$1(patterns, options)(str);\n\n/**\n * Backwards compatibility\n */\n\nmicromatch.any = micromatch.isMatch;\n\n/**\n * Returns a list of strings that _**do not match any**_ of the given `patterns`.\n *\n * ```js\n * const mm = require('micromatch');\n * // mm.not(list, patterns[, options]);\n *\n * console.log(mm.not(['a.a', 'b.b', 'c.c'], '*.a'));\n * //=> ['b.b', 'c.c']\n * ```\n * @param {Array} `list` Array of strings to match.\n * @param {String|Array} `patterns` One or more glob pattern to use for matching.\n * @param {Object} `options` See available [options](#options) for changing how matches are performed\n * @return {Array} Returns an array of strings that **do not match** the given patterns.\n * @api public\n */\n\nmicromatch.not = (list, patterns, options = {}) => {\n  patterns = [].concat(patterns).map(String);\n  let result = new Set();\n  let items = [];\n\n  let onResult = state => {\n    if (options.onResult) options.onResult(state);\n    items.push(state.output);\n  };\n\n  let matches = micromatch(list, patterns, { ...options, onResult });\n\n  for (let item of items) {\n    if (!matches.includes(item)) {\n      result.add(item);\n    }\n  }\n  return [...result];\n};\n\n/**\n * Returns true if the given `string` contains the given pattern. Similar\n * to [.isMatch](#isMatch) but the pattern can match any part of the string.\n *\n * ```js\n * var mm = require('micromatch');\n * // mm.contains(string, pattern[, options]);\n *\n * console.log(mm.contains('aa/bb/cc', '*b'));\n * //=> true\n * console.log(mm.contains('aa/bb/cc', '*d'));\n * //=> false\n * ```\n * @param {String} `str` The string to match.\n * @param {String|Array} `patterns` Glob pattern to use for matching.\n * @param {Object} `options` See available [options](#options) for changing how matches are performed\n * @return {Boolean} Returns true if the patter matches any part of `str`.\n * @api public\n */\n\nmicromatch.contains = (str, pattern, options) => {\n  if (typeof str !== 'string') {\n    throw new TypeError(`Expected a string: \"${util.inspect(str)}\"`);\n  }\n\n  if (Array.isArray(pattern)) {\n    return pattern.some(p => micromatch.contains(str, p, options));\n  }\n\n  if (typeof pattern === 'string') {\n    if (isEmptyString(str) || isEmptyString(pattern)) {\n      return false;\n    }\n\n    if (str.includes(pattern) || (str.startsWith('./') && str.slice(2).includes(pattern))) {\n      return true;\n    }\n  }\n\n  return micromatch.isMatch(str, pattern, { ...options, contains: true });\n};\n\n/**\n * Filter the keys of the given object with the given `glob` pattern\n * and `options`. Does not attempt to match nested keys. If you need this feature,\n * use [glob-object][] instead.\n *\n * ```js\n * const mm = require('micromatch');\n * // mm.matchKeys(object, patterns[, options]);\n *\n * const obj = { aa: 'a', ab: 'b', ac: 'c' };\n * console.log(mm.matchKeys(obj, '*b'));\n * //=> { ab: 'b' }\n * ```\n * @param {Object} `object` The object with keys to filter.\n * @param {String|Array} `patterns` One or more glob patterns to use for matching.\n * @param {Object} `options` See available [options](#options) for changing how matches are performed\n * @return {Object} Returns an object with only keys that match the given patterns.\n * @api public\n */\n\nmicromatch.matchKeys = (obj, patterns, options) => {\n  if (!utils$1.isObject(obj)) {\n    throw new TypeError('Expected the first argument to be an object');\n  }\n  let keys = micromatch(Object.keys(obj), patterns, options);\n  let res = {};\n  for (let key of keys) res[key] = obj[key];\n  return res;\n};\n\n/**\n * Returns true if some of the strings in the given `list` match any of the given glob `patterns`.\n *\n * ```js\n * const mm = require('micromatch');\n * // mm.some(list, patterns[, options]);\n *\n * console.log(mm.some(['foo.js', 'bar.js'], ['*.js', '!foo.js']));\n * // true\n * console.log(mm.some(['foo.js'], ['*.js', '!foo.js']));\n * // false\n * ```\n * @param {String|Array} `list` The string or array of strings to test. Returns as soon as the first match is found.\n * @param {String|Array} `patterns` One or more glob patterns to use for matching.\n * @param {Object} `options` See available [options](#options) for changing how matches are performed\n * @return {Boolean} Returns true if any patterns match `str`\n * @api public\n */\n\nmicromatch.some = (list, patterns, options) => {\n  let items = [].concat(list);\n\n  for (let pattern of [].concat(patterns)) {\n    let isMatch = picomatch$1(String(pattern), options);\n    if (items.some(item => isMatch(item))) {\n      return true;\n    }\n  }\n  return false;\n};\n\n/**\n * Returns true if every string in the given `list` matches\n * any of the given glob `patterns`.\n *\n * ```js\n * const mm = require('micromatch');\n * // mm.every(list, patterns[, options]);\n *\n * console.log(mm.every('foo.js', ['foo.js']));\n * // true\n * console.log(mm.every(['foo.js', 'bar.js'], ['*.js']));\n * // true\n * console.log(mm.every(['foo.js', 'bar.js'], ['*.js', '!foo.js']));\n * // false\n * console.log(mm.every(['foo.js'], ['*.js', '!foo.js']));\n * // false\n * ```\n * @param {String|Array} `list` The string or array of strings to test.\n * @param {String|Array} `patterns` One or more glob patterns to use for matching.\n * @param {Object} `options` See available [options](#options) for changing how matches are performed\n * @return {Boolean} Returns true if any patterns match `str`\n * @api public\n */\n\nmicromatch.every = (list, patterns, options) => {\n  let items = [].concat(list);\n\n  for (let pattern of [].concat(patterns)) {\n    let isMatch = picomatch$1(String(pattern), options);\n    if (!items.every(item => isMatch(item))) {\n      return false;\n    }\n  }\n  return true;\n};\n\n/**\n * Returns true if **all** of the given `patterns` match\n * the specified string.\n *\n * ```js\n * const mm = require('micromatch');\n * // mm.all(string, patterns[, options]);\n *\n * console.log(mm.all('foo.js', ['foo.js']));\n * // true\n *\n * console.log(mm.all('foo.js', ['*.js', '!foo.js']));\n * // false\n *\n * console.log(mm.all('foo.js', ['*.js', 'foo.js']));\n * // true\n *\n * console.log(mm.all('foo.js', ['*.js', 'f*', '*o*', '*o.js']));\n * // true\n * ```\n * @param {String|Array} `str` The string to test.\n * @param {String|Array} `patterns` One or more glob patterns to use for matching.\n * @param {Object} `options` See available [options](#options) for changing how matches are performed\n * @return {Boolean} Returns true if any patterns match `str`\n * @api public\n */\n\nmicromatch.all = (str, patterns, options) => {\n  if (typeof str !== 'string') {\n    throw new TypeError(`Expected a string: \"${util.inspect(str)}\"`);\n  }\n\n  return [].concat(patterns).every(p => picomatch$1(p, options)(str));\n};\n\n/**\n * Returns an array of matches captured by `pattern` in `string, or `null` if the pattern did not match.\n *\n * ```js\n * const mm = require('micromatch');\n * // mm.capture(pattern, string[, options]);\n *\n * console.log(mm.capture('test/*.js', 'test/foo.js'));\n * //=> ['foo']\n * console.log(mm.capture('test/*.js', 'foo/bar.css'));\n * //=> null\n * ```\n * @param {String} `glob` Glob pattern to use for matching.\n * @param {String} `input` String to match\n * @param {Object} `options` See available [options](#options) for changing how matches are performed\n * @return {Boolean} Returns an array of captures if the input matches the glob pattern, otherwise `null`.\n * @api public\n */\n\nmicromatch.capture = (glob, input, options) => {\n  let posix = utils$1.isWindows(options);\n  let regex = picomatch$1.makeRe(String(glob), { ...options, capture: true });\n  let match = regex.exec(posix ? utils$1.toPosixSlashes(input) : input);\n\n  if (match) {\n    return match.slice(1).map(v => v === void 0 ? '' : v);\n  }\n};\n\n/**\n * Create a regular expression from the given glob `pattern`.\n *\n * ```js\n * const mm = require('micromatch');\n * // mm.makeRe(pattern[, options]);\n *\n * console.log(mm.makeRe('*.js'));\n * //=> /^(?:(\\.[\\\\\\/])?(?!\\.)(?=.)[^\\/]*?\\.js)$/\n * ```\n * @param {String} `pattern` A glob pattern to convert to regex.\n * @param {Object} `options`\n * @return {RegExp} Returns a regex created from the given pattern.\n * @api public\n */\n\nmicromatch.makeRe = (...args) => picomatch$1.makeRe(...args);\n\n/**\n * Scan a glob pattern to separate the pattern into segments. Used\n * by the [split](#split) method.\n *\n * ```js\n * const mm = require('micromatch');\n * const state = mm.scan(pattern[, options]);\n * ```\n * @param {String} `pattern`\n * @param {Object} `options`\n * @return {Object} Returns an object with\n * @api public\n */\n\nmicromatch.scan = (...args) => picomatch$1.scan(...args);\n\n/**\n * Parse a glob pattern to create the source string for a regular\n * expression.\n *\n * ```js\n * const mm = require('micromatch');\n * const state = mm(pattern[, options]);\n * ```\n * @param {String} `glob`\n * @param {Object} `options`\n * @return {Object} Returns an object with useful properties and output to be used as regex source string.\n * @api public\n */\n\nmicromatch.parse = (patterns, options) => {\n  let res = [];\n  for (let pattern of [].concat(patterns || [])) {\n    for (let str of braces_1(String(pattern), options)) {\n      res.push(picomatch$1.parse(str, options));\n    }\n  }\n  return res;\n};\n\n/**\n * Process the given brace `pattern`.\n *\n * ```js\n * const { braces } = require('micromatch');\n * console.log(braces('foo/{a,b,c}/bar'));\n * //=> [ 'foo/(a|b|c)/bar' ]\n *\n * console.log(braces('foo/{a,b,c}/bar', { expand: true }));\n * //=> [ 'foo/a/bar', 'foo/b/bar', 'foo/c/bar' ]\n * ```\n * @param {String} `pattern` String with brace pattern to process.\n * @param {Object} `options` Any [options](#options) to change how expansion is performed. See the [braces][] library for all available options.\n * @return {Array}\n * @api public\n */\n\nmicromatch.braces = (pattern, options) => {\n  if (typeof pattern !== 'string') throw new TypeError('Expected a string');\n  if ((options && options.nobrace === true) || !/\\{.*\\}/.test(pattern)) {\n    return [pattern];\n  }\n  return braces_1(pattern, options);\n};\n\n/**\n * Expand braces\n */\n\nmicromatch.braceExpand = (pattern, options) => {\n  if (typeof pattern !== 'string') throw new TypeError('Expected a string');\n  return micromatch.braces(pattern, { ...options, expand: true });\n};\n\n/**\n * Expose micromatch\n */\n\nvar micromatch_1 = micromatch;\n\nfunction ensureArray(thing) {\n    if (Array.isArray(thing))\n        return thing;\n    if (thing == undefined)\n        return [];\n    return [thing];\n}\n\nfunction getMatcherString(id, resolutionBase) {\n    if (resolutionBase === false) {\n        return id;\n    }\n    return resolve(...(typeof resolutionBase === 'string' ? [resolutionBase, id] : [id]));\n}\nconst createFilter = function createFilter(include, exclude, options) {\n    const resolutionBase = options && options.resolve;\n    const getMatcher = (id) => {\n        return id instanceof RegExp\n            ? id\n            : {\n                test: micromatch_1.matcher(getMatcherString(id, resolutionBase)\n                    .split(sep)\n                    .join('/'), { dot: true })\n            };\n    };\n    const includeMatchers = ensureArray(include).map(getMatcher);\n    const excludeMatchers = ensureArray(exclude).map(getMatcher);\n    return function (id) {\n        if (typeof id !== 'string')\n            return false;\n        if (/\\0/.test(id))\n            return false;\n        id = id.split(sep).join('/');\n        for (let i = 0; i < excludeMatchers.length; ++i) {\n            const matcher = excludeMatchers[i];\n            if (matcher.test(id))\n                return false;\n        }\n        for (let i = 0; i < includeMatchers.length; ++i) {\n            const matcher = includeMatchers[i];\n            if (matcher.test(id))\n                return true;\n        }\n        return !includeMatchers.length;\n    };\n};\n\nconst commandAliases = {\n    c: 'config',\n    d: 'dir',\n    e: 'external',\n    f: 'format',\n    g: 'globals',\n    h: 'help',\n    i: 'input',\n    m: 'sourcemap',\n    n: 'name',\n    o: 'file',\n    p: 'plugin',\n    v: 'version',\n    w: 'watch'\n};\nfunction mergeOptions(config, rawCommandOptions = { external: [], globals: undefined }, defaultOnWarnHandler = defaultOnWarn) {\n    const command = getCommandOptions(rawCommandOptions);\n    const inputOptions = mergeInputOptions(config, command, defaultOnWarnHandler);\n    const warn = inputOptions.onwarn;\n    if (command.output) {\n        Object.assign(command, command.output);\n    }\n    const outputOptionsArray = ensureArray$1(config.output);\n    if (outputOptionsArray.length === 0)\n        outputOptionsArray.push({});\n    const outputOptions = outputOptionsArray.map(singleOutputOptions => mergeOutputOptions(singleOutputOptions, command, warn));\n    warnUnknownOptions(command, Object.keys(inputOptions).concat(Object.keys(outputOptions[0]).filter(option => option !== 'sourcemapPathTransform'), Object.keys(commandAliases), 'config', 'environment', 'plugin', 'silent', 'stdin', 'waitForBundleInput'), 'CLI flags', warn, /^_$|output$|config/);\n    inputOptions.output = outputOptions;\n    return inputOptions;\n}\nfunction getCommandOptions(rawCommandOptions) {\n    const external = rawCommandOptions.external && typeof rawCommandOptions.external === 'string'\n        ? rawCommandOptions.external.split(',')\n        : [];\n    return {\n        ...rawCommandOptions,\n        external,\n        globals: typeof rawCommandOptions.globals === 'string'\n            ? rawCommandOptions.globals.split(',').reduce((globals, globalDefinition) => {\n                const [id, variableName] = globalDefinition.split(':');\n                globals[id] = variableName;\n                if (external.indexOf(id) === -1) {\n                    external.push(id);\n                }\n                return globals;\n            }, Object.create(null))\n            : undefined\n    };\n}\nfunction mergeInputOptions(config, overrides, defaultOnWarnHandler) {\n    const getOption = (name) => { var _a; return (_a = overrides[name]) !== null && _a !== void 0 ? _a : config[name]; };\n    const inputOptions = {\n        acorn: getOption('acorn'),\n        acornInjectPlugins: config.acornInjectPlugins,\n        cache: config.cache,\n        context: getOption('context'),\n        experimentalCacheExpiry: getOption('experimentalCacheExpiry'),\n        external: getExternal(config, overrides),\n        inlineDynamicImports: getOption('inlineDynamicImports'),\n        input: getOption('input') || [],\n        manualChunks: getOption('manualChunks'),\n        moduleContext: getOption('moduleContext'),\n        onwarn: getOnWarn(config, defaultOnWarnHandler),\n        perf: getOption('perf'),\n        plugins: ensureArray$1(config.plugins),\n        preserveEntrySignatures: getOption('preserveEntrySignatures'),\n        preserveModules: getOption('preserveModules'),\n        preserveSymlinks: getOption('preserveSymlinks'),\n        shimMissingExports: getOption('shimMissingExports'),\n        strictDeprecations: getOption('strictDeprecations'),\n        treeshake: getObjectOption(config, overrides, 'treeshake'),\n        watch: getWatch(config, overrides, 'watch')\n    };\n    warnUnknownOptions(config, Object.keys(inputOptions), 'input options', inputOptions.onwarn, /^output$/);\n    return inputOptions;\n}\nconst getExternal = (config, overrides) => {\n    const configExternal = config.external;\n    return typeof configExternal === 'function'\n        ? (source, importer, isResolved) => configExternal(source, importer, isResolved) || overrides.external.indexOf(source) !== -1\n        : ensureArray$1(configExternal).concat(overrides.external);\n};\nconst getOnWarn = (config, defaultOnWarnHandler) => config.onwarn\n    ? warning => config.onwarn(warning, defaultOnWarnHandler)\n    : defaultOnWarnHandler;\nconst getObjectOption = (config, overrides, name) => {\n    const commandOption = normalizeObjectOptionValue(overrides[name]);\n    const configOption = normalizeObjectOptionValue(config[name]);\n    if (commandOption !== undefined) {\n        return commandOption && { ...configOption, ...commandOption };\n    }\n    return configOption;\n};\nconst getWatch = (config, overrides, name) => config.watch !== false && getObjectOption(config, overrides, name);\nconst normalizeObjectOptionValue = (optionValue) => {\n    if (!optionValue) {\n        return optionValue;\n    }\n    if (Array.isArray(optionValue)) {\n        return optionValue.reduce((result, value) => value && result && { ...result, ...value }, {});\n    }\n    if (typeof optionValue !== 'object') {\n        return {};\n    }\n    return optionValue;\n};\nfunction mergeOutputOptions(config, overrides, warn) {\n    const getOption = (name) => { var _a; return (_a = overrides[name]) !== null && _a !== void 0 ? _a : config[name]; };\n    const outputOptions = {\n        amd: getObjectOption(config, overrides, 'amd'),\n        assetFileNames: getOption('assetFileNames'),\n        banner: getOption('banner'),\n        chunkFileNames: getOption('chunkFileNames'),\n        compact: getOption('compact'),\n        dir: getOption('dir'),\n        dynamicImportFunction: getOption('dynamicImportFunction'),\n        entryFileNames: getOption('entryFileNames'),\n        esModule: getOption('esModule'),\n        exports: getOption('exports'),\n        extend: getOption('extend'),\n        externalLiveBindings: getOption('externalLiveBindings'),\n        file: getOption('file'),\n        footer: getOption('footer'),\n        format: getOption('format'),\n        freeze: getOption('freeze'),\n        globals: getOption('globals'),\n        hoistTransitiveImports: getOption('hoistTransitiveImports'),\n        indent: getOption('indent'),\n        inlineDynamicImports: getOption('inlineDynamicImports'),\n        interop: getOption('interop'),\n        intro: getOption('intro'),\n        manualChunks: getOption('manualChunks'),\n        minifyInternalExports: getOption('minifyInternalExports'),\n        name: getOption('name'),\n        namespaceToStringTag: getOption('namespaceToStringTag'),\n        noConflict: getOption('noConflict'),\n        outro: getOption('outro'),\n        paths: getOption('paths'),\n        plugins: ensureArray$1(config.plugins),\n        preferConst: getOption('preferConst'),\n        preserveModules: getOption('preserveModules'),\n        sourcemap: getOption('sourcemap'),\n        sourcemapExcludeSources: getOption('sourcemapExcludeSources'),\n        sourcemapFile: getOption('sourcemapFile'),\n        sourcemapPathTransform: getOption('sourcemapPathTransform'),\n        strict: getOption('strict'),\n        systemNullSetters: getOption('systemNullSetters')\n    };\n    warnUnknownOptions(config, Object.keys(outputOptions), 'output options', warn);\n    return outputOptions;\n}\n\nconst { Readable } = stream;\n\nconst { promisify } = util;\n\n\nconst readdir = promisify(fs.readdir);\nconst stat = promisify(fs.stat);\nconst lstat = promisify(fs.lstat);\nconst realpath = promisify(fs.realpath);\n\n/**\n * @typedef {Object} EntryInfo\n * @property {String} path\n * @property {String} fullPath\n * @property {fs.Stats=} stats\n * @property {fs.Dirent=} dirent\n * @property {String} basename\n */\n\nconst BANG = '!';\nconst NORMAL_FLOW_ERRORS = new Set(['ENOENT', 'EPERM', 'EACCES', 'ELOOP']);\nconst FILE_TYPE = 'files';\nconst DIR_TYPE = 'directories';\nconst FILE_DIR_TYPE = 'files_directories';\nconst EVERYTHING_TYPE = 'all';\nconst ALL_TYPES = [FILE_TYPE, DIR_TYPE, FILE_DIR_TYPE, EVERYTHING_TYPE];\n\nconst isNormalFlowError = error => NORMAL_FLOW_ERRORS.has(error.code);\n\nconst normalizeFilter = filter => {\n  if (filter === undefined) return;\n  if (typeof filter === 'function') return filter;\n\n  if (typeof filter === 'string') {\n    const glob = picomatch$1(filter.trim());\n    return entry => glob(entry.basename);\n  }\n\n  if (Array.isArray(filter)) {\n    const positive = [];\n    const negative = [];\n    for (const item of filter) {\n      const trimmed = item.trim();\n      if (trimmed.charAt(0) === BANG) {\n        negative.push(picomatch$1(trimmed.slice(1)));\n      } else {\n        positive.push(picomatch$1(trimmed));\n      }\n    }\n\n    if (negative.length > 0) {\n      if (positive.length > 0) {\n        return entry =>\n          positive.some(f => f(entry.basename)) && !negative.some(f => f(entry.basename));\n      }\n      return entry => !negative.some(f => f(entry.basename));\n    }\n    return entry => positive.some(f => f(entry.basename));\n  }\n};\n\nclass ReaddirpStream extends Readable {\n  static get defaultOptions() {\n    return {\n      root: '.',\n      /* eslint-disable no-unused-vars */\n      fileFilter: (path) => true,\n      directoryFilter: (path) => true,\n      /* eslint-enable no-unused-vars */\n      type: FILE_TYPE,\n      lstat: false,\n      depth: 2147483648,\n      alwaysStat: false\n    };\n  }\n\n  constructor(options = {}) {\n    super({\n      objectMode: true,\n      autoDestroy: true,\n      highWaterMark: options.highWaterMark || 4096\n    });\n    const opts = { ...ReaddirpStream.defaultOptions, ...options };\n    const { root, type } = opts;\n\n    this._fileFilter = normalizeFilter(opts.fileFilter);\n    this._directoryFilter = normalizeFilter(opts.directoryFilter);\n\n    const statMethod = opts.lstat ? lstat : stat;\n    // Use bigint stats if it's windows and stat() supports options (node 10+).\n    if (process.platform === 'win32' && stat.length === 3) {\n      this._stat = path => statMethod(path, { bigint: true });\n    } else {\n      this._stat = statMethod;\n    }\n\n    this._maxDepth = opts.depth;\n    this._wantsDir = [DIR_TYPE, FILE_DIR_TYPE, EVERYTHING_TYPE].includes(type);\n    this._wantsFile = [FILE_TYPE, FILE_DIR_TYPE, EVERYTHING_TYPE].includes(type);\n    this._wantsEverything = type === EVERYTHING_TYPE;\n    this._root = path.resolve(root);\n    this._isDirent = ('Dirent' in fs) && !opts.alwaysStat;\n    this._statsProp = this._isDirent ? 'dirent' : 'stats';\n    this._rdOptions = { encoding: 'utf8', withFileTypes: this._isDirent };\n\n    // Launch stream with one parent, the root dir.\n    this.parents = [this._exploreDir(root, 1)];\n    this.reading = false;\n    this.parent = undefined;\n  }\n\n  async _read(batch) {\n    if (this.reading) return;\n    this.reading = true;\n\n    try {\n      while (!this.destroyed && batch > 0) {\n        const { path, depth, files = [] } = this.parent || {};\n\n        if (files.length > 0) {\n          const slice = files.splice(0, batch).map(dirent => this._formatEntry(dirent, path));\n          for (const entry of await Promise.all(slice)) {\n            if (this.destroyed) return;\n\n            const entryType = await this._getEntryType(entry);\n            if (entryType === 'directory' && this._directoryFilter(entry)) {\n              if (depth <= this._maxDepth) {\n                this.parents.push(this._exploreDir(entry.fullPath, depth + 1));\n              }\n\n              if (this._wantsDir) {\n                this.push(entry);\n                batch--;\n              }\n            } else if ((entryType === 'file' || this._includeAsFile(entry)) && this._fileFilter(entry)) {\n              if (this._wantsFile) {\n                this.push(entry);\n                batch--;\n              }\n            }\n          }\n        } else {\n          const parent = this.parents.pop();\n          if (!parent) {\n            this.push(null);\n            break;\n          }\n          this.parent = await parent;\n          if (this.destroyed) return;\n        }\n      }\n    } catch (error) {\n      this.destroy(error);\n    } finally {\n      this.reading = false;\n    }\n  }\n\n  async _exploreDir(path, depth) {\n    let files;\n    try {\n      files = await readdir(path, this._rdOptions);\n    } catch (error) {\n      this._onError(error);\n    }\n    return {files, depth, path};\n  }\n\n  async _formatEntry(dirent, path$1) {\n    let entry;\n    try {\n      const basename = this._isDirent ? dirent.name : dirent;\n      const fullPath = path.resolve(path.join(path$1, basename));\n      entry = {path: path.relative(this._root, fullPath), fullPath, basename};\n      entry[this._statsProp] = this._isDirent ? dirent : await this._stat(fullPath);\n    } catch (err) {\n      this._onError(err);\n    }\n    return entry;\n  }\n\n  _onError(err) {\n    if (isNormalFlowError(err) && !this.destroyed) {\n      this.emit('warn', err);\n    } else {\n      this.destroy(err);\n    }\n  }\n\n  async _getEntryType(entry) {\n    // entry may be undefined, because a warning or an error were emitted\n    // and the statsProp is undefined\n    const stats = entry && entry[this._statsProp];\n    if (!stats) {\n      return;\n    }\n    if (stats.isFile()) {\n      return 'file';\n    }\n    if (stats.isDirectory()) {\n      return 'directory';\n    }\n    if (stats && stats.isSymbolicLink()) {\n      try {\n        const entryRealPath = await realpath(entry.fullPath);\n        const entryRealPathStats = await lstat(entryRealPath);\n        if (entryRealPathStats.isFile()) {\n          return 'file';\n        }\n        if (entryRealPathStats.isDirectory()) {\n          return 'directory';\n        }\n      } catch (error) {\n        this._onError(error);\n      }\n    }\n  }\n\n  _includeAsFile(entry) {\n    const stats = entry && entry[this._statsProp];\n\n    return stats && this._wantsEverything && !stats.isDirectory();\n  }\n}\n\n/**\n * @typedef {Object} ReaddirpArguments\n * @property {Function=} fileFilter\n * @property {Function=} directoryFilter\n * @property {String=} type\n * @property {Number=} depth\n * @property {String=} root\n * @property {Boolean=} lstat\n * @property {Boolean=} bigint\n */\n\n/**\n * Main function which ends up calling readdirRec and reads all files and directories in given root recursively.\n * @param {String} root Root directory\n * @param {ReaddirpArguments=} options Options to specify root (start directory), filters and recursion depth\n */\nconst readdirp = (root, options = {}) => {\n  let type = options.entryType || options.type;\n  if (type === 'both') type = FILE_DIR_TYPE; // backwards-compatibility\n  if (type) options.type = type;\n  if (!root) {\n    throw new Error('readdirp: root argument is required. Usage: readdirp(root, options)');\n  } else if (typeof root !== 'string') {\n    throw new TypeError('readdirp: root argument must be a string. Usage: readdirp(root, options)');\n  } else if (type && !ALL_TYPES.includes(type)) {\n    throw new Error(`readdirp: Invalid type passed. Use one of ${ALL_TYPES.join(', ')}`);\n  }\n\n  options.root = root;\n  return new ReaddirpStream(options);\n};\n\nconst readdirpPromise = (root, options = {}) => {\n  return new Promise((resolve, reject) => {\n    const files = [];\n    readdirp(root, options)\n      .on('data', entry => files.push(entry))\n      .on('end', () => resolve(files))\n      .on('error', error => reject(error));\n  });\n};\n\nreaddirp.promise = readdirpPromise;\nreaddirp.ReaddirpStream = ReaddirpStream;\nreaddirp.default = readdirp;\n\nvar readdirp_1 = readdirp;\n\n/*!\n * normalize-path <https://github.com/jonschlinkert/normalize-path>\n *\n * Copyright (c) 2014-2018, Jon Schlinkert.\n * Released under the MIT License.\n */\n\nvar normalizePath = function(path, stripTrailing) {\n  if (typeof path !== 'string') {\n    throw new TypeError('expected path to be a string');\n  }\n\n  if (path === '\\\\' || path === '/') return '/';\n\n  var len = path.length;\n  if (len <= 1) return path;\n\n  // ensure that win32 namespaces has two leading slashes, so that the path is\n  // handled properly by the win32 version of path.parse() after being normalized\n  // https://msdn.microsoft.com/library/windows/desktop/aa365247(v=vs.85).aspx#namespaces\n  var prefix = '';\n  if (len > 4 && path[3] === '\\\\') {\n    var ch = path[2];\n    if ((ch === '?' || ch === '.') && path.slice(0, 2) === '\\\\\\\\') {\n      path = path.slice(2);\n      prefix = '//';\n    }\n  }\n\n  var segs = path.split(/[/\\\\]+/);\n  if (stripTrailing !== false && segs[segs.length - 1] === '') {\n    segs.pop();\n  }\n  return prefix + segs.join('/');\n};\n\nvar anymatch_1 = createCommonjsModule(function (module, exports) {\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\n\n\n\n\n/**\n * @typedef {(testString: string) => boolean} AnymatchFn\n * @typedef {string|RegExp|AnymatchFn} AnymatchPattern\n * @typedef {AnymatchPattern|AnymatchPattern[]} AnymatchMatcher\n */\nconst BANG = '!';\nconst DEFAULT_OPTIONS = {returnIndex: false};\nconst arrify = (item) => Array.isArray(item) ? item : [item];\n\n/**\n * @param {AnymatchPattern} matcher\n * @param {object} options\n * @returns {AnymatchFn}\n */\nconst createPattern = (matcher, options) => {\n  if (typeof matcher === 'function') {\n    return matcher;\n  }\n  if (typeof matcher === 'string') {\n    const glob = picomatch$1(matcher, options);\n    return (string) => matcher === string || glob(string);\n  }\n  if (matcher instanceof RegExp) {\n    return (string) => matcher.test(string);\n  }\n  return (string) => false;\n};\n\n/**\n * @param {Array<Function>} patterns\n * @param {Array<Function>} negPatterns\n * @param {String|Array} args\n * @param {Boolean} returnIndex\n * @returns {boolean|number}\n */\nconst matchPatterns = (patterns, negPatterns, args, returnIndex) => {\n  const isList = Array.isArray(args);\n  const _path = isList ? args[0] : args;\n  if (!isList && typeof _path !== 'string') {\n    throw new TypeError('anymatch: second argument must be a string: got ' +\n      Object.prototype.toString.call(_path))\n  }\n  const path = normalizePath(_path);\n\n  for (let index = 0; index < negPatterns.length; index++) {\n    const nglob = negPatterns[index];\n    if (nglob(path)) {\n      return returnIndex ? -1 : false;\n    }\n  }\n\n  const applied = isList && [path].concat(args.slice(1));\n  for (let index = 0; index < patterns.length; index++) {\n    const pattern = patterns[index];\n    if (isList ? pattern(...applied) : pattern(path)) {\n      return returnIndex ? index : true;\n    }\n  }\n\n  return returnIndex ? -1 : false;\n};\n\n/**\n * @param {AnymatchMatcher} matchers\n * @param {Array|string} testString\n * @param {object} options\n * @returns {boolean|number|Function}\n */\nconst anymatch = (matchers, testString, options = DEFAULT_OPTIONS) => {\n  if (matchers == null) {\n    throw new TypeError('anymatch: specify first argument');\n  }\n  const opts = typeof options === 'boolean' ? {returnIndex: options} : options;\n  const returnIndex = opts.returnIndex || false;\n\n  // Early cache for matchers.\n  const mtchers = arrify(matchers);\n  const negatedGlobs = mtchers\n    .filter(item => typeof item === 'string' && item.charAt(0) === BANG)\n    .map(item => item.slice(1))\n    .map(item => picomatch$1(item, opts));\n  const patterns = mtchers.map(matcher => createPattern(matcher, opts));\n\n  if (testString == null) {\n    return (testString, ri = false) => {\n      const returnIndex = typeof ri === 'boolean' ? ri : false;\n      return matchPatterns(patterns, negatedGlobs, testString, returnIndex);\n    }\n  }\n\n  return matchPatterns(patterns, negatedGlobs, testString, returnIndex);\n};\n\nanymatch.default = anymatch;\nmodule.exports = anymatch;\n});\n\n/*!\n * is-extglob <https://github.com/jonschlinkert/is-extglob>\n *\n * Copyright (c) 2014-2016, Jon Schlinkert.\n * Licensed under the MIT License.\n */\n\nvar isExtglob = function isExtglob(str) {\n  if (typeof str !== 'string' || str === '') {\n    return false;\n  }\n\n  var match;\n  while ((match = /(\\\\).|([@?!+*]\\(.*\\))/g.exec(str))) {\n    if (match[2]) return true;\n    str = str.slice(match.index + match[0].length);\n  }\n\n  return false;\n};\n\n/*!\n * is-glob <https://github.com/jonschlinkert/is-glob>\n *\n * Copyright (c) 2014-2017, Jon Schlinkert.\n * Released under the MIT License.\n */\n\n\nvar chars = { '{': '}', '(': ')', '[': ']'};\nvar strictRegex = /\\\\(.)|(^!|\\*|[\\].+)]\\?|\\[[^\\\\\\]]+\\]|\\{[^\\\\}]+\\}|\\(\\?[:!=][^\\\\)]+\\)|\\([^|]+\\|[^\\\\)]+\\))/;\nvar relaxedRegex = /\\\\(.)|(^!|[*?{}()[\\]]|\\(\\?)/;\n\nvar isGlob = function isGlob(str, options) {\n  if (typeof str !== 'string' || str === '') {\n    return false;\n  }\n\n  if (isExtglob(str)) {\n    return true;\n  }\n\n  var regex = strictRegex;\n  var match;\n\n  // optionally relax regex\n  if (options && options.strict === false) {\n    regex = relaxedRegex;\n  }\n\n  while ((match = regex.exec(str))) {\n    if (match[2]) return true;\n    var idx = match.index + match[0].length;\n\n    // if an open bracket/brace/paren is escaped,\n    // set the index to the next closing character\n    var open = match[1];\n    var close = open ? chars[open] : null;\n    if (open && close) {\n      var n = str.indexOf(close, idx);\n      if (n !== -1) {\n        idx = n + 1;\n      }\n    }\n\n    str = str.slice(idx);\n  }\n  return false;\n};\n\nvar pathPosixDirname = path.posix.dirname;\nvar isWin32 = os.platform() === 'win32';\n\nvar slash = '/';\nvar backslash = /\\\\/g;\nvar enclosure = /[\\{\\[].*[\\/]*.*[\\}\\]]$/;\nvar globby = /(^|[^\\\\])([\\{\\[]|\\([^\\)]+$)/;\nvar escaped = /\\\\([\\!\\*\\?\\|\\[\\]\\(\\)\\{\\}])/g;\n\n/**\n * @param {string} str\n * @param {Object} opts\n * @param {boolean} [opts.flipBackslashes=true]\n */\nvar globParent = function globParent(str, opts) {\n  var options = Object.assign({ flipBackslashes: true }, opts);\n\n  // flip windows path separators\n  if (options.flipBackslashes && isWin32 && str.indexOf(slash) < 0) {\n    str = str.replace(backslash, slash);\n  }\n\n  // special case for strings ending in enclosure containing path separator\n  if (enclosure.test(str)) {\n    str += slash;\n  }\n\n  // preserves full path in case of trailing path separator\n  str += 'a';\n\n  // remove path parts that are globby\n  do {\n    str = pathPosixDirname(str);\n  } while (isGlob(str) || globby.test(str));\n\n  // remove escape chars and return result\n  return str.replace(escaped, '$1');\n};\n\nvar binaryExtensions = [\n\t\"3dm\",\n\t\"3ds\",\n\t\"3g2\",\n\t\"3gp\",\n\t\"7z\",\n\t\"a\",\n\t\"aac\",\n\t\"adp\",\n\t\"ai\",\n\t\"aif\",\n\t\"aiff\",\n\t\"alz\",\n\t\"ape\",\n\t\"apk\",\n\t\"ar\",\n\t\"arj\",\n\t\"asf\",\n\t\"au\",\n\t\"avi\",\n\t\"bak\",\n\t\"baml\",\n\t\"bh\",\n\t\"bin\",\n\t\"bk\",\n\t\"bmp\",\n\t\"btif\",\n\t\"bz2\",\n\t\"bzip2\",\n\t\"cab\",\n\t\"caf\",\n\t\"cgm\",\n\t\"class\",\n\t\"cmx\",\n\t\"cpio\",\n\t\"cr2\",\n\t\"cur\",\n\t\"dat\",\n\t\"dcm\",\n\t\"deb\",\n\t\"dex\",\n\t\"djvu\",\n\t\"dll\",\n\t\"dmg\",\n\t\"dng\",\n\t\"doc\",\n\t\"docm\",\n\t\"docx\",\n\t\"dot\",\n\t\"dotm\",\n\t\"dra\",\n\t\"DS_Store\",\n\t\"dsk\",\n\t\"dts\",\n\t\"dtshd\",\n\t\"dvb\",\n\t\"dwg\",\n\t\"dxf\",\n\t\"ecelp4800\",\n\t\"ecelp7470\",\n\t\"ecelp9600\",\n\t\"egg\",\n\t\"eol\",\n\t\"eot\",\n\t\"epub\",\n\t\"exe\",\n\t\"f4v\",\n\t\"fbs\",\n\t\"fh\",\n\t\"fla\",\n\t\"flac\",\n\t\"fli\",\n\t\"flv\",\n\t\"fpx\",\n\t\"fst\",\n\t\"fvt\",\n\t\"g3\",\n\t\"gh\",\n\t\"gif\",\n\t\"graffle\",\n\t\"gz\",\n\t\"gzip\",\n\t\"h261\",\n\t\"h263\",\n\t\"h264\",\n\t\"icns\",\n\t\"ico\",\n\t\"ief\",\n\t\"img\",\n\t\"ipa\",\n\t\"iso\",\n\t\"jar\",\n\t\"jpeg\",\n\t\"jpg\",\n\t\"jpgv\",\n\t\"jpm\",\n\t\"jxr\",\n\t\"key\",\n\t\"ktx\",\n\t\"lha\",\n\t\"lib\",\n\t\"lvp\",\n\t\"lz\",\n\t\"lzh\",\n\t\"lzma\",\n\t\"lzo\",\n\t\"m3u\",\n\t\"m4a\",\n\t\"m4v\",\n\t\"mar\",\n\t\"mdi\",\n\t\"mht\",\n\t\"mid\",\n\t\"midi\",\n\t\"mj2\",\n\t\"mka\",\n\t\"mkv\",\n\t\"mmr\",\n\t\"mng\",\n\t\"mobi\",\n\t\"mov\",\n\t\"movie\",\n\t\"mp3\",\n\t\"mp4\",\n\t\"mp4a\",\n\t\"mpeg\",\n\t\"mpg\",\n\t\"mpga\",\n\t\"mxu\",\n\t\"nef\",\n\t\"npx\",\n\t\"numbers\",\n\t\"nupkg\",\n\t\"o\",\n\t\"oga\",\n\t\"ogg\",\n\t\"ogv\",\n\t\"otf\",\n\t\"pages\",\n\t\"pbm\",\n\t\"pcx\",\n\t\"pdb\",\n\t\"pdf\",\n\t\"pea\",\n\t\"pgm\",\n\t\"pic\",\n\t\"png\",\n\t\"pnm\",\n\t\"pot\",\n\t\"potm\",\n\t\"potx\",\n\t\"ppa\",\n\t\"ppam\",\n\t\"ppm\",\n\t\"pps\",\n\t\"ppsm\",\n\t\"ppsx\",\n\t\"ppt\",\n\t\"pptm\",\n\t\"pptx\",\n\t\"psd\",\n\t\"pya\",\n\t\"pyc\",\n\t\"pyo\",\n\t\"pyv\",\n\t\"qt\",\n\t\"rar\",\n\t\"ras\",\n\t\"raw\",\n\t\"resources\",\n\t\"rgb\",\n\t\"rip\",\n\t\"rlc\",\n\t\"rmf\",\n\t\"rmvb\",\n\t\"rtf\",\n\t\"rz\",\n\t\"s3m\",\n\t\"s7z\",\n\t\"scpt\",\n\t\"sgi\",\n\t\"shar\",\n\t\"sil\",\n\t\"sketch\",\n\t\"slk\",\n\t\"smv\",\n\t\"snk\",\n\t\"so\",\n\t\"stl\",\n\t\"suo\",\n\t\"sub\",\n\t\"swf\",\n\t\"tar\",\n\t\"tbz\",\n\t\"tbz2\",\n\t\"tga\",\n\t\"tgz\",\n\t\"thmx\",\n\t\"tif\",\n\t\"tiff\",\n\t\"tlz\",\n\t\"ttc\",\n\t\"ttf\",\n\t\"txz\",\n\t\"udf\",\n\t\"uvh\",\n\t\"uvi\",\n\t\"uvm\",\n\t\"uvp\",\n\t\"uvs\",\n\t\"uvu\",\n\t\"viv\",\n\t\"vob\",\n\t\"war\",\n\t\"wav\",\n\t\"wax\",\n\t\"wbmp\",\n\t\"wdp\",\n\t\"weba\",\n\t\"webm\",\n\t\"webp\",\n\t\"whl\",\n\t\"wim\",\n\t\"wm\",\n\t\"wma\",\n\t\"wmv\",\n\t\"wmx\",\n\t\"woff\",\n\t\"woff2\",\n\t\"wrm\",\n\t\"wvx\",\n\t\"xbm\",\n\t\"xif\",\n\t\"xla\",\n\t\"xlam\",\n\t\"xls\",\n\t\"xlsb\",\n\t\"xlsm\",\n\t\"xlsx\",\n\t\"xlt\",\n\t\"xltm\",\n\t\"xltx\",\n\t\"xm\",\n\t\"xmind\",\n\t\"xpi\",\n\t\"xpm\",\n\t\"xwd\",\n\t\"xz\",\n\t\"z\",\n\t\"zip\",\n\t\"zipx\"\n];\n\nvar binaryExtensions$1 = {\n  __proto__: null,\n  'default': binaryExtensions\n};\n\nvar require$$0 = getCjsExportFromNamespace(binaryExtensions$1);\n\nvar binaryExtensions$2 = require$$0;\n\nconst extensions = new Set(binaryExtensions$2);\n\nvar isBinaryPath = filePath => extensions.has(path.extname(filePath).slice(1).toLowerCase());\n\nvar constants$2 = createCommonjsModule(function (module, exports) {\n\nconst {sep} = path;\nconst {platform} = process;\n\nexports.EV_ALL = 'all';\nexports.EV_READY = 'ready';\nexports.EV_ADD = 'add';\nexports.EV_CHANGE = 'change';\nexports.EV_ADD_DIR = 'addDir';\nexports.EV_UNLINK = 'unlink';\nexports.EV_UNLINK_DIR = 'unlinkDir';\nexports.EV_RAW = 'raw';\nexports.EV_ERROR = 'error';\n\nexports.STR_DATA = 'data';\nexports.STR_END = 'end';\nexports.STR_CLOSE = 'close';\n\nexports.FSEVENT_CREATED = 'created';\nexports.FSEVENT_MODIFIED = 'modified';\nexports.FSEVENT_DELETED = 'deleted';\nexports.FSEVENT_MOVED = 'moved';\nexports.FSEVENT_CLONED = 'cloned';\nexports.FSEVENT_UNKNOWN = 'unknown';\nexports.FSEVENT_TYPE_FILE = 'file';\nexports.FSEVENT_TYPE_DIRECTORY = 'directory';\nexports.FSEVENT_TYPE_SYMLINK = 'symlink';\n\nexports.KEY_LISTENERS = 'listeners';\nexports.KEY_ERR = 'errHandlers';\nexports.KEY_RAW = 'rawEmitters';\nexports.HANDLER_KEYS = [exports.KEY_LISTENERS, exports.KEY_ERR, exports.KEY_RAW];\n\nexports.DOT_SLASH = `.${sep}`;\n\nexports.BACK_SLASH_RE = /\\\\/g;\nexports.DOUBLE_SLASH_RE = /\\/\\//;\nexports.SLASH_OR_BACK_SLASH_RE = /[/\\\\]/;\nexports.DOT_RE = /\\..*\\.(sw[px])$|~$|\\.subl.*\\.tmp/;\nexports.REPLACER_RE = /^\\.[/\\\\]/;\n\nexports.SLASH = '/';\nexports.BRACE_START = '{';\nexports.BANG = '!';\nexports.ONE_DOT = '.';\nexports.TWO_DOTS = '..';\nexports.STAR = '*';\nexports.GLOBSTAR = '**';\nexports.ROOT_GLOBSTAR = '/**/*';\nexports.SLASH_GLOBSTAR = '/**';\nexports.DIR_SUFFIX = 'Dir';\nexports.ANYMATCH_OPTS = {dot: true};\nexports.STRING_TYPE = 'string';\nexports.FUNCTION_TYPE = 'function';\nexports.EMPTY_STR = '';\nexports.EMPTY_FN = () => {};\nexports.IDENTITY_FN = val => val;\n\nexports.isWindows = platform === 'win32';\nexports.isMacos = platform === 'darwin';\n});\n\nconst { promisify: promisify$1 } = util;\n\nconst {\n  isWindows,\n  EMPTY_FN,\n  EMPTY_STR,\n  KEY_LISTENERS,\n  KEY_ERR,\n  KEY_RAW,\n  HANDLER_KEYS,\n  EV_CHANGE,\n  EV_ADD,\n  EV_ADD_DIR,\n  EV_ERROR,\n  STR_DATA,\n  STR_END,\n  BRACE_START,\n  STAR: STAR$1\n} = constants$2;\n\nconst THROTTLE_MODE_WATCH = 'watch';\n\nconst open = promisify$1(fs.open);\nconst stat$1 = promisify$1(fs.stat);\nconst lstat$1 = promisify$1(fs.lstat);\nconst close = promisify$1(fs.close);\nconst fsrealpath = promisify$1(fs.realpath);\n\nconst statMethods = { lstat: lstat$1, stat: stat$1 };\n\n// TODO: emit errors properly. Example: EMFILE on Macos.\nconst foreach = (val, fn) => {\n  if (val instanceof Set) {\n    val.forEach(fn);\n  } else {\n    fn(val);\n  }\n};\n\nconst addAndConvert = (main, prop, item) => {\n  let container = main[prop];\n  if (!(container instanceof Set)) {\n    main[prop] = container = new Set([container]);\n  }\n  container.add(item);\n};\n\nconst clearItem = cont => key => {\n  const set = cont[key];\n  if (set instanceof Set) {\n    set.clear();\n  } else {\n    delete cont[key];\n  }\n};\n\nconst delFromSet = (main, prop, item) => {\n  const container = main[prop];\n  if (container instanceof Set) {\n    container.delete(item);\n  } else if (container === item) {\n    delete main[prop];\n  }\n};\n\nconst isEmptySet = (val) => val instanceof Set ? val.size === 0 : !val;\n\n/**\n * @typedef {String} Path\n */\n\n// fs_watch helpers\n\n// object to hold per-process fs_watch instances\n// (may be shared across chokidar FSWatcher instances)\n\n/**\n * @typedef {Object} FsWatchContainer\n * @property {Set} listeners\n * @property {Set} errHandlers\n * @property {Set} rawEmitters\n * @property {fs.FSWatcher=} watcher\n * @property {Boolean=} watcherUnusable\n */\n\n/**\n * @type {Map<String,FsWatchContainer>}\n */\nconst FsWatchInstances = new Map();\n\n/**\n * Instantiates the fs_watch interface\n * @param {String} path to be watched\n * @param {Object} options to be passed to fs_watch\n * @param {Function} listener main event handler\n * @param {Function} errHandler emits info about errors\n * @param {Function} emitRaw emits raw event data\n * @returns {fs.FSWatcher} new fsevents instance\n */\nfunction createFsWatchInstance(path$1, options, listener, errHandler, emitRaw) {\n  const handleEvent = (rawEvent, evPath) => {\n    listener(path$1);\n    emitRaw(rawEvent, evPath, {watchedPath: path$1});\n\n    // emit based on events occurring for files from a directory's watcher in\n    // case the file's watcher misses it (and rely on throttling to de-dupe)\n    if (evPath && path$1 !== evPath) {\n      fsWatchBroadcast(\n        path.resolve(path$1, evPath), KEY_LISTENERS, path.join(path$1, evPath)\n      );\n    }\n  };\n  try {\n    return fs.watch(path$1, options, handleEvent);\n  } catch (error) {\n    errHandler(error);\n  }\n}\n\n/**\n * Helper for passing fs_watch event data to a collection of listeners\n * @param {Path} fullPath absolute path bound to fs_watch instance\n * @param {String} type listener type\n * @param {*=} val1 arguments to be passed to listeners\n * @param {*=} val2\n * @param {*=} val3\n */\nconst fsWatchBroadcast = (fullPath, type, val1, val2, val3) => {\n  const cont = FsWatchInstances.get(fullPath);\n  if (!cont) return;\n  foreach(cont[type], (listener) => {\n    listener(val1, val2, val3);\n  });\n};\n\n/**\n * Instantiates the fs_watch interface or binds listeners\n * to an existing one covering the same file system entry\n * @param {String} path\n * @param {String} fullPath absolute path\n * @param {Object} options to be passed to fs_watch\n * @param {Object} handlers container for event listener functions\n */\nconst setFsWatchListener = (path, fullPath, options, handlers) => {\n  const {listener, errHandler, rawEmitter} = handlers;\n  let cont = FsWatchInstances.get(fullPath);\n\n  /** @type {fs.FSWatcher=} */\n  let watcher;\n  if (!options.persistent) {\n    watcher = createFsWatchInstance(\n      path, options, listener, errHandler, rawEmitter\n    );\n    return watcher.close.bind(watcher);\n  }\n  if (cont) {\n    addAndConvert(cont, KEY_LISTENERS, listener);\n    addAndConvert(cont, KEY_ERR, errHandler);\n    addAndConvert(cont, KEY_RAW, rawEmitter);\n  } else {\n    watcher = createFsWatchInstance(\n      path,\n      options,\n      fsWatchBroadcast.bind(null, fullPath, KEY_LISTENERS),\n      errHandler, // no need to use broadcast here\n      fsWatchBroadcast.bind(null, fullPath, KEY_RAW)\n    );\n    if (!watcher) return;\n    watcher.on(EV_ERROR, async (error) => {\n      const broadcastErr = fsWatchBroadcast.bind(null, fullPath, KEY_ERR);\n      cont.watcherUnusable = true; // documented since Node 10.4.1\n      // Workaround for https://github.com/joyent/node/issues/4337\n      if (isWindows && error.code === 'EPERM') {\n        try {\n          const fd = await open(path, 'r');\n          await close(fd);\n          broadcastErr(error);\n        } catch (err) {}\n      } else {\n        broadcastErr(error);\n      }\n    });\n    cont = {\n      listeners: listener,\n      errHandlers: errHandler,\n      rawEmitters: rawEmitter,\n      watcher\n    };\n    FsWatchInstances.set(fullPath, cont);\n  }\n  // const index = cont.listeners.indexOf(listener);\n\n  // removes this instance's listeners and closes the underlying fs_watch\n  // instance if there are no more listeners left\n  return () => {\n    delFromSet(cont, KEY_LISTENERS, listener);\n    delFromSet(cont, KEY_ERR, errHandler);\n    delFromSet(cont, KEY_RAW, rawEmitter);\n    if (isEmptySet(cont.listeners)) {\n      // Check to protect against issue gh-730.\n      // if (cont.watcherUnusable) {\n      cont.watcher.close();\n      // }\n      FsWatchInstances.delete(fullPath);\n      HANDLER_KEYS.forEach(clearItem(cont));\n      cont.watcher = undefined;\n      Object.freeze(cont);\n    }\n  };\n};\n\n// fs_watchFile helpers\n\n// object to hold per-process fs_watchFile instances\n// (may be shared across chokidar FSWatcher instances)\nconst FsWatchFileInstances = new Map();\n\n/**\n * Instantiates the fs_watchFile interface or binds listeners\n * to an existing one covering the same file system entry\n * @param {String} path to be watched\n * @param {String} fullPath absolute path\n * @param {Object} options options to be passed to fs_watchFile\n * @param {Object} handlers container for event listener functions\n * @returns {Function} closer\n */\nconst setFsWatchFileListener = (path, fullPath, options, handlers) => {\n  const {listener, rawEmitter} = handlers;\n  let cont = FsWatchFileInstances.get(fullPath);\n\n  const copts = cont && cont.options;\n  if (copts && (copts.persistent < options.persistent || copts.interval > options.interval)) {\n    fs.unwatchFile(fullPath);\n    cont = undefined;\n  }\n\n  /* eslint-enable no-unused-vars, prefer-destructuring */\n\n  if (cont) {\n    addAndConvert(cont, KEY_LISTENERS, listener);\n    addAndConvert(cont, KEY_RAW, rawEmitter);\n  } else {\n    // TODO\n    // listeners.add(listener);\n    // rawEmitters.add(rawEmitter);\n    cont = {\n      listeners: listener,\n      rawEmitters: rawEmitter,\n      options,\n      watcher: fs.watchFile(fullPath, options, (curr, prev) => {\n        foreach(cont.rawEmitters, (rawEmitter) => {\n          rawEmitter(EV_CHANGE, fullPath, {curr, prev});\n        });\n        const currmtime = curr.mtimeMs;\n        if (curr.size !== prev.size || currmtime > prev.mtimeMs || currmtime === 0) {\n          foreach(cont.listeners, (listener) => listener(path, curr));\n        }\n      })\n    };\n    FsWatchFileInstances.set(fullPath, cont);\n  }\n  // const index = cont.listeners.indexOf(listener);\n\n  // Removes this instance's listeners and closes the underlying fs_watchFile\n  // instance if there are no more listeners left.\n  return () => {\n    delFromSet(cont, KEY_LISTENERS, listener);\n    delFromSet(cont, KEY_RAW, rawEmitter);\n    if (isEmptySet(cont.listeners)) {\n      FsWatchFileInstances.delete(fullPath);\n      fs.unwatchFile(fullPath);\n      cont.options = cont.watcher = undefined;\n      Object.freeze(cont);\n    }\n  };\n};\n\n/**\n * @mixin\n */\nclass NodeFsHandler {\n\n/**\n * @param {import(\"../index\").FSWatcher} fsW\n */\nconstructor(fsW) {\n  this.fsw = fsW;\n  this._boundHandleError = (error) => fsW._handleError(error);\n}\n\n/**\n * Watch file for changes with fs_watchFile or fs_watch.\n * @param {String} path to file or dir\n * @param {Function} listener on fs change\n * @returns {Function} closer for the watcher instance\n */\n_watchWithNodeFs(path$1, listener) {\n  const opts = this.fsw.options;\n  const directory = path.dirname(path$1);\n  const basename = path.basename(path$1);\n  const parent = this.fsw._getWatchedDir(directory);\n  parent.add(basename);\n  const absolutePath = path.resolve(path$1);\n  const options = {persistent: opts.persistent};\n  if (!listener) listener = EMPTY_FN;\n\n  let closer;\n  if (opts.usePolling) {\n    options.interval = opts.enableBinaryInterval && isBinaryPath(basename) ?\n      opts.binaryInterval : opts.interval;\n    closer = setFsWatchFileListener(path$1, absolutePath, options, {\n      listener,\n      rawEmitter: this.fsw._emitRaw\n    });\n  } else {\n    closer = setFsWatchListener(path$1, absolutePath, options, {\n      listener,\n      errHandler: this._boundHandleError,\n      rawEmitter: this.fsw._emitRaw\n    });\n  }\n  return closer;\n}\n\n/**\n * Watch a file and emit add event if warranted.\n * @param {Path} file Path\n * @param {fs.Stats} stats result of fs_stat\n * @param {Boolean} initialAdd was the file added at watch instantiation?\n * @returns {Function} closer for the watcher instance\n */\n_handleFile(file, stats, initialAdd) {\n  if (this.fsw.closed) {\n    return;\n  }\n  const dirname = path.dirname(file);\n  const basename = path.basename(file);\n  const parent = this.fsw._getWatchedDir(dirname);\n  // stats is always present\n  let prevStats = stats;\n\n  // if the file is already being watched, do nothing\n  if (parent.has(basename)) return;\n\n  // kick off the watcher\n  const closer = this._watchWithNodeFs(file, async (path, newStats) => {\n    if (!this.fsw._throttle(THROTTLE_MODE_WATCH, file, 5)) return;\n    if (!newStats || newStats.mtimeMs === 0) {\n      try {\n        const newStats = await stat$1(file);\n        if (this.fsw.closed) return;\n        // Check that change event was not fired because of changed only accessTime.\n        const at = newStats.atimeMs;\n        const mt = newStats.mtimeMs;\n        if (!at || at <= mt || mt !== prevStats.mtimeMs) {\n          this.fsw._emit(EV_CHANGE, file, newStats);\n        }\n        prevStats = newStats;\n      } catch (error) {\n        // Fix issues where mtime is null but file is still present\n        this.fsw._remove(dirname, basename);\n      }\n    // add is about to be emitted if file not already tracked in parent\n    } else if (parent.has(basename)) {\n      // Check that change event was not fired because of changed only accessTime.\n      const at = newStats.atimeMs;\n      const mt = newStats.mtimeMs;\n      if (!at || at <= mt || mt !== prevStats.mtimeMs) {\n        this.fsw._emit(EV_CHANGE, file, newStats);\n      }\n      prevStats = newStats;\n    }\n  });\n\n  // emit an add event if we're supposed to\n  if (!(initialAdd && this.fsw.options.ignoreInitial) && this.fsw._isntIgnored(file)) {\n    if (!this.fsw._throttle(EV_ADD, file, 0)) return;\n    this.fsw._emit(EV_ADD, file, stats);\n  }\n\n  return closer;\n}\n\n/**\n * Handle symlinks encountered while reading a dir.\n * @param {Object} entry returned by readdirp\n * @param {String} directory path of dir being read\n * @param {String} path of this item\n * @param {String} item basename of this item\n * @returns {Promise<Boolean>} true if no more processing is needed for this entry.\n */\nasync _handleSymlink(entry, directory, path, item) {\n  if (this.fsw.closed) {\n    return;\n  }\n  const full = entry.fullPath;\n  const dir = this.fsw._getWatchedDir(directory);\n\n  if (!this.fsw.options.followSymlinks) {\n    // watch symlink directly (don't follow) and detect changes\n    this.fsw._incrReadyCount();\n    const linkPath = await fsrealpath(path);\n    if (this.fsw.closed) return;\n    if (dir.has(item)) {\n      if (this.fsw._symlinkPaths.get(full) !== linkPath) {\n        this.fsw._symlinkPaths.set(full, linkPath);\n        this.fsw._emit(EV_CHANGE, path, entry.stats);\n      }\n    } else {\n      dir.add(item);\n      this.fsw._symlinkPaths.set(full, linkPath);\n      this.fsw._emit(EV_ADD, path, entry.stats);\n    }\n    this.fsw._emitReady();\n    return true;\n  }\n\n  // don't follow the same symlink more than once\n  if (this.fsw._symlinkPaths.has(full)) {\n    return true;\n  }\n\n  this.fsw._symlinkPaths.set(full, true);\n}\n\n_handleRead(directory, initialAdd, wh, target, dir, depth, throttler) {\n  // Normalize the directory name on Windows\n  directory = path.join(directory, EMPTY_STR);\n\n  if (!wh.hasGlob) {\n    throttler = this.fsw._throttle('readdir', directory, 1000);\n    if (!throttler) return;\n  }\n\n  const previous = this.fsw._getWatchedDir(wh.path);\n  const current = new Set();\n\n  let stream = this.fsw._readdirp(directory, {\n    fileFilter: entry => wh.filterPath(entry),\n    directoryFilter: entry => wh.filterDir(entry),\n    depth: 0\n  }).on(STR_DATA, async (entry) => {\n    if (this.fsw.closed) {\n      stream = undefined;\n      return;\n    }\n    const item = entry.path;\n    let path$1 = path.join(directory, item);\n    current.add(item);\n\n    if (entry.stats.isSymbolicLink() && await this._handleSymlink(entry, directory, path$1, item)) {\n      return;\n    }\n\n    if (this.fsw.closed) {\n      stream = undefined;\n      return;\n    }\n    // Files that present in current directory snapshot\n    // but absent in previous are added to watch list and\n    // emit `add` event.\n    if (item === target || !target && !previous.has(item)) {\n      this.fsw._incrReadyCount();\n\n      // ensure relativeness of path is preserved in case of watcher reuse\n      path$1 = path.join(dir, path.relative(dir, path$1));\n\n      this._addToNodeFs(path$1, initialAdd, wh, depth + 1);\n    }\n  }).on(EV_ERROR, this._boundHandleError);\n\n  return new Promise(resolve =>\n    stream.once(STR_END, () => {\n      if (this.fsw.closed) {\n        stream = undefined;\n        return;\n      }\n      const wasThrottled = throttler ? throttler.clear() : false;\n\n      resolve();\n\n      // Files that absent in current directory snapshot\n      // but present in previous emit `remove` event\n      // and are removed from @watched[directory].\n      previous.getChildren().filter((item) => {\n        return item !== directory &&\n          !current.has(item) &&\n          // in case of intersecting globs;\n          // a path may have been filtered out of this readdir, but\n          // shouldn't be removed because it matches a different glob\n          (!wh.hasGlob || wh.filterPath({\n            fullPath: path.resolve(directory, item)\n          }));\n      }).forEach((item) => {\n        this.fsw._remove(directory, item);\n      });\n\n      stream = undefined;\n\n      // one more time for any missed in case changes came in extremely quickly\n      if (wasThrottled) this._handleRead(directory, false, wh, target, dir, depth, throttler);\n    })\n  );\n}\n\n/**\n * Read directory to add / remove files from `@watched` list and re-read it on change.\n * @param {String} dir fs path\n * @param {fs.Stats} stats\n * @param {Boolean} initialAdd\n * @param {Number} depth relative to user-supplied path\n * @param {String} target child path targeted for watch\n * @param {Object} wh Common watch helpers for this path\n * @param {String} realpath\n * @returns {Promise<Function>} closer for the watcher instance.\n */\nasync _handleDir(dir, stats, initialAdd, depth, target, wh, realpath) {\n  const parentDir = this.fsw._getWatchedDir(path.dirname(dir));\n  const tracked = parentDir.has(path.basename(dir));\n  if (!(initialAdd && this.fsw.options.ignoreInitial) && !target && !tracked) {\n    if (!wh.hasGlob || wh.globFilter(dir)) this.fsw._emit(EV_ADD_DIR, dir, stats);\n  }\n\n  // ensure dir is tracked (harmless if redundant)\n  parentDir.add(path.basename(dir));\n  this.fsw._getWatchedDir(dir);\n  let throttler;\n  let closer;\n\n  const oDepth = this.fsw.options.depth;\n  if ((oDepth == null || depth <= oDepth) && !this.fsw._symlinkPaths.has(realpath)) {\n    if (!target) {\n      await this._handleRead(dir, initialAdd, wh, target, dir, depth, throttler);\n      if (this.fsw.closed) return;\n    }\n\n    closer = this._watchWithNodeFs(dir, (dirPath, stats) => {\n      // if current directory is removed, do nothing\n      if (stats && stats.mtimeMs === 0) return;\n\n      this._handleRead(dirPath, false, wh, target, dir, depth, throttler);\n    });\n  }\n  return closer;\n}\n\n/**\n * Handle added file, directory, or glob pattern.\n * Delegates call to _handleFile / _handleDir after checks.\n * @param {String} path to file or ir\n * @param {Boolean} initialAdd was the file added at watch instantiation?\n * @param {Object} priorWh depth relative to user-supplied path\n * @param {Number} depth Child path actually targeted for watch\n * @param {String=} target Child path actually targeted for watch\n * @returns {Promise}\n */\nasync _addToNodeFs(path$1, initialAdd, priorWh, depth, target) {\n  const ready = this.fsw._emitReady;\n  if (this.fsw._isIgnored(path$1) || this.fsw.closed) {\n    ready();\n    return false;\n  }\n\n  const wh = this.fsw._getWatchHelpers(path$1, depth);\n  if (!wh.hasGlob && priorWh) {\n    wh.hasGlob = priorWh.hasGlob;\n    wh.globFilter = priorWh.globFilter;\n    wh.filterPath = entry => priorWh.filterPath(entry);\n    wh.filterDir = entry => priorWh.filterDir(entry);\n  }\n\n  // evaluate what is at the path we're being asked to watch\n  try {\n    const stats = await statMethods[wh.statMethod](wh.watchPath);\n    if (this.fsw.closed) return;\n    if (this.fsw._isIgnored(wh.watchPath, stats)) {\n      ready();\n      return false;\n    }\n\n    const follow = this.fsw.options.followSymlinks && !path$1.includes(STAR$1) && !path$1.includes(BRACE_START);\n    let closer;\n    if (stats.isDirectory()) {\n      const targetPath = follow ? await fsrealpath(path$1) : path$1;\n      if (this.fsw.closed) return;\n      closer = await this._handleDir(wh.watchPath, stats, initialAdd, depth, target, wh, targetPath);\n      if (this.fsw.closed) return;\n      // preserve this symlink's target path\n      if (path$1 !== targetPath && targetPath !== undefined) {\n        this.fsw._symlinkPaths.set(targetPath, true);\n      }\n    } else if (stats.isSymbolicLink()) {\n      const targetPath = follow ? await fsrealpath(path$1) : path$1;\n      if (this.fsw.closed) return;\n      const parent = path.dirname(wh.watchPath);\n      this.fsw._getWatchedDir(parent).add(wh.watchPath);\n      this.fsw._emit(EV_ADD, wh.watchPath, stats);\n      closer = await this._handleDir(parent, stats, initialAdd, depth, path$1, wh, targetPath);\n      if (this.fsw.closed) return;\n\n      // preserve this symlink's target path\n      if (targetPath !== undefined) {\n        this.fsw._symlinkPaths.set(path.resolve(path$1), targetPath);\n      }\n    } else {\n      closer = this._handleFile(wh.watchPath, stats, initialAdd);\n    }\n    ready();\n\n    this.fsw._addPathCloser(path$1, closer);\n    return false;\n\n  } catch (error) {\n    if (this.fsw._handleError(error)) {\n      ready();\n      return path$1;\n    }\n  }\n}\n\n}\n\nvar nodefsHandler = NodeFsHandler;\n\nvar require$$1 = getCjsExportFromNamespace(fseventsImporter);\n\nconst { promisify: promisify$2 } = util;\n\nlet fsevents;\ntry {\n  fsevents = require$$1.getFsEvents();\n} catch (error) {\n  if (process.env.CHOKIDAR_PRINT_FSEVENTS_REQUIRE_ERROR) console.error(error);\n}\n\nif (fsevents) {\n  // TODO: real check\n  const mtch = process.version.match(/v(\\d+)\\.(\\d+)/);\n  if (mtch && mtch[1] && mtch[2]) {\n    const maj = Number.parseInt(mtch[1], 10);\n    const min = Number.parseInt(mtch[2], 10);\n    if (maj === 8 && min < 16) {\n      fsevents = undefined;\n    }\n  }\n}\n\nconst {\n  EV_ADD: EV_ADD$1,\n  EV_CHANGE: EV_CHANGE$1,\n  EV_ADD_DIR: EV_ADD_DIR$1,\n  EV_UNLINK,\n  EV_ERROR: EV_ERROR$1,\n  STR_DATA: STR_DATA$1,\n  STR_END: STR_END$1,\n  FSEVENT_CREATED,\n  FSEVENT_MODIFIED,\n  FSEVENT_DELETED,\n  FSEVENT_MOVED,\n  // FSEVENT_CLONED,\n  FSEVENT_UNKNOWN,\n  FSEVENT_TYPE_FILE,\n  FSEVENT_TYPE_DIRECTORY,\n  FSEVENT_TYPE_SYMLINK,\n\n  ROOT_GLOBSTAR,\n  DIR_SUFFIX,\n  DOT_SLASH,\n  FUNCTION_TYPE,\n  EMPTY_FN: EMPTY_FN$1,\n  IDENTITY_FN\n} = constants$2;\n\nconst Depth = (value) => isNaN(value) ? {} : {depth: value};\n\nconst stat$2 = promisify$2(fs.stat);\nconst lstat$2 = promisify$2(fs.lstat);\nconst realpath$1 = promisify$2(fs.realpath);\n\nconst statMethods$1 = { stat: stat$2, lstat: lstat$2 };\n\n/**\n * @typedef {String} Path\n */\n\n/**\n * @typedef {Object} FsEventsWatchContainer\n * @property {Set<Function>} listeners\n * @property {Function} rawEmitter\n * @property {{stop: Function}} watcher\n */\n\n// fsevents instance helper functions\n/**\n * Object to hold per-process fsevents instances (may be shared across chokidar FSWatcher instances)\n * @type {Map<Path,FsEventsWatchContainer>}\n */\nconst FSEventsWatchers = new Map();\n\n// Threshold of duplicate path prefixes at which to start\n// consolidating going forward\nconst consolidateThreshhold = 10;\n\nconst wrongEventFlags = new Set([\n  69888, 70400, 71424, 72704, 73472, 131328, 131840, 262912\n]);\n\n/**\n * Instantiates the fsevents interface\n * @param {Path} path path to be watched\n * @param {Function} callback called when fsevents is bound and ready\n * @returns {{stop: Function}} new fsevents instance\n */\nconst createFSEventsInstance = (path, callback) => {\n  const stop = fsevents.watch(path, callback);\n  return {stop};\n};\n\n/**\n * Instantiates the fsevents interface or binds listeners to an existing one covering\n * the same file tree.\n * @param {Path} path           - to be watched\n * @param {Path} realPath       - real path for symlinks\n * @param {Function} listener   - called when fsevents emits events\n * @param {Function} rawEmitter - passes data to listeners of the 'raw' event\n * @returns {Function} closer\n */\nfunction setFSEventsListener(path$1, realPath, listener, rawEmitter, fsw) {\n  let watchPath = path.extname(path$1) ? path.dirname(path$1) : path$1;\n  const parentPath = path.dirname(watchPath);\n  let cont = FSEventsWatchers.get(watchPath);\n\n  // If we've accumulated a substantial number of paths that\n  // could have been consolidated by watching one directory\n  // above the current one, create a watcher on the parent\n  // path instead, so that we do consolidate going forward.\n  if (couldConsolidate(parentPath)) {\n    watchPath = parentPath;\n  }\n\n  const resolvedPath = path.resolve(path$1);\n  const hasSymlink = resolvedPath !== realPath;\n\n  const filteredListener = (fullPath, flags, info) => {\n    if (hasSymlink) fullPath = fullPath.replace(realPath, resolvedPath);\n    if (\n      fullPath === resolvedPath ||\n      !fullPath.indexOf(resolvedPath + path.sep)\n    ) listener(fullPath, flags, info);\n  };\n\n  // check if there is already a watcher on a parent path\n  // modifies `watchPath` to the parent path when it finds a match\n  let watchedParent = false;\n  for (const watchedPath of FSEventsWatchers.keys()) {\n    if (realPath.indexOf(path.resolve(watchedPath) + path.sep) === 0) {\n      watchPath = watchedPath;\n      cont = FSEventsWatchers.get(watchPath);\n      watchedParent = true;\n      break;\n    }\n  }\n\n  if (cont || watchedParent) {\n    cont.listeners.add(filteredListener);\n  } else {\n    cont = {\n      listeners: new Set([filteredListener]),\n      rawEmitter,\n      watcher: createFSEventsInstance(watchPath, (fullPath, flags) => {\n        if (fsw.closed) return;\n        const info = fsevents.getInfo(fullPath, flags);\n        cont.listeners.forEach(list => {\n          list(fullPath, flags, info);\n        });\n\n        cont.rawEmitter(info.event, fullPath, info);\n      })\n    };\n    FSEventsWatchers.set(watchPath, cont);\n  }\n\n  // removes this instance's listeners and closes the underlying fsevents\n  // instance if there are no more listeners left\n  return () => {\n    const lst = cont.listeners;\n\n    lst.delete(filteredListener);\n    if (!lst.size) {\n      FSEventsWatchers.delete(watchPath);\n      if (cont.watcher) return cont.watcher.stop().then(() => {\n        cont.rawEmitter = cont.watcher = undefined;\n        Object.freeze(cont);\n      });\n    }\n  };\n}\n\n// Decide whether or not we should start a new higher-level\n// parent watcher\nconst couldConsolidate = (path) => {\n  let count = 0;\n  for (const watchPath of FSEventsWatchers.keys()) {\n    if (watchPath.indexOf(path) === 0) {\n      count++;\n      if (count >= consolidateThreshhold) {\n        return true;\n      }\n    }\n  }\n\n  return false;\n};\n\n// returns boolean indicating whether fsevents can be used\nconst canUse = () => fsevents && FSEventsWatchers.size < 128;\n\n// determines subdirectory traversal levels from root to path\nconst calcDepth = (path$1, root) => {\n  let i = 0;\n  while (!path$1.indexOf(root) && (path$1 = path.dirname(path$1)) !== root) i++;\n  return i;\n};\n\n// returns boolean indicating whether the fsevents' event info has the same type\n// as the one returned by fs.stat\nconst sameTypes = (info, stats) => (\n  info.type === FSEVENT_TYPE_DIRECTORY && stats.isDirectory() ||\n  info.type === FSEVENT_TYPE_SYMLINK && stats.isSymbolicLink() ||\n  info.type === FSEVENT_TYPE_FILE && stats.isFile()\n);\n\n/**\n * @mixin\n */\nclass FsEventsHandler {\n\n/**\n * @param {import('../index').FSWatcher} fsw\n */\nconstructor(fsw) {\n  this.fsw = fsw;\n}\ncheckIgnored(path, stats) {\n  const ipaths = this.fsw._ignoredPaths;\n  if (this.fsw._isIgnored(path, stats)) {\n    ipaths.add(path);\n    if (stats && stats.isDirectory()) {\n      ipaths.add(path + ROOT_GLOBSTAR);\n    }\n    return true;\n  }\n\n  ipaths.delete(path);\n  ipaths.delete(path + ROOT_GLOBSTAR);\n}\n\naddOrChange(path, fullPath, realPath, parent, watchedDir, item, info, opts) {\n  const event = watchedDir.has(item) ? EV_CHANGE$1 : EV_ADD$1;\n  this.handleEvent(event, path, fullPath, realPath, parent, watchedDir, item, info, opts);\n}\n\nasync checkExists(path, fullPath, realPath, parent, watchedDir, item, info, opts) {\n  try {\n    const stats = await stat$2(path);\n    if (this.fsw.closed) return;\n    if (this.fsw.closed) return;\n    if (sameTypes(info, stats)) {\n      this.addOrChange(path, fullPath, realPath, parent, watchedDir, item, info, opts);\n    } else {\n      this.handleEvent(EV_UNLINK, path, fullPath, realPath, parent, watchedDir, item, info, opts);\n    }\n  } catch (error) {\n    if (error.code === 'EACCES') {\n      this.addOrChange(path, fullPath, realPath, parent, watchedDir, item, info, opts);\n    } else {\n      this.handleEvent(EV_UNLINK, path, fullPath, realPath, parent, watchedDir, item, info, opts);\n    }\n  }\n}\n\nhandleEvent(event, path, fullPath, realPath, parent, watchedDir, item, info, opts) {\n  if (this.fsw.closed || this.checkIgnored(path)) return;\n\n  if (event === EV_UNLINK) {\n    const isDirectory = info.type === FSEVENT_TYPE_DIRECTORY;\n    // suppress unlink events on never before seen files\n    if (isDirectory || watchedDir.has(item)) {\n      this.fsw._remove(parent, item, isDirectory);\n    }\n  } else {\n    if (event === EV_ADD$1) {\n      // track new directories\n      if (info.type === FSEVENT_TYPE_DIRECTORY) this.fsw._getWatchedDir(path);\n\n      if (info.type === FSEVENT_TYPE_SYMLINK && opts.followSymlinks) {\n        // push symlinks back to the top of the stack to get handled\n        const curDepth = opts.depth === undefined ?\n          undefined : calcDepth(fullPath, realPath) + 1;\n        return this._addToFsEvents(path, false, true, curDepth);\n      }\n\n      // track new paths\n      // (other than symlinks being followed, which will be tracked soon)\n      this.fsw._getWatchedDir(parent).add(item);\n    }\n    /**\n     * @type {'add'|'addDir'|'unlink'|'unlinkDir'}\n     */\n    const eventName = info.type === FSEVENT_TYPE_DIRECTORY ? event + DIR_SUFFIX : event;\n    this.fsw._emit(eventName, path);\n    if (eventName === EV_ADD_DIR$1) this._addToFsEvents(path, false, true);\n  }\n}\n\n/**\n * Handle symlinks encountered during directory scan\n * @param {String} watchPath  - file/dir path to be watched with fsevents\n * @param {String} realPath   - real path (in case of symlinks)\n * @param {Function} transform  - path transformer\n * @param {Function} globFilter - path filter in case a glob pattern was provided\n * @returns {Function} closer for the watcher instance\n*/\n_watchWithFsEvents(watchPath, realPath, transform, globFilter) {\n  if (this.fsw.closed) return;\n  if (this.fsw._isIgnored(watchPath)) return;\n  const opts = this.fsw.options;\n  const watchCallback = async (fullPath, flags, info) => {\n    if (this.fsw.closed) return;\n    if (\n      opts.depth !== undefined &&\n      calcDepth(fullPath, realPath) > opts.depth\n    ) return;\n    const path$1 = transform(path.join(\n      watchPath, path.relative(watchPath, fullPath)\n    ));\n    if (globFilter && !globFilter(path$1)) return;\n    // ensure directories are tracked\n    const parent = path.dirname(path$1);\n    const item = path.basename(path$1);\n    const watchedDir = this.fsw._getWatchedDir(\n      info.type === FSEVENT_TYPE_DIRECTORY ? path$1 : parent\n    );\n\n    // correct for wrong events emitted\n    if (wrongEventFlags.has(flags) || info.event === FSEVENT_UNKNOWN) {\n      if (typeof opts.ignored === FUNCTION_TYPE) {\n        let stats;\n        try {\n          stats = await stat$2(path$1);\n        } catch (error) {}\n        if (this.fsw.closed) return;\n        if (this.checkIgnored(path$1, stats)) return;\n        if (sameTypes(info, stats)) {\n          this.addOrChange(path$1, fullPath, realPath, parent, watchedDir, item, info, opts);\n        } else {\n          this.handleEvent(EV_UNLINK, path$1, fullPath, realPath, parent, watchedDir, item, info, opts);\n        }\n      } else {\n        this.checkExists(path$1, fullPath, realPath, parent, watchedDir, item, info, opts);\n      }\n    } else {\n      switch (info.event) {\n      case FSEVENT_CREATED:\n      case FSEVENT_MODIFIED:\n        return this.addOrChange(path$1, fullPath, realPath, parent, watchedDir, item, info, opts);\n      case FSEVENT_DELETED:\n      case FSEVENT_MOVED:\n        return this.checkExists(path$1, fullPath, realPath, parent, watchedDir, item, info, opts);\n      }\n    }\n  };\n\n  const closer = setFSEventsListener(\n    watchPath,\n    realPath,\n    watchCallback,\n    this.fsw._emitRaw,\n    this.fsw\n  );\n\n  this.fsw._emitReady();\n  return closer;\n}\n\n/**\n * Handle symlinks encountered during directory scan\n * @param {String} linkPath path to symlink\n * @param {String} fullPath absolute path to the symlink\n * @param {Function} transform pre-existing path transformer\n * @param {Number} curDepth level of subdirectories traversed to where symlink is\n * @returns {Promise<void>}\n */\nasync _handleFsEventsSymlink(linkPath, fullPath, transform, curDepth) {\n  // don't follow the same symlink more than once\n  if (this.fsw.closed || this.fsw._symlinkPaths.has(fullPath)) return;\n\n  this.fsw._symlinkPaths.set(fullPath, true);\n  this.fsw._incrReadyCount();\n\n  try {\n    const linkTarget = await realpath$1(linkPath);\n    if (this.fsw.closed) return;\n    if (this.fsw._isIgnored(linkTarget)) {\n      return this.fsw._emitReady();\n    }\n\n    this.fsw._incrReadyCount();\n\n    // add the linkTarget for watching with a wrapper for transform\n    // that causes emitted paths to incorporate the link's path\n    this._addToFsEvents(linkTarget || linkPath, (path$1) => {\n      let aliasedPath = linkPath;\n      if (linkTarget && linkTarget !== DOT_SLASH) {\n        aliasedPath = path$1.replace(linkTarget, linkPath);\n      } else if (path$1 !== DOT_SLASH) {\n        aliasedPath = path.join(linkPath, path$1);\n      }\n      return transform(aliasedPath);\n    }, false, curDepth);\n  } catch(error) {\n    if (this.fsw._handleError(error)) {\n      return this.fsw._emitReady();\n    }\n  }\n}\n\n/**\n *\n * @param {Path} newPath\n * @param {fs.Stats} stats\n */\nemitAdd(newPath, stats, processPath, opts, forceAdd) {\n  const pp = processPath(newPath);\n  const isDir = stats.isDirectory();\n  const dirObj = this.fsw._getWatchedDir(path.dirname(pp));\n  const base = path.basename(pp);\n\n  // ensure empty dirs get tracked\n  if (isDir) this.fsw._getWatchedDir(pp);\n  if (dirObj.has(base)) return;\n  dirObj.add(base);\n\n  if (!opts.ignoreInitial || forceAdd === true) {\n    this.fsw._emit(isDir ? EV_ADD_DIR$1 : EV_ADD$1, pp, stats);\n  }\n}\n\ninitWatch(realPath, path$1, wh, processPath) {\n  if (this.fsw.closed) return;\n  const closer = this._watchWithFsEvents(\n    wh.watchPath,\n    path.resolve(realPath || wh.watchPath),\n    processPath,\n    wh.globFilter\n  );\n  this.fsw._addPathCloser(path$1, closer);\n}\n\n/**\n * Handle added path with fsevents\n * @param {String} path file/dir path or glob pattern\n * @param {Function|Boolean=} transform converts working path to what the user expects\n * @param {Boolean=} forceAdd ensure add is emitted\n * @param {Number=} priorDepth Level of subdirectories already traversed.\n * @returns {Promise<void>}\n */\nasync _addToFsEvents(path$1, transform, forceAdd, priorDepth) {\n  if (this.fsw.closed) {\n    return;\n  }\n  const opts = this.fsw.options;\n  const processPath = typeof transform === FUNCTION_TYPE ? transform : IDENTITY_FN;\n\n  const wh = this.fsw._getWatchHelpers(path$1);\n\n  // evaluate what is at the path we're being asked to watch\n  try {\n    const stats = await statMethods$1[wh.statMethod](wh.watchPath);\n    if (this.fsw.closed) return;\n    if (this.fsw._isIgnored(wh.watchPath, stats)) {\n      throw null;\n    }\n    if (stats.isDirectory()) {\n      // emit addDir unless this is a glob parent\n      if (!wh.globFilter) this.emitAdd(processPath(path$1), stats, processPath, opts, forceAdd);\n\n      // don't recurse further if it would exceed depth setting\n      if (priorDepth && priorDepth > opts.depth) return;\n\n      // scan the contents of the dir\n      this.fsw._readdirp(wh.watchPath, {\n        fileFilter: entry => wh.filterPath(entry),\n        directoryFilter: entry => wh.filterDir(entry),\n        ...Depth(opts.depth - (priorDepth || 0))\n      }).on(STR_DATA$1, (entry) => {\n        // need to check filterPath on dirs b/c filterDir is less restrictive\n        if (this.fsw.closed) {\n          return;\n        }\n        if (entry.stats.isDirectory() && !wh.filterPath(entry)) return;\n\n        const joinedPath = path.join(wh.watchPath, entry.path);\n        const {fullPath} = entry;\n\n        if (wh.followSymlinks && entry.stats.isSymbolicLink()) {\n          // preserve the current depth here since it can't be derived from\n          // real paths past the symlink\n          const curDepth = opts.depth === undefined ?\n            undefined : calcDepth(joinedPath, path.resolve(wh.watchPath)) + 1;\n\n          this._handleFsEventsSymlink(joinedPath, fullPath, processPath, curDepth);\n        } else {\n          this.emitAdd(joinedPath, entry.stats, processPath, opts, forceAdd);\n        }\n      }).on(EV_ERROR$1, EMPTY_FN$1).on(STR_END$1, () => {\n        this.fsw._emitReady();\n      });\n    } else {\n      this.emitAdd(wh.watchPath, stats, processPath, opts, forceAdd);\n      this.fsw._emitReady();\n    }\n  } catch (error) {\n    if (!error || this.fsw._handleError(error)) {\n      // TODO: Strange thing: \"should not choke on an ignored watch path\" will be failed without 2 ready calls -__-\n      this.fsw._emitReady();\n      this.fsw._emitReady();\n    }\n  }\n\n  if (opts.persistent && forceAdd !== true) {\n    if (typeof transform === FUNCTION_TYPE) {\n      // realpath has already been resolved\n      this.initWatch(undefined, path$1, wh, processPath);\n    } else {\n      let realPath;\n      try {\n        realPath = await realpath$1(wh.watchPath);\n      } catch (e) {}\n      this.initWatch(realPath, path$1, wh, processPath);\n    }\n  }\n}\n\n}\n\nvar fseventsHandler = FsEventsHandler;\nvar canUse_1 = canUse;\nfseventsHandler.canUse = canUse_1;\n\nconst { EventEmitter } = events;\n\n\nconst { promisify: promisify$3 } = util;\n\nconst anymatch = anymatch_1.default;\n\n\n\n\n\n\n\nconst {\n  EV_ALL,\n  EV_READY,\n  EV_ADD: EV_ADD$2,\n  EV_CHANGE: EV_CHANGE$2,\n  EV_UNLINK: EV_UNLINK$1,\n  EV_ADD_DIR: EV_ADD_DIR$2,\n  EV_UNLINK_DIR,\n  EV_RAW,\n  EV_ERROR: EV_ERROR$2,\n\n  STR_CLOSE,\n  STR_END: STR_END$2,\n\n  BACK_SLASH_RE,\n  DOUBLE_SLASH_RE,\n  SLASH_OR_BACK_SLASH_RE,\n  DOT_RE,\n  REPLACER_RE,\n\n  SLASH,\n  BRACE_START: BRACE_START$1,\n  BANG: BANG$1,\n  ONE_DOT,\n  TWO_DOTS,\n  GLOBSTAR,\n  SLASH_GLOBSTAR,\n  ANYMATCH_OPTS,\n  STRING_TYPE,\n  FUNCTION_TYPE: FUNCTION_TYPE$1,\n  EMPTY_STR: EMPTY_STR$1,\n  EMPTY_FN: EMPTY_FN$2,\n\n  isWindows: isWindows$1,\n  isMacos\n} = constants$2;\n\nconst stat$3 = promisify$3(fs.stat);\nconst readdir$1 = promisify$3(fs.readdir);\n\n/**\n * @typedef {String} Path\n * @typedef {'all'|'add'|'addDir'|'change'|'unlink'|'unlinkDir'|'raw'|'error'|'ready'} EventName\n * @typedef {'readdir'|'watch'|'add'|'remove'|'change'} ThrottleType\n */\n\n/**\n *\n * @typedef {Object} WatchHelpers\n * @property {Boolean} followSymlinks\n * @property {'stat'|'lstat'} statMethod\n * @property {Path} path\n * @property {Path} watchPath\n * @property {Function} entryPath\n * @property {Boolean} hasGlob\n * @property {Object} globFilter\n * @property {Function} filterPath\n * @property {Function} filterDir\n */\n\nconst arrify = (value = []) => Array.isArray(value) ? value : [value];\nconst flatten = (list, result = []) => {\n  list.forEach(item => {\n    if (Array.isArray(item)) {\n      flatten(item, result);\n    } else {\n      result.push(item);\n    }\n  });\n  return result;\n};\n\nconst unifyPaths = (paths_) => {\n  /**\n   * @type {Array<String>}\n   */\n  const paths = flatten(arrify(paths_));\n  if (!paths.every(p => typeof p === STRING_TYPE)) {\n    throw new TypeError(`Non-string provided as watch path: ${paths}`);\n  }\n  return paths.map(normalizePathToUnix);\n};\n\nconst toUnix = (string) => {\n  let str = string.replace(BACK_SLASH_RE, SLASH);\n  while (str.match(DOUBLE_SLASH_RE)) {\n    str = str.replace(DOUBLE_SLASH_RE, SLASH);\n  }\n  return str;\n};\n\n// Our version of upath.normalize\n// TODO: this is not equal to path-normalize module - investigate why\nconst normalizePathToUnix = (path$1) => toUnix(path.normalize(toUnix(path$1)));\n\nconst normalizeIgnored = (cwd = EMPTY_STR$1) => (path$1) => {\n  if (typeof path$1 !== STRING_TYPE) return path$1;\n  return normalizePathToUnix(path.isAbsolute(path$1) ? path$1 : path.join(cwd, path$1));\n};\n\nconst getAbsolutePath = (path$1, cwd) => {\n  if (path.isAbsolute(path$1)) {\n    return path$1;\n  }\n  if (path$1.startsWith(BANG$1)) {\n    return BANG$1 + path.join(cwd, path$1.slice(1));\n  }\n  return path.join(cwd, path$1);\n};\n\nconst undef = (opts, key) => opts[key] === undefined;\n\n/**\n * Directory entry.\n * @property {Path} path\n * @property {Set<Path>} items\n */\nclass DirEntry {\n  /**\n   * @param {Path} dir\n   * @param {Function} removeWatcher\n   */\n  constructor(dir, removeWatcher) {\n    this.path = dir;\n    this._removeWatcher = removeWatcher;\n    /** @type {Set<Path>} */\n    this.items = new Set();\n  }\n\n  add(item) {\n    const {items} = this;\n    if (!items) return;\n    if (item !== ONE_DOT && item !== TWO_DOTS) items.add(item);\n  }\n\n  async remove(item) {\n    const {items} = this;\n    if (!items) return;\n    items.delete(item);\n    if (items.size > 0) return;\n\n    const dir = this.path;\n    try {\n      await readdir$1(dir);\n    } catch (err) {\n      if (this._removeWatcher) {\n        this._removeWatcher(path.dirname(dir), path.basename(dir));\n      }\n    }\n  }\n\n  has(item) {\n    const {items} = this;\n    if (!items) return;\n    return items.has(item);\n  }\n\n  /**\n   * @returns {Array<String>}\n   */\n  getChildren() {\n    const {items} = this;\n    if (!items) return;\n    return [...items.values()];\n  }\n\n  dispose() {\n    this.items.clear();\n    delete this.path;\n    delete this._removeWatcher;\n    delete this.items;\n    Object.freeze(this);\n  }\n}\n\nconst STAT_METHOD_F = 'stat';\nconst STAT_METHOD_L = 'lstat';\nclass WatchHelper {\n  constructor(path$1, watchPath, follow, fsw) {\n    this.fsw = fsw;\n    this.path = path$1 = path$1.replace(REPLACER_RE, EMPTY_STR$1);\n    this.watchPath = watchPath;\n    this.fullWatchPath = path.resolve(watchPath);\n    this.hasGlob = watchPath !== path$1;\n    /** @type {object|boolean} */\n    if (path$1 === EMPTY_STR$1) this.hasGlob = false;\n    this.globSymlink = this.hasGlob && follow ? undefined : false;\n    this.globFilter = this.hasGlob ? anymatch(path$1, undefined, ANYMATCH_OPTS) : false;\n    this.dirParts = this.getDirParts(path$1);\n    this.dirParts.forEach((parts) => {\n      if (parts.length > 1) parts.pop();\n    });\n    this.followSymlinks = follow;\n    this.statMethod = follow ? STAT_METHOD_F : STAT_METHOD_L;\n  }\n\n  checkGlobSymlink(entry) {\n    // only need to resolve once\n    // first entry should always have entry.parentDir === EMPTY_STR\n    if (this.globSymlink === undefined) {\n      this.globSymlink = entry.fullParentDir === this.fullWatchPath ?\n        false : {realPath: entry.fullParentDir, linkPath: this.fullWatchPath};\n    }\n\n    if (this.globSymlink) {\n      return entry.fullPath.replace(this.globSymlink.realPath, this.globSymlink.linkPath);\n    }\n\n    return entry.fullPath;\n  }\n\n  entryPath(entry) {\n    return path.join(this.watchPath,\n      path.relative(this.watchPath, this.checkGlobSymlink(entry))\n    );\n  }\n\n  filterPath(entry) {\n    const {stats} = entry;\n    if (stats && stats.isSymbolicLink()) return this.filterDir(entry);\n    const resolvedPath = this.entryPath(entry);\n    const matchesGlob = this.hasGlob && typeof this.globFilter === FUNCTION_TYPE$1 ?\n      this.globFilter(resolvedPath) : true;\n    return matchesGlob &&\n      this.fsw._isntIgnored(resolvedPath, stats) &&\n      this.fsw._hasReadPermissions(stats);\n  }\n\n  getDirParts(path$1) {\n    if (!this.hasGlob) return [];\n    const parts = [];\n    const expandedPath = path$1.includes(BRACE_START$1) ? braces_1.expand(path$1) : [path$1];\n    expandedPath.forEach((path$1) => {\n      parts.push(path.relative(this.watchPath, path$1).split(SLASH_OR_BACK_SLASH_RE));\n    });\n    return parts;\n  }\n\n  filterDir(entry) {\n    if (this.hasGlob) {\n      const entryParts = this.getDirParts(this.checkGlobSymlink(entry));\n      let globstar = false;\n      this.unmatchedGlob = !this.dirParts.some((parts) => {\n        return parts.every((part, i) => {\n          if (part === GLOBSTAR) globstar = true;\n          return globstar || !entryParts[0][i] || anymatch(part, entryParts[0][i], ANYMATCH_OPTS);\n        });\n      });\n    }\n    return !this.unmatchedGlob && this.fsw._isntIgnored(this.entryPath(entry), entry.stats);\n  }\n}\n\n/**\n * Watches files & directories for changes. Emitted events:\n * `add`, `addDir`, `change`, `unlink`, `unlinkDir`, `all`, `error`\n *\n *     new FSWatcher()\n *       .add(directories)\n *       .on('add', path => log('File', path, 'was added'))\n */\nclass FSWatcher extends EventEmitter {\n// Not indenting methods for history sake; for now.\nconstructor(_opts) {\n  super();\n\n  const opts = {};\n  if (_opts) Object.assign(opts, _opts); // for frozen objects\n\n  /** @type {Map<String, DirEntry>} */\n  this._watched = new Map();\n  /** @type {Map<String, Array>} */\n  this._closers = new Map();\n  /** @type {Set<String>} */\n  this._ignoredPaths = new Set();\n\n  /** @type {Map<ThrottleType, Map>} */\n  this._throttled = new Map();\n\n  /** @type {Map<Path, String|Boolean>} */\n  this._symlinkPaths = new Map();\n\n  this._streams = new Set();\n  this.closed = false;\n\n  // Set up default options.\n  if (undef(opts, 'persistent')) opts.persistent = true;\n  if (undef(opts, 'ignoreInitial')) opts.ignoreInitial = false;\n  if (undef(opts, 'ignorePermissionErrors')) opts.ignorePermissionErrors = false;\n  if (undef(opts, 'interval')) opts.interval = 100;\n  if (undef(opts, 'binaryInterval')) opts.binaryInterval = 300;\n  if (undef(opts, 'disableGlobbing')) opts.disableGlobbing = false;\n  opts.enableBinaryInterval = opts.binaryInterval !== opts.interval;\n\n  // Enable fsevents on OS X when polling isn't explicitly enabled.\n  if (undef(opts, 'useFsEvents')) opts.useFsEvents = !opts.usePolling;\n\n  // If we can't use fsevents, ensure the options reflect it's disabled.\n  const canUseFsEvents = fseventsHandler.canUse();\n  if (!canUseFsEvents) opts.useFsEvents = false;\n\n  // Use polling on Mac if not using fsevents.\n  // Other platforms use non-polling fs_watch.\n  if (undef(opts, 'usePolling') && !opts.useFsEvents) {\n    opts.usePolling = isMacos;\n  }\n\n  // Global override (useful for end-developers that need to force polling for all\n  // instances of chokidar, regardless of usage/dependency depth)\n  const envPoll = process.env.CHOKIDAR_USEPOLLING;\n  if (envPoll !== undefined) {\n    const envLower = envPoll.toLowerCase();\n\n    if (envLower === 'false' || envLower === '0') {\n      opts.usePolling = false;\n    } else if (envLower === 'true' || envLower === '1') {\n      opts.usePolling = true;\n    } else {\n      opts.usePolling = !!envLower;\n    }\n  }\n  const envInterval = process.env.CHOKIDAR_INTERVAL;\n  if (envInterval) {\n    opts.interval = Number.parseInt(envInterval, 10);\n  }\n\n  // Editor atomic write normalization enabled by default with fs.watch\n  if (undef(opts, 'atomic')) opts.atomic = !opts.usePolling && !opts.useFsEvents;\n  if (opts.atomic) this._pendingUnlinks = new Map();\n\n  if (undef(opts, 'followSymlinks')) opts.followSymlinks = true;\n\n  if (undef(opts, 'awaitWriteFinish')) opts.awaitWriteFinish = false;\n  if (opts.awaitWriteFinish === true) opts.awaitWriteFinish = {};\n  const awf = opts.awaitWriteFinish;\n  if (awf) {\n    if (!awf.stabilityThreshold) awf.stabilityThreshold = 2000;\n    if (!awf.pollInterval) awf.pollInterval = 100;\n    this._pendingWrites = new Map();\n  }\n  if (opts.ignored) opts.ignored = arrify(opts.ignored);\n\n  let readyCalls = 0;\n  this._emitReady = () => {\n    readyCalls++;\n    if (readyCalls >= this._readyCount) {\n      this._emitReady = EMPTY_FN$2;\n      this._readyEmitted = true;\n      // use process.nextTick to allow time for listener to be bound\n      process.nextTick(() => this.emit(EV_READY));\n    }\n  };\n  this._emitRaw = (...args) => this.emit(EV_RAW, ...args);\n  this._readyEmitted = false;\n  this.options = opts;\n\n  // Initialize with proper watcher.\n  if (opts.useFsEvents) {\n    this._fsEventsHandler = new fseventsHandler(this);\n  } else {\n    this._nodeFsHandler = new nodefsHandler(this);\n  }\n\n  // You’re frozen when your heart’s not open.\n  Object.freeze(opts);\n}\n\n// Public methods\n\n/**\n * Adds paths to be watched on an existing FSWatcher instance\n * @param {Path|Array<Path>} paths_\n * @param {String=} _origAdd private; for handling non-existent paths to be watched\n * @param {Boolean=} _internal private; indicates a non-user add\n * @returns {FSWatcher} for chaining\n */\nadd(paths_, _origAdd, _internal) {\n  const {cwd, disableGlobbing} = this.options;\n  this.closed = false;\n  let paths = unifyPaths(paths_);\n  if (cwd) {\n    paths = paths.map((path) => {\n      const absPath = getAbsolutePath(path, cwd);\n\n      // Check `path` instead of `absPath` because the cwd portion can't be a glob\n      if (disableGlobbing || !isGlob(path)) {\n        return absPath;\n      }\n      return normalizePath(absPath);\n    });\n  }\n\n  // set aside negated glob strings\n  paths = paths.filter((path) => {\n    if (path.startsWith(BANG$1)) {\n      this._ignoredPaths.add(path.slice(1));\n      return false;\n    }\n\n    // if a path is being added that was previously ignored, stop ignoring it\n    this._ignoredPaths.delete(path);\n    this._ignoredPaths.delete(path + SLASH_GLOBSTAR);\n\n    // reset the cached userIgnored anymatch fn\n    // to make ignoredPaths changes effective\n    this._userIgnored = undefined;\n\n    return true;\n  });\n\n  if (this.options.useFsEvents && this._fsEventsHandler) {\n    if (!this._readyCount) this._readyCount = paths.length;\n    if (this.options.persistent) this._readyCount *= 2;\n    paths.forEach((path) => this._fsEventsHandler._addToFsEvents(path));\n  } else {\n    if (!this._readyCount) this._readyCount = 0;\n    this._readyCount += paths.length;\n    Promise.all(\n      paths.map(async path => {\n        const res = await this._nodeFsHandler._addToNodeFs(path, !_internal, 0, 0, _origAdd);\n        if (res) this._emitReady();\n        return res;\n      })\n    ).then(results => {\n      if (this.closed) return;\n      results.filter(item => item).forEach(item => {\n        this.add(path.dirname(item), path.basename(_origAdd || item));\n      });\n    });\n  }\n\n  return this;\n}\n\n/**\n * Close watchers or start ignoring events from specified paths.\n * @param {Path|Array<Path>} paths_ - string or array of strings, file/directory paths and/or globs\n * @returns {FSWatcher} for chaining\n*/\nunwatch(paths_) {\n  if (this.closed) return this;\n  const paths = unifyPaths(paths_);\n  const {cwd} = this.options;\n\n  paths.forEach((path$1) => {\n    // convert to absolute path unless relative path already matches\n    if (!path.isAbsolute(path$1) && !this._closers.has(path$1)) {\n      if (cwd) path$1 = path.join(cwd, path$1);\n      path$1 = path.resolve(path$1);\n    }\n\n    this._closePath(path$1);\n\n    this._ignoredPaths.add(path$1);\n    if (this._watched.has(path$1)) {\n      this._ignoredPaths.add(path$1 + SLASH_GLOBSTAR);\n    }\n\n    // reset the cached userIgnored anymatch fn\n    // to make ignoredPaths changes effective\n    this._userIgnored = undefined;\n  });\n\n  return this;\n}\n\n/**\n * Close watchers and remove all listeners from watched paths.\n * @returns {Promise<void>}.\n*/\nclose() {\n  if (this.closed) return this._closePromise;\n  this.closed = true;\n\n  // Memory management.\n  this.removeAllListeners();\n  const closers = [];\n  this._closers.forEach(closerList => closerList.forEach(closer => {\n    const promise = closer();\n    if (promise instanceof Promise) closers.push(promise);\n  }));\n  this._streams.forEach(stream => stream.destroy());\n  this._userIgnored = undefined;\n  this._readyCount = 0;\n  this._readyEmitted = false;\n  this._watched.forEach(dirent => dirent.dispose());\n  ['closers', 'watched', 'streams', 'symlinkPaths', 'throttled'].forEach(key => {\n    this[`_${key}`].clear();\n  });\n\n  this._closePromise = closers.length ? Promise.all(closers).then(() => undefined) : Promise.resolve();\n  return this._closePromise;\n}\n\n/**\n * Expose list of watched paths\n * @returns {Object} for chaining\n*/\ngetWatched() {\n  const watchList = {};\n  this._watched.forEach((entry, dir) => {\n    const key = this.options.cwd ? path.relative(this.options.cwd, dir) : dir;\n    watchList[key || ONE_DOT] = entry.getChildren().sort();\n  });\n  return watchList;\n}\n\nemitWithAll(event, args) {\n  this.emit(...args);\n  if (event !== EV_ERROR$2) this.emit(EV_ALL, ...args);\n}\n\n// Common helpers\n// --------------\n\n/**\n * Normalize and emit events.\n * Calling _emit DOES NOT MEAN emit() would be called!\n * @param {EventName} event Type of event\n * @param {Path} path File or directory path\n * @param {*=} val1 arguments to be passed with event\n * @param {*=} val2\n * @param {*=} val3\n * @returns the error if defined, otherwise the value of the FSWatcher instance's `closed` flag\n */\nasync _emit(event, path$1, val1, val2, val3) {\n  if (this.closed) return;\n\n  const opts = this.options;\n  if (isWindows$1) path$1 = path.normalize(path$1);\n  if (opts.cwd) path$1 = path.relative(opts.cwd, path$1);\n  /** @type Array<any> */\n  const args = [event, path$1];\n  if (val3 !== undefined) args.push(val1, val2, val3);\n  else if (val2 !== undefined) args.push(val1, val2);\n  else if (val1 !== undefined) args.push(val1);\n\n  const awf = opts.awaitWriteFinish;\n  let pw;\n  if (awf && (pw = this._pendingWrites.get(path$1))) {\n    pw.lastChange = new Date();\n    return this;\n  }\n\n  if (opts.atomic) {\n    if (event === EV_UNLINK$1) {\n      this._pendingUnlinks.set(path$1, args);\n      setTimeout(() => {\n        this._pendingUnlinks.forEach((entry, path) => {\n          this.emit(...entry);\n          this.emit(EV_ALL, ...entry);\n          this._pendingUnlinks.delete(path);\n        });\n      }, typeof opts.atomic === 'number' ? opts.atomic : 100);\n      return this;\n    }\n    if (event === EV_ADD$2 && this._pendingUnlinks.has(path$1)) {\n      event = args[0] = EV_CHANGE$2;\n      this._pendingUnlinks.delete(path$1);\n    }\n  }\n\n  if (awf && (event === EV_ADD$2 || event === EV_CHANGE$2) && this._readyEmitted) {\n    const awfEmit = (err, stats) => {\n      if (err) {\n        event = args[0] = EV_ERROR$2;\n        args[1] = err;\n        this.emitWithAll(event, args);\n      } else if (stats) {\n        // if stats doesn't exist the file must have been deleted\n        if (args.length > 2) {\n          args[2] = stats;\n        } else {\n          args.push(stats);\n        }\n        this.emitWithAll(event, args);\n      }\n    };\n\n    this._awaitWriteFinish(path$1, awf.stabilityThreshold, event, awfEmit);\n    return this;\n  }\n\n  if (event === EV_CHANGE$2) {\n    const isThrottled = !this._throttle(EV_CHANGE$2, path$1, 50);\n    if (isThrottled) return this;\n  }\n\n  if (opts.alwaysStat && val1 === undefined &&\n    (event === EV_ADD$2 || event === EV_ADD_DIR$2 || event === EV_CHANGE$2)\n  ) {\n    const fullPath = opts.cwd ? path.join(opts.cwd, path$1) : path$1;\n    let stats;\n    try {\n      stats = await stat$3(fullPath);\n    } catch (err) {}\n    // Suppress event when fs_stat fails, to avoid sending undefined 'stat'\n    if (!stats || this.closed) return;\n    args.push(stats);\n  }\n  this.emitWithAll(event, args);\n\n  return this;\n}\n\n/**\n * Common handler for errors\n * @param {Error} error\n * @returns {Error|Boolean} The error if defined, otherwise the value of the FSWatcher instance's `closed` flag\n */\n_handleError(error) {\n  const code = error && error.code;\n  if (error && code !== 'ENOENT' && code !== 'ENOTDIR' &&\n    (!this.options.ignorePermissionErrors || (code !== 'EPERM' && code !== 'EACCES'))\n  ) {\n    this.emit(EV_ERROR$2, error);\n  }\n  return error || this.closed;\n}\n\n/**\n * Helper utility for throttling\n * @param {ThrottleType} actionType type being throttled\n * @param {Path} path being acted upon\n * @param {Number} timeout duration of time to suppress duplicate actions\n * @returns {Object|false} tracking object or false if action should be suppressed\n */\n_throttle(actionType, path, timeout) {\n  if (!this._throttled.has(actionType)) {\n    this._throttled.set(actionType, new Map());\n  }\n\n  /** @type {Map<Path, Object>} */\n  const action = this._throttled.get(actionType);\n  /** @type {Object} */\n  const actionPath = action.get(path);\n\n  if (actionPath) {\n    actionPath.count++;\n    return false;\n  }\n\n  let timeoutObject;\n  const clear = () => {\n    const item = action.get(path);\n    const count = item ? item.count : 0;\n    action.delete(path);\n    clearTimeout(timeoutObject);\n    if (item) clearTimeout(item.timeoutObject);\n    return count;\n  };\n  timeoutObject = setTimeout(clear, timeout);\n  const thr = {timeoutObject, clear, count: 0};\n  action.set(path, thr);\n  return thr;\n}\n\n_incrReadyCount() {\n  return this._readyCount++;\n}\n\n/**\n * Awaits write operation to finish.\n * Polls a newly created file for size variations. When files size does not change for 'threshold' milliseconds calls callback.\n * @param {Path} path being acted upon\n * @param {Number} threshold Time in milliseconds a file size must be fixed before acknowledging write OP is finished\n * @param {EventName} event\n * @param {Function} awfEmit Callback to be called when ready for event to be emitted.\n */\n_awaitWriteFinish(path$1, threshold, event, awfEmit) {\n  let timeoutHandler;\n\n  let fullPath = path$1;\n  if (this.options.cwd && !path.isAbsolute(path$1)) {\n    fullPath = path.join(this.options.cwd, path$1);\n  }\n\n  const now = new Date();\n\n  const awaitWriteFinish = (prevStat) => {\n    fs.stat(fullPath, (err, curStat) => {\n      if (err || !this._pendingWrites.has(path$1)) {\n        if (err && err.code !== 'ENOENT') awfEmit(err);\n        return;\n      }\n\n      const now = Number(new Date());\n\n      if (prevStat && curStat.size !== prevStat.size) {\n        this._pendingWrites.get(path$1).lastChange = now;\n      }\n      const pw = this._pendingWrites.get(path$1);\n      const df = now - pw.lastChange;\n\n      if (df >= threshold) {\n        this._pendingWrites.delete(path$1);\n        awfEmit(undefined, curStat);\n      } else {\n        timeoutHandler = setTimeout(\n          awaitWriteFinish,\n          this.options.awaitWriteFinish.pollInterval,\n          curStat\n        );\n      }\n    });\n  };\n\n  if (!this._pendingWrites.has(path$1)) {\n    this._pendingWrites.set(path$1, {\n      lastChange: now,\n      cancelWait: () => {\n        this._pendingWrites.delete(path$1);\n        clearTimeout(timeoutHandler);\n        return event;\n      }\n    });\n    timeoutHandler = setTimeout(\n      awaitWriteFinish,\n      this.options.awaitWriteFinish.pollInterval\n    );\n  }\n}\n\n_getGlobIgnored() {\n  return [...this._ignoredPaths.values()];\n}\n\n/**\n * Determines whether user has asked to ignore this path.\n * @param {Path} path filepath or dir\n * @param {fs.Stats=} stats result of fs.stat\n * @returns {Boolean}\n */\n_isIgnored(path, stats) {\n  if (this.options.atomic && DOT_RE.test(path)) return true;\n  if (!this._userIgnored) {\n    const {cwd} = this.options;\n    const ign = this.options.ignored;\n\n    const ignored = ign && ign.map(normalizeIgnored(cwd));\n    const paths = arrify(ignored)\n      .filter((path) => typeof path === STRING_TYPE && !isGlob(path))\n      .map((path) => path + SLASH_GLOBSTAR);\n    const list = this._getGlobIgnored().map(normalizeIgnored(cwd)).concat(ignored, paths);\n    this._userIgnored = anymatch(list, undefined, ANYMATCH_OPTS);\n  }\n\n  return this._userIgnored([path, stats]);\n}\n\n_isntIgnored(path, stat) {\n  return !this._isIgnored(path, stat);\n}\n\n/**\n * Provides a set of common helpers and properties relating to symlink and glob handling.\n * @param {Path} path file, directory, or glob pattern being watched\n * @param {Number=} depth at any depth > 0, this isn't a glob\n * @returns {WatchHelper} object containing helpers for this path\n */\n_getWatchHelpers(path, depth) {\n  const watchPath = depth || this.options.disableGlobbing || !isGlob(path) ? path : globParent(path);\n  const follow = this.options.followSymlinks;\n\n  return new WatchHelper(path, watchPath, follow, this);\n}\n\n// Directory helpers\n// -----------------\n\n/**\n * Provides directory tracking objects\n * @param {String} directory path of the directory\n * @returns {DirEntry} the directory's tracking object\n */\n_getWatchedDir(directory) {\n  if (!this._boundRemove) this._boundRemove = this._remove.bind(this);\n  const dir = path.resolve(directory);\n  if (!this._watched.has(dir)) this._watched.set(dir, new DirEntry(dir, this._boundRemove));\n  return this._watched.get(dir);\n}\n\n// File helpers\n// ------------\n\n/**\n * Check for read permissions.\n * Based on this answer on SO: https://stackoverflow.com/a/11781404/1358405\n * @param {fs.Stats} stats - object, result of fs_stat\n * @returns {Boolean} indicates whether the file can be read\n*/\n_hasReadPermissions(stats) {\n  if (this.options.ignorePermissionErrors) return true;\n\n  // stats.mode may be bigint\n  const md = stats && Number.parseInt(stats.mode, 10);\n  const st = md & 0o777;\n  const it = Number.parseInt(st.toString(8)[0], 10);\n  return Boolean(4 & it);\n}\n\n/**\n * Handles emitting unlink events for\n * files and directories, and via recursion, for\n * files and directories within directories that are unlinked\n * @param {String} directory within which the following item is located\n * @param {String} item      base path of item/directory\n * @returns {void}\n*/\n_remove(directory, item, isDirectory) {\n  // if what is being deleted is a directory, get that directory's paths\n  // for recursive deleting and cleaning of watched object\n  // if it is not a directory, nestedDirectoryChildren will be empty array\n  const path$1 = path.join(directory, item);\n  const fullPath = path.resolve(path$1);\n  isDirectory = isDirectory != null\n    ? isDirectory\n    : this._watched.has(path$1) || this._watched.has(fullPath);\n\n  // prevent duplicate handling in case of arriving here nearly simultaneously\n  // via multiple paths (such as _handleFile and _handleDir)\n  if (!this._throttle('remove', path$1, 100)) return;\n\n  // if the only watched file is removed, watch for its return\n  if (!isDirectory && !this.options.useFsEvents && this._watched.size === 1) {\n    this.add(directory, item, true);\n  }\n\n  // This will create a new entry in the watched object in either case\n  // so we got to do the directory check beforehand\n  const wp = this._getWatchedDir(path$1);\n  const nestedDirectoryChildren = wp.getChildren();\n\n  // Recursively remove children directories / files.\n  nestedDirectoryChildren.forEach(nested => this._remove(path$1, nested));\n\n  // Check if item was on the watched list and remove it\n  const parent = this._getWatchedDir(directory);\n  const wasTracked = parent.has(item);\n  parent.remove(item);\n\n  // If we wait for this file to be fully written, cancel the wait.\n  let relPath = path$1;\n  if (this.options.cwd) relPath = path.relative(this.options.cwd, path$1);\n  if (this.options.awaitWriteFinish && this._pendingWrites.has(relPath)) {\n    const event = this._pendingWrites.get(relPath).cancelWait();\n    if (event === EV_ADD$2) return;\n  }\n\n  // The Entry will either be a directory that just got removed\n  // or a bogus entry to a file, in either case we have to remove it\n  this._watched.delete(path$1);\n  this._watched.delete(fullPath);\n  const eventName = isDirectory ? EV_UNLINK_DIR : EV_UNLINK$1;\n  if (wasTracked && !this._isIgnored(path$1)) this._emit(eventName, path$1);\n\n  // Avoid conflicts if we later create another file with the same name\n  if (!this.options.useFsEvents) {\n    this._closePath(path$1);\n  }\n}\n\n/**\n *\n * @param {Path} path\n */\n_closePath(path$1) {\n  const closers = this._closers.get(path$1);\n  if (!closers) return;\n  closers.forEach(closer => closer());\n  this._closers.delete(path$1);\n  const dir = path.dirname(path$1);\n  this._getWatchedDir(dir).remove(path.basename(path$1));\n}\n\n/**\n *\n * @param {Path} path\n * @param {Function} closer\n */\n_addPathCloser(path, closer) {\n  if (!closer) return;\n  let list = this._closers.get(path);\n  if (!list) {\n    list = [];\n    this._closers.set(path, list);\n  }\n  list.push(closer);\n}\n\n_readdirp(root, opts) {\n  if (this.closed) return;\n  const options = {type: EV_ALL, alwaysStat: true, lstat: true, ...opts};\n  let stream = readdirp_1(root, options);\n  this._streams.add(stream);\n  stream.once(STR_CLOSE, () => {\n    stream = undefined;\n  });\n  stream.once(STR_END$2, () => {\n    if (stream) {\n      this._streams.delete(stream);\n      stream = undefined;\n    }\n  });\n  return stream;\n}\n\n}\n\n// Export FSWatcher class\nvar FSWatcher_1 = FSWatcher;\n\n/**\n * Instantiates watcher with paths to be tracked.\n * @param {String|Array<String>} paths file/directory paths and/or globs\n * @param {Object=} options chokidar opts\n * @returns an instance of FSWatcher for chaining.\n */\nconst watch = (paths, options) => {\n  const watcher = new FSWatcher(options);\n  watcher.add(paths);\n  return watcher;\n};\n\nvar watch_1 = watch;\n\nvar chokidar = {\n\tFSWatcher: FSWatcher_1,\n\twatch: watch_1\n};\n\nclass FileWatcher {\n    constructor(task, chokidarOptions) {\n        this.transformWatchers = new Map();\n        this.chokidarOptions = chokidarOptions;\n        this.task = task;\n        this.watcher = this.createWatcher(null);\n    }\n    close() {\n        this.watcher.close();\n        for (const watcher of this.transformWatchers.values()) {\n            watcher.close();\n        }\n    }\n    unwatch(id) {\n        this.watcher.unwatch(id);\n        const transformWatcher = this.transformWatchers.get(id);\n        if (transformWatcher) {\n            this.transformWatchers.delete(id);\n            transformWatcher.close();\n        }\n    }\n    watch(id, isTransformDependency) {\n        if (isTransformDependency) {\n            const watcher = this.transformWatchers.get(id) || this.createWatcher(id);\n            watcher.add(id);\n            this.transformWatchers.set(id, watcher);\n        }\n        else {\n            this.watcher.add(id);\n        }\n    }\n    createWatcher(transformWatcherId) {\n        const task = this.task;\n        const isLinux = platform() === 'linux';\n        const isTransformDependency = transformWatcherId !== null;\n        const handleChange = (id) => {\n            const changedId = transformWatcherId || id;\n            if (isLinux) {\n                // unwatching and watching fixes an issue with chokidar where on certain systems,\n                // a file that was unlinked and immediately recreated would create a change event\n                // but then no longer any further events\n                watcher.unwatch(changedId);\n                watcher.add(changedId);\n            }\n            task.invalidate(changedId, isTransformDependency);\n        };\n        const watcher = chokidar\n            .watch([], this.chokidarOptions)\n            .on('change', handleChange)\n            .on('unlink', handleChange);\n        return watcher;\n    }\n}\n\nclass Watcher {\n    constructor(configs, emitter) {\n        this.buildDelay = 0;\n        this.buildTimeout = null;\n        this.invalidatedIds = new Set();\n        this.rerun = false;\n        this.emitter = emitter;\n        emitter.close = this.close.bind(this);\n        this.tasks = configs.map(config => new Task(this, config));\n        this.buildDelay = configs.reduce((buildDelay, { watch }) => watch && typeof watch.buildDelay === 'number'\n            ? Math.max(buildDelay, watch.buildDelay)\n            : buildDelay, this.buildDelay);\n        this.running = true;\n        process.nextTick(() => this.run());\n    }\n    close() {\n        if (this.buildTimeout)\n            clearTimeout(this.buildTimeout);\n        for (const task of this.tasks) {\n            task.close();\n        }\n        this.emitter.removeAllListeners();\n    }\n    emit(event, value) {\n        this.emitter.emit(event, value);\n    }\n    invalidate(id) {\n        if (id) {\n            this.invalidatedIds.add(id);\n        }\n        if (this.running) {\n            this.rerun = true;\n            return;\n        }\n        if (this.buildTimeout)\n            clearTimeout(this.buildTimeout);\n        this.buildTimeout = setTimeout(() => {\n            this.buildTimeout = null;\n            for (const id of this.invalidatedIds) {\n                this.emit('change', id);\n            }\n            this.invalidatedIds.clear();\n            this.emit('restart');\n            this.run();\n        }, this.buildDelay);\n    }\n    async run() {\n        this.running = true;\n        this.emit('event', {\n            code: 'START'\n        });\n        try {\n            for (const task of this.tasks) {\n                await task.run();\n            }\n            this.running = false;\n            this.emit('event', {\n                code: 'END'\n            });\n        }\n        catch (error) {\n            this.running = false;\n            this.emit('event', {\n                code: 'ERROR',\n                error\n            });\n        }\n        if (this.rerun) {\n            this.rerun = false;\n            this.invalidate();\n        }\n    }\n}\nclass Task {\n    constructor(watcher, config) {\n        this.cache = { modules: [] };\n        this.watchFiles = [];\n        this.invalidated = true;\n        this.watcher = watcher;\n        this.closed = false;\n        this.watched = new Set();\n        this.skipWrite = config.watch && !!config.watch.skipWrite;\n        this.options = mergeOptions(config);\n        this.outputs = this.options.output;\n        this.outputFiles = this.outputs.map(output => {\n            if (output.file || output.dir)\n                return resolve(output.file || output.dir);\n            return undefined;\n        });\n        const watchOptions = this.options.watch || {};\n        this.filter = createFilter(watchOptions.include, watchOptions.exclude);\n        this.fileWatcher = new FileWatcher(this, {\n            ...watchOptions.chokidar,\n            disableGlobbing: true,\n            ignoreInitial: true\n        });\n    }\n    close() {\n        this.closed = true;\n        this.fileWatcher.close();\n    }\n    invalidate(id, isTransformDependency) {\n        this.invalidated = true;\n        if (isTransformDependency) {\n            for (const module of this.cache.modules) {\n                if (module.transformDependencies.indexOf(id) === -1)\n                    continue;\n                // effective invalidation\n                module.originalCode = null;\n            }\n        }\n        this.watcher.invalidate(id);\n    }\n    async run() {\n        if (!this.invalidated)\n            return;\n        this.invalidated = false;\n        const options = {\n            ...this.options,\n            cache: this.cache\n        };\n        const start = Date.now();\n        this.watcher.emit('event', {\n            code: 'BUNDLE_START',\n            input: this.options.input,\n            output: this.outputFiles\n        });\n        try {\n            const result = await rollupInternal(options, this.watcher.emitter);\n            if (this.closed) {\n                return;\n            }\n            this.updateWatchedFiles(result);\n            this.skipWrite || (await Promise.all(this.outputs.map(output => result.write(output))));\n            this.watcher.emit('event', {\n                code: 'BUNDLE_END',\n                duration: Date.now() - start,\n                input: this.options.input,\n                output: this.outputFiles,\n                result\n            });\n        }\n        catch (error) {\n            if (this.closed) {\n                return;\n            }\n            if (Array.isArray(error.watchFiles)) {\n                for (const id of error.watchFiles) {\n                    this.watchFile(id);\n                }\n            }\n            if (error.id) {\n                this.cache.modules = this.cache.modules.filter(module => module.id !== error.id);\n            }\n            throw error;\n        }\n    }\n    updateWatchedFiles(result) {\n        const previouslyWatched = this.watched;\n        this.watched = new Set();\n        this.watchFiles = result.watchFiles;\n        this.cache = result.cache;\n        for (const id of this.watchFiles) {\n            this.watchFile(id);\n        }\n        for (const module of this.cache.modules) {\n            for (const depId of module.transformDependencies) {\n                this.watchFile(depId, true);\n            }\n        }\n        for (const id of previouslyWatched) {\n            if (!this.watched.has(id)) {\n                this.fileWatcher.unwatch(id);\n            }\n        }\n    }\n    watchFile(id, isTransformDependency = false) {\n        if (!this.filter(id))\n            return;\n        this.watched.add(id);\n        if (this.outputFiles.some(file => file === id)) {\n            throw new Error('Cannot import the generated bundle');\n        }\n        // this is necessary to ensure that any 'renamed' files\n        // continue to be watched following an error\n        this.fileWatcher.watch(id, isTransformDependency);\n    }\n}\n\nexport { Task, Watcher };\n","exports.endianness = function () { return 'LE' };\n\nexports.hostname = function () {\n    if (typeof location !== 'undefined') {\n        return location.hostname\n    }\n    else return '';\n};\n\nexports.loadavg = function () { return [] };\n\nexports.uptime = function () { return 0 };\n\nexports.freemem = function () {\n    return Number.MAX_VALUE;\n};\n\nexports.totalmem = function () {\n    return Number.MAX_VALUE;\n};\n\nexports.cpus = function () { return [] };\n\nexports.type = function () { return 'Browser' };\n\nexports.release = function () {\n    if (typeof navigator !== 'undefined') {\n        return navigator.appVersion;\n    }\n    return '';\n};\n\nexports.networkInterfaces\n= exports.getNetworkInterfaces\n= function () { return {} };\n\nexports.arch = function () { return 'javascript' };\n\nexports.platform = function () { return 'browser' };\n\nexports.tmpdir = exports.tmpDir = function () {\n    return '/tmp';\n};\n\nexports.EOL = '\\n';\n\nexports.homedir = function () {\n\treturn '/'\n};\n"],"sourceRoot":""}